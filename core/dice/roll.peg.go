package dice

// Code generated by C:\Users\fy0\go\bin\peg.exe -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rules0
	ruleblock
	rulestmtElse
	rulestmtIf
	rulee0
	ruleeSimpleSwitch
	ruleeTernary
	ruleeBitwise
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	rulesimpleDice2
	rulewodDicePool
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulebitwiseOr
	rulelogicOr
	rulebitwiseAnd
	rulelogicAnd
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulestrPart
	rulestrPart1
	rulestrPart2
	rulestrPart3
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
	rulePegText
	ruleAction71
	ruleAction72
	ruleAction73
	ruleAction74
	ruleAction75
	ruleAction76
	ruleAction77
	ruleAction78
	ruleAction79
	ruleAction80
	ruleAction81
	ruleAction82
	ruleAction83
	ruleAction84
	ruleAction85
	ruleAction86
	ruleAction87
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"s0",
	"block",
	"stmtElse",
	"stmtIf",
	"e0",
	"eSimpleSwitch",
	"eTernary",
	"eBitwise",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"simpleDice2",
	"wodDicePool",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"bitwiseOr",
	"logicOr",
	"bitwiseAnd",
	"logicAnd",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"strPart",
	"strPart1",
	"strPart2",
	"strPart3",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
	"PegText",
	"Action71",
	"Action72",
	"Action73",
	"Action74",
	"Action75",
	"Action76",
	"Action77",
	"Action78",
	"Action79",
	"Action80",
	"Action81",
	"Action82",
	"Action83",
	"Action84",
	"Action85",
	"Action86",
	"Action87",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [147]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypePop)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddValueStr("")
		case ruleAction9:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction10:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction11:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction12:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction13:
			p.PopAndSetOffset()
		case ruleAction14:
			p.CounterPush()
		case ruleAction15:
			p.CounterAdd(1)
		case ruleAction16:
			p.AddValueStr("")
			limit := p.CounterPop() + 1
			for i := int64(0); i < limit; i++ {
				p.PopAndSetOffset()
			}
		case ruleAction17:
			p.AddLeftValueMark()
		case ruleAction18:
			p.AddOperator(TypeBitwiseOr)
		case ruleAction19:
			p.AddLeftValueMark()
		case ruleAction20:
			p.AddOperator(TypeBitwiseAnd)
		case ruleAction21:
			p.AddLeftValueMark()
		case ruleAction22:
			p.AddOperator(TypeCompLT)
		case ruleAction23:
			p.AddLeftValueMark()
		case ruleAction24:
			p.AddOperator(TypeCompLE)
		case ruleAction25:
			p.AddLeftValueMark()
		case ruleAction26:
			p.AddOperator(TypeCompEQ)
		case ruleAction27:
			p.AddLeftValueMark()
		case ruleAction28:
			p.AddOperator(TypeCompNE)
		case ruleAction29:
			p.AddLeftValueMark()
		case ruleAction30:
			p.AddOperator(TypeCompGE)
		case ruleAction31:
			p.AddLeftValueMark()
		case ruleAction32:
			p.AddOperator(TypeCompGT)
		case ruleAction33:
			p.AddLeftValueMark()
		case ruleAction34:
			p.AddOperator(TypeAdd)
		case ruleAction35:
			p.AddLeftValueMark()
		case ruleAction36:
			p.AddOperator(TypeSubtract)
		case ruleAction37:
			p.AddLeftValueMark()
		case ruleAction38:
			p.AddOperator(TypeMultiply)
		case ruleAction39:
			p.AddLeftValueMark()
		case ruleAction40:
			p.AddOperator(TypeDivide)
		case ruleAction41:
			p.AddLeftValueMark()
		case ruleAction42:
			p.AddOperator(TypeModulus)
		case ruleAction43:
			p.AddLeftValueMark()
		case ruleAction44:
			p.AddOperator(TypeExponentiation)
		case ruleAction45:
			p.AddOperator(TypeNegation)
		case ruleAction46:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction47:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction48:
			p.AddOperator(TypeDiceSetK)
		case ruleAction49:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction50:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction51:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction52:
			p.AddOperator(TypeWodSetInit)
		case ruleAction53:
			p.AddOperator(TypeWodSetPool)
		case ruleAction54:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction55:
			p.AddOperator(TypeDice)
		case ruleAction56:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction57:
			p.AddOperator(TypeDice)
		case ruleAction58:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction59:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction60:
			p.AddOperator(TypeWodSetPoints)
		case ruleAction61:
			p.AddOperator(TypeWodSetThreshold)
		case ruleAction62:
			p.AddOperator(TypeDiceWod)
		case ruleAction63:
			p.AddLeftValueMark()
		case ruleAction64:
			p.AddOperator(TypeDice)
		case ruleAction65:
			p.AddOperator(TypeDicePenalty)
		case ruleAction66:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction67:
			p.AddOperator(TypeDiceBonus)
		case ruleAction68:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction69:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction70:
			p.AddLoadVarname(string(text))
		case ruleAction71:
			p.AddValue(string(text))
		case ruleAction72:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction73:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction74:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction75:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction76:
			p.CounterPush()
		case ruleAction77:
			p.CounterAdd(1)
		case ruleAction78:
			p.CounterAdd(1)
		case ruleAction79:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction80:
			p.CounterPush()
		case ruleAction81:
			p.CounterAdd(1)
		case ruleAction82:
			p.CounterAdd(1)
		case ruleAction83:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction84:
			p.CounterPush()
		case ruleAction85:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction86:
			p.CounterPush()
		case ruleAction87:
			p.AddFormatString(string(text), p.CounterPop())

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulee]() {
					goto l0
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <(eOne (';' sp Action1 eOne?)*)> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				if !_rules[ruleeOne]() {
					goto l3
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if buffer[position] != rune(';') {
						goto l6
					}
					position++
					if !_rules[rulesp]() {
						goto l6
					}
					{
						add(ruleAction1, position)
					}
					{
						position8, tokenIndex8 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l8
						}
						goto l9
					l8:
						position, tokenIndex = position8, tokenIndex8
					}
				l9:
					goto l5
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(rulee, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 eOne <- <(sp (s0 / e0 / assign_expr))> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[rulesp]() {
					goto l10
				}
				{
					position12, tokenIndex12 := position, tokenIndex
					{
						position14 := position
						{
							position15 := position
							if buffer[position] != rune('i') {
								goto l13
							}
							position++
							if buffer[position] != rune('f') {
								goto l13
							}
							position++
							if !_rules[rulesp]() {
								goto l13
							}
							if !_rules[rulee0]() {
								goto l13
							}
							{
								add(ruleAction5, position)
							}
							if !_rules[ruleblock]() {
								goto l13
							}
							{
								add(ruleAction6, position)
							}
							{
								position18, tokenIndex18 := position, tokenIndex
								{
									position20 := position
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if buffer[position] != rune('l') {
										goto l18
									}
									position++
									if buffer[position] != rune('s') {
										goto l18
									}
									position++
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if !_rules[rulesp]() {
										goto l18
									}
									if !_rules[ruleblock]() {
										goto l18
									}
									add(rulestmtElse, position20)
								}
								goto l19
							l18:
								position, tokenIndex = position18, tokenIndex18
							}
						l19:
							{
								add(ruleAction7, position)
							}
							{
								add(ruleAction8, position)
							}
							add(rulestmtIf, position15)
						}
						add(rules0, position14)
					}
					goto l12
				l13:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[rulee0]() {
						goto l23
					}
					goto l12
				l23:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleassign_expr]() {
						goto l10
					}
				}
			l12:
				add(ruleeOne, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' sp e0 Action3)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if !_rules[ruleidentifier]() {
					goto l24
				}
				{
					add(ruleAction2, position)
				}
				if buffer[position] != rune('=') {
					goto l24
				}
				position++
				if !_rules[rulesp]() {
					goto l24
				}
				if !_rules[rulee0]() {
					goto l24
				}
				{
					add(ruleAction3, position)
				}
				add(ruleassign_expr, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 4 s0 <- <stmtIf> */
		nil,
		/* 5 block <- <((('{' sp '}') / ('{' sp e Action4 '}')) sp)> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				{
					position31, tokenIndex31 := position, tokenIndex
					if buffer[position] != rune('{') {
						goto l32
					}
					position++
					if !_rules[rulesp]() {
						goto l32
					}
					if buffer[position] != rune('}') {
						goto l32
					}
					position++
					goto l31
				l32:
					position, tokenIndex = position31, tokenIndex31
					if buffer[position] != rune('{') {
						goto l29
					}
					position++
					if !_rules[rulesp]() {
						goto l29
					}
					if !_rules[rulee]() {
						goto l29
					}
					{
						add(ruleAction4, position)
					}
					if buffer[position] != rune('}') {
						goto l29
					}
					position++
				}
			l31:
				if !_rules[rulesp]() {
					goto l29
				}
				add(ruleblock, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 6 stmtElse <- <('e' 'l' 's' 'e' sp block)> */
		nil,
		/* 7 stmtIf <- <('i' 'f' sp e0 Action5 block Action6 stmtElse? Action7 Action8)> */
		nil,
		/* 8 e0 <- <eTernary> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				{
					position38 := position
					{
						position39, tokenIndex39 := position, tokenIndex
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune('?') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction11, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune(':') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction12, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						{
							add(ruleAction13, position)
						}
						goto l39
					l40:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeSimpleSwitch]() {
							goto l44
						}
						{
							add(ruleAction14, position)
						}
					l46:
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l47
							}
							position++
							if !_rules[rulesp]() {
								goto l47
							}
							if !_rules[ruleeSimpleSwitch]() {
								goto l47
							}
							{
								add(ruleAction15, position)
							}
							goto l46
						l47:
							position, tokenIndex = position47, tokenIndex47
						}
						{
							add(ruleAction16, position)
						}
						goto l39
					l44:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeBitwise]() {
							goto l36
						}
					}
				l39:
					add(ruleeTernary, position38)
				}
				add(rulee0, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 9 eSimpleSwitch <- <(eBitwise '?' sp Action9 eBitwise Action10)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				if buffer[position] != rune('?') {
					goto l50
				}
				position++
				if !_rules[rulesp]() {
					goto l50
				}
				{
					add(ruleAction9, position)
				}
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				{
					add(ruleAction10, position)
				}
				add(ruleeSimpleSwitch, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 10 eTernary <- <((eBitwise '?' sp Action11 eBitwise ':' sp Action12 eBitwise Action13) / (eSimpleSwitch Action14 (',' sp eSimpleSwitch Action15)* Action16) / eBitwise)> */
		nil,
		/* 11 eBitwise <- <(eComp (((logicOr / bitwiseOr) Action17 eComp Action18) / ((logicAnd / bitwiseAnd) Action19 eComp Action20))*)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleeComp]() {
					goto l55
				}
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						{
							position61, tokenIndex61 := position, tokenIndex
							{
								position63 := position
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if !_rules[rulesp]() {
									goto l62
								}
								add(rulelogicOr, position63)
							}
							goto l61
						l62:
							position, tokenIndex = position61, tokenIndex61
							{
								position64 := position
								if buffer[position] != rune('|') {
									goto l60
								}
								position++
								if !_rules[rulesp]() {
									goto l60
								}
								add(rulebitwiseOr, position64)
							}
						}
					l61:
						{
							add(ruleAction17, position)
						}
						if !_rules[ruleeComp]() {
							goto l60
						}
						{
							add(ruleAction18, position)
						}
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						{
							position67, tokenIndex67 := position, tokenIndex
							{
								position69 := position
								{
									position70, tokenIndex70 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									goto l70
								l71:
									position, tokenIndex = position70, tokenIndex70
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
								}
							l70:
								if !_rules[rulesp]() {
									goto l68
								}
								add(rulelogicAnd, position69)
							}
							goto l67
						l68:
							position, tokenIndex = position67, tokenIndex67
							{
								position72 := position
								{
									position73, tokenIndex73 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l74
									}
									position++
									goto l73
								l74:
									position, tokenIndex = position73, tokenIndex73
									if buffer[position] != rune('&') {
										goto l58
									}
									position++
									if buffer[position] != rune('a') {
										goto l58
									}
									position++
									if buffer[position] != rune('m') {
										goto l58
									}
									position++
									if buffer[position] != rune('p') {
										goto l58
									}
									position++
									if buffer[position] != rune(';') {
										goto l58
									}
									position++
								}
							l73:
								if !_rules[rulesp]() {
									goto l58
								}
								add(rulebitwiseAnd, position72)
							}
						}
					l67:
						{
							add(ruleAction19, position)
						}
						if !_rules[ruleeComp]() {
							goto l58
						}
						{
							add(ruleAction20, position)
						}
					}
				l59:
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(ruleeBitwise, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 12 eComp <- <(e1 ((lt Action21 e1 Action22) / (ge Action29 e1 Action30) / ((&('>') (gt Action31 e1 Action32)) | (&('!') (ne Action27 e1 Action28)) | (&('=') (eq Action25 e1 Action26)) | (&('<') (le Action23 e1 Action24))))*)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if !_rules[rulee1]() {
					goto l77
				}
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					{
						position81, tokenIndex81 := position, tokenIndex
						{
							position83 := position
							{
								position84, tokenIndex84 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l85
								}
								position++
								goto l84
							l85:
								position, tokenIndex = position84, tokenIndex84
								if buffer[position] != rune('＜') {
									goto l82
								}
								position++
							}
						l84:
							if !_rules[rulesp]() {
								goto l82
							}
							add(rulelt, position83)
						}
						{
							add(ruleAction21, position)
						}
						if !_rules[rulee1]() {
							goto l82
						}
						{
							add(ruleAction22, position)
						}
						goto l81
					l82:
						position, tokenIndex = position81, tokenIndex81
						{
							position89 := position
							{
								position90, tokenIndex90 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l91
								}
								position++
								if buffer[position] != rune('=') {
									goto l91
								}
								position++
								goto l90
							l91:
								position, tokenIndex = position90, tokenIndex90
								if buffer[position] != rune('＞') {
									goto l88
								}
								position++
								if buffer[position] != rune('＝') {
									goto l88
								}
								position++
							}
						l90:
							if !_rules[rulesp]() {
								goto l88
							}
							add(rulege, position89)
						}
						{
							add(ruleAction29, position)
						}
						if !_rules[rulee1]() {
							goto l88
						}
						{
							add(ruleAction30, position)
						}
						goto l81
					l88:
						position, tokenIndex = position81, tokenIndex81
						{
							switch buffer[position] {
							case '>':
								{
									position95 := position
									{
										position96, tokenIndex96 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l97
										}
										position++
										goto l96
									l97:
										position, tokenIndex = position96, tokenIndex96
										if buffer[position] != rune('＞') {
											goto l80
										}
										position++
									}
								l96:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulegt, position95)
								}
								{
									add(ruleAction31, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction32, position)
								}
							case '!':
								{
									position100 := position
									{
										position101, tokenIndex101 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l102
										}
										position++
										if buffer[position] != rune('=') {
											goto l102
										}
										position++
										goto l101
									l102:
										position, tokenIndex = position101, tokenIndex101
										if buffer[position] != rune('！') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l101:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulene, position100)
								}
								{
									add(ruleAction27, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction28, position)
								}
							case '=':
								{
									position105 := position
									{
										position106, tokenIndex106 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										goto l106
									l107:
										position, tokenIndex = position106, tokenIndex106
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l106:
									if !_rules[rulesp]() {
										goto l80
									}
									add(ruleeq, position105)
								}
								{
									add(ruleAction25, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction26, position)
								}
							default:
								{
									position110 := position
									{
										position111, tokenIndex111 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l112
										}
										position++
										if buffer[position] != rune('=') {
											goto l112
										}
										position++
										goto l111
									l112:
										position, tokenIndex = position111, tokenIndex111
										if buffer[position] != rune('＜') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l111:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulele, position110)
								}
								{
									add(ruleAction23, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction24, position)
								}
							}
						}

					}
				l81:
					goto l79
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
				add(ruleeComp, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 13 e1 <- <(e2 ((add Action33 e2 Action34) / (minus Action35 e2 Action36))*)> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				if !_rules[rulee2]() {
					goto l115
				}
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					{
						position119, tokenIndex119 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l120
						}
						{
							add(ruleAction33, position)
						}
						if !_rules[rulee2]() {
							goto l120
						}
						{
							add(ruleAction34, position)
						}
						goto l119
					l120:
						position, tokenIndex = position119, tokenIndex119
						if !_rules[ruleminus]() {
							goto l118
						}
						{
							add(ruleAction35, position)
						}
						if !_rules[rulee2]() {
							goto l118
						}
						{
							add(ruleAction36, position)
						}
					}
				l119:
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(rulee1, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 14 e2 <- <(e3 ((&('%') (modulus Action41 e3 Action42)) | (&('/') (divide Action39 e3 Action40)) | (&('*') (multiply Action37 e3 Action38)))*)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				if !_rules[rulee3]() {
					goto l125
				}
			l127:
				{
					position128, tokenIndex128 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position130 := position
								if buffer[position] != rune('%') {
									goto l128
								}
								position++
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemodulus, position130)
							}
							{
								add(ruleAction41, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction42, position)
							}
						case '/':
							{
								position133 := position
								{
									position134, tokenIndex134 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l135
									}
									position++
									goto l134
								l135:
									position, tokenIndex = position134, tokenIndex134
									if buffer[position] != rune('／') {
										goto l128
									}
									position++
								}
							l134:
								if !_rules[rulesp]() {
									goto l128
								}
								add(ruledivide, position133)
							}
							{
								add(ruleAction39, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction40, position)
							}
						default:
							{
								position138 := position
								{
									position139, tokenIndex139 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l140
									}
									position++
									goto l139
								l140:
									position, tokenIndex = position139, tokenIndex139
									if buffer[position] != rune('＊') {
										goto l128
									}
									position++
								}
							l139:
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemultiply, position138)
							}
							{
								add(ruleAction37, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction38, position)
							}
						}
					}

					goto l127
				l128:
					position, tokenIndex = position128, tokenIndex128
				}
				add(rulee2, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 15 e3 <- <(e4 (exponentiation Action43 e4 Action44)*)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if !_rules[rulee4]() {
					goto l143
				}
			l145:
				{
					position146, tokenIndex146 := position, tokenIndex
					{
						position147 := position
						{
							position148, tokenIndex148 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l149
							}
							position++
							if !_rules[rulesp]() {
								goto l149
							}
							goto l148
						l149:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if !_rules[rulesp]() {
								goto l146
							}
						}
					l148:
						add(ruleexponentiation, position147)
					}
					{
						add(ruleAction43, position)
					}
					if !_rules[rulee4]() {
						goto l146
					}
					{
						add(ruleAction44, position)
					}
					goto l145
				l146:
					position, tokenIndex = position146, tokenIndex146
				}
				add(rulee3, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 16 e4 <- <((minus e5 Action45) / e5)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l155
					}
					if !_rules[rulee5]() {
						goto l155
					}
					{
						add(ruleAction45, position)
					}
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[rulee5]() {
						goto l152
					}
				}
			l154:
				add(rulee4, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 17 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				{
					position159, tokenIndex159 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l160
					}
					if !_rules[ruleeDice]() {
						goto l160
					}
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if !_rules[ruleeDice]() {
						goto l157
					}
				}
			l159:
				add(rulee5, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 18 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action46 sp) / ((('劣' '势') / ('k' 'l')) Action47 sp))> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position163, tokenIndex163 := position, tokenIndex
					{
						position165, tokenIndex165 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l166
						}
						position++
						if buffer[position] != rune('势') {
							goto l166
						}
						position++
						goto l165
					l166:
						position, tokenIndex = position165, tokenIndex165
						if buffer[position] != rune('k') {
							goto l164
						}
						position++
						if buffer[position] != rune('h') {
							goto l164
						}
						position++
					}
				l165:
					{
						add(ruleAction46, position)
					}
					if !_rules[rulesp]() {
						goto l164
					}
					goto l163
				l164:
					position, tokenIndex = position163, tokenIndex163
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l169
						}
						position++
						if buffer[position] != rune('势') {
							goto l169
						}
						position++
						goto l168
					l169:
						position, tokenIndex = position168, tokenIndex168
						if buffer[position] != rune('k') {
							goto l161
						}
						position++
						if buffer[position] != rune('l') {
							goto l161
						}
						position++
					}
				l168:
					{
						add(ruleAction47, position)
					}
					if !_rules[rulesp]() {
						goto l161
					}
				}
			l163:
				add(ruledndDiceSuffix, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 19 kqDiceOp <- <(('k' eDice2 Action48)? ('q' eDice2 Action49)? ('d' 'l' eDice2 Action50)? ('d' 'h' eDice2 Action51)?)> */
		func() bool {
			{
				position172 := position
				{
					position173, tokenIndex173 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l173
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l173
					}
					{
						add(ruleAction48, position)
					}
					goto l174
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
			l174:
				{
					position176, tokenIndex176 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l176
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l176
					}
					{
						add(ruleAction49, position)
					}
					goto l177
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
			l177:
				{
					position179, tokenIndex179 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l179
					}
					position++
					if buffer[position] != rune('l') {
						goto l179
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l179
					}
					{
						add(ruleAction50, position)
					}
					goto l180
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
			l180:
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l182
					}
					position++
					if buffer[position] != rune('h') {
						goto l182
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l182
					}
					{
						add(ruleAction51, position)
					}
					goto l183
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
			l183:
				add(rulekqDiceOp, position172)
			}
			return true
		},
		/* 20 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					{
						position188, tokenIndex188 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l189
						}
						position++
						goto l188
					l189:
						position, tokenIndex = position188, tokenIndex188
						if buffer[position] != rune('D') {
							goto l185
						}
						position++
					}
				l188:
					{
						position190, tokenIndex190 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l191
						}
						goto l190
					l191:
						position, tokenIndex = position190, tokenIndex190
						if buffer[position] != rune('(') {
							goto l185
						}
						position++
					}
				l190:
					position, tokenIndex = position187, tokenIndex187
				}
				add(rule_dnumber, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 21 simpleDice2 <- <(&(number / '(') eDice2)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					{
						position195, tokenIndex195 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l196
						}
						goto l195
					l196:
						position, tokenIndex = position195, tokenIndex195
						if buffer[position] != rune('(') {
							goto l192
						}
						position++
					}
				l195:
					position, tokenIndex = position194, tokenIndex194
				}
				if !_rules[ruleeDice2]() {
					goto l192
				}
				add(rulesimpleDice2, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 22 wodDicePool <- <(Action52 (simpleDice2 Action53)?)> */
		nil,
		/* 23 eDice <- <((_dnumber ('d' / 'D') Action54 eDice2 dndDiceSuffix Action55) / (_dnumber ('d' / 'D') Action56 eDice2 kqDiceOp Action57) / (('d' / 'D') dndDiceSuffix Action58) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action59) / (wodDicePool ('a' / 'A') simpleDice2 ((('m' / 'M') simpleDice2 Action60) / (('k' / 'K') simpleDice2 Action61))* Action62) / (eDice2 (('d' / 'D') Action63 simpleDice2 kqDiceOp Action64)*))> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				{
					position200, tokenIndex200 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l201
					}
					{
						position202, tokenIndex202 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l203
						}
						position++
						goto l202
					l203:
						position, tokenIndex = position202, tokenIndex202
						if buffer[position] != rune('D') {
							goto l201
						}
						position++
					}
				l202:
					{
						add(ruleAction54, position)
					}
					if !_rules[ruleeDice2]() {
						goto l201
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l201
					}
					{
						add(ruleAction55, position)
					}
					goto l200
				l201:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[rule_dnumber]() {
						goto l206
					}
					{
						position207, tokenIndex207 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l208
						}
						position++
						goto l207
					l208:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('D') {
							goto l206
						}
						position++
					}
				l207:
					{
						add(ruleAction56, position)
					}
					if !_rules[ruleeDice2]() {
						goto l206
					}
					if !_rules[rulekqDiceOp]() {
						goto l206
					}
					{
						add(ruleAction57, position)
					}
					goto l200
				l206:
					position, tokenIndex = position200, tokenIndex200
					{
						position212, tokenIndex212 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l213
						}
						position++
						goto l212
					l213:
						position, tokenIndex = position212, tokenIndex212
						if buffer[position] != rune('D') {
							goto l211
						}
						position++
					}
				l212:
					if !_rules[ruledndDiceSuffix]() {
						goto l211
					}
					{
						add(ruleAction58, position)
					}
					goto l200
				l211:
					position, tokenIndex = position200, tokenIndex200
					{
						position216, tokenIndex216 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l217
						}
						position++
						goto l216
					l217:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('D') {
							goto l215
						}
						position++
					}
				l216:
					{
						position218, tokenIndex218 := position, tokenIndex
						{
							position219, tokenIndex219 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l219
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l219
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l219
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l219
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l219
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l219
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l219
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l219
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l219
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l219
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l219
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l219
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l219
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l219
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l219
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l219
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l219
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l219
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l219
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l219
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l219
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l219
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l219
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l219
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l219
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l219
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l219
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l219
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l219
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l219
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l219
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l219
									}
									position++
								}
							}

							goto l218
						l219:
							position, tokenIndex = position219, tokenIndex219
						}
						if !matchDot() {
							goto l218
						}
						goto l215
					l218:
						position, tokenIndex = position218, tokenIndex218
					}
					if !_rules[rulesp]() {
						goto l215
					}
					{
						add(ruleAction59, position)
					}
					goto l200
				l215:
					position, tokenIndex = position200, tokenIndex200
					{
						position223 := position
						{
							add(ruleAction52, position)
						}
						{
							position225, tokenIndex225 := position, tokenIndex
							if !_rules[rulesimpleDice2]() {
								goto l225
							}
							{
								add(ruleAction53, position)
							}
							goto l226
						l225:
							position, tokenIndex = position225, tokenIndex225
						}
					l226:
						add(rulewodDicePool, position223)
					}
					{
						position228, tokenIndex228 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l229
						}
						position++
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('A') {
							goto l222
						}
						position++
					}
				l228:
					if !_rules[rulesimpleDice2]() {
						goto l222
					}
				l230:
					{
						position231, tokenIndex231 := position, tokenIndex
						{
							position232, tokenIndex232 := position, tokenIndex
							{
								position234, tokenIndex234 := position, tokenIndex
								if buffer[position] != rune('m') {
									goto l235
								}
								position++
								goto l234
							l235:
								position, tokenIndex = position234, tokenIndex234
								if buffer[position] != rune('M') {
									goto l233
								}
								position++
							}
						l234:
							if !_rules[rulesimpleDice2]() {
								goto l233
							}
							{
								add(ruleAction60, position)
							}
							goto l232
						l233:
							position, tokenIndex = position232, tokenIndex232
							{
								position237, tokenIndex237 := position, tokenIndex
								if buffer[position] != rune('k') {
									goto l238
								}
								position++
								goto l237
							l238:
								position, tokenIndex = position237, tokenIndex237
								if buffer[position] != rune('K') {
									goto l231
								}
								position++
							}
						l237:
							if !_rules[rulesimpleDice2]() {
								goto l231
							}
							{
								add(ruleAction61, position)
							}
						}
					l232:
						goto l230
					l231:
						position, tokenIndex = position231, tokenIndex231
					}
					{
						add(ruleAction62, position)
					}
					goto l200
				l222:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleeDice2]() {
						goto l198
					}
				l241:
					{
						position242, tokenIndex242 := position, tokenIndex
						{
							position243, tokenIndex243 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l244
							}
							position++
							goto l243
						l244:
							position, tokenIndex = position243, tokenIndex243
							if buffer[position] != rune('D') {
								goto l242
							}
							position++
						}
					l243:
						{
							add(ruleAction63, position)
						}
						if !_rules[rulesimpleDice2]() {
							goto l242
						}
						if !_rules[rulekqDiceOp]() {
							goto l242
						}
						{
							add(ruleAction64, position)
						}
						goto l241
					l242:
						position, tokenIndex = position242, tokenIndex242
					}
				}
			l200:
				add(ruleeDice, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 24 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				{
					position249, tokenIndex249 := position, tokenIndex
					{
						position250, tokenIndex250 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l251
						}
						goto l250
					l251:
						position, tokenIndex = position250, tokenIndex250
						if buffer[position] != rune('(') {
							goto l247
						}
						position++
					}
				l250:
					position, tokenIndex = position249, tokenIndex249
				}
				add(rulelaNumberOrLeftParen, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 25 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action65) / (('p' / 'P') Action66) / eDice3)> */
		func() bool {
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				{
					position254, tokenIndex254 := position, tokenIndex
					{
						position256, tokenIndex256 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l257
						}
						position++
						goto l256
					l257:
						position, tokenIndex = position256, tokenIndex256
						if buffer[position] != rune('P') {
							goto l255
						}
						position++
					}
				l256:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l255
					}
					if !_rules[ruleeDice3]() {
						goto l255
					}
					{
						add(ruleAction65, position)
					}
					goto l254
				l255:
					position, tokenIndex = position254, tokenIndex254
					{
						position260, tokenIndex260 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l261
						}
						position++
						goto l260
					l261:
						position, tokenIndex = position260, tokenIndex260
						if buffer[position] != rune('P') {
							goto l259
						}
						position++
					}
				l260:
					{
						add(ruleAction66, position)
					}
					goto l254
				l259:
					position, tokenIndex = position254, tokenIndex254
					if !_rules[ruleeDice3]() {
						goto l252
					}
				}
			l254:
				add(ruleeDice2, position253)
			}
			return true
		l252:
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 26 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action67) / (('b' / 'B') Action68) / eDice4)> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				{
					position265, tokenIndex265 := position, tokenIndex
					{
						position267, tokenIndex267 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l268
						}
						position++
						goto l267
					l268:
						position, tokenIndex = position267, tokenIndex267
						if buffer[position] != rune('B') {
							goto l266
						}
						position++
					}
				l267:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l266
					}
					if !_rules[rulevalue]() {
						goto l266
					}
					{
						add(ruleAction67, position)
					}
					goto l265
				l266:
					position, tokenIndex = position265, tokenIndex265
					{
						position271, tokenIndex271 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l272
						}
						position++
						goto l271
					l272:
						position, tokenIndex = position271, tokenIndex271
						if buffer[position] != rune('B') {
							goto l270
						}
						position++
					}
				l271:
					{
						add(ruleAction68, position)
					}
					goto l265
				l270:
					position, tokenIndex = position265, tokenIndex265
					{
						position274 := position
						{
							position275, tokenIndex275 := position, tokenIndex
							{
								position277, tokenIndex277 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l278
								}
								position++
								goto l277
							l278:
								position, tokenIndex = position277, tokenIndex277
								if buffer[position] != rune('F') {
									goto l276
								}
								position++
							}
						l277:
							if !_rules[rulesp]() {
								goto l276
							}
							{
								add(ruleAction69, position)
							}
							goto l275
						l276:
							position, tokenIndex = position275, tokenIndex275
							if !_rules[rulevalue]() {
								goto l263
							}
						}
					l275:
						add(ruleeDice4, position274)
					}
				}
			l265:
				add(ruleeDice3, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 27 eDice4 <- <((('f' / 'F') sp Action69) / value)> */
		nil,
		/* 28 value <- <(number / assign_expr / (identifier Action70) / sub / fstring)> */
		func() bool {
			position281, tokenIndex281 := position, tokenIndex
			{
				position282 := position
				{
					position283, tokenIndex283 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l284
					}
					goto l283
				l284:
					position, tokenIndex = position283, tokenIndex283
					if !_rules[ruleassign_expr]() {
						goto l285
					}
					goto l283
				l285:
					position, tokenIndex = position283, tokenIndex283
					if !_rules[ruleidentifier]() {
						goto l286
					}
					{
						add(ruleAction70, position)
					}
					goto l283
				l286:
					position, tokenIndex = position283, tokenIndex283
					{
						position289 := position
						{
							position290 := position
							if buffer[position] != rune('(') {
								goto l288
							}
							position++
							if !_rules[rulesp]() {
								goto l288
							}
							add(ruleopen, position290)
						}
						if !_rules[rulee0]() {
							goto l288
						}
						{
							position291 := position
							if buffer[position] != rune(')') {
								goto l288
							}
							position++
							if !_rules[rulesp]() {
								goto l288
							}
							add(ruleclose, position291)
						}
						add(rulesub, position289)
					}
					goto l283
				l288:
					position, tokenIndex = position283, tokenIndex283
					{
						position292 := position
						{
							switch buffer[position] {
							case '\'':
								if buffer[position] != rune('\'') {
									goto l281
								}
								position++
								{
									add(ruleAction86, position)
								}
								{
									position295 := position
								l296:
									{
										position297, tokenIndex297 := position, tokenIndex
										{
											position298 := position
											{
												position299 := position
												{
													position302, tokenIndex302 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l303
													}
													goto l302
												l303:
													position, tokenIndex = position302, tokenIndex302
													{
														position304, tokenIndex304 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l304
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l304
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l304
																}
																position++
															case '\'':
																if buffer[position] != rune('\'') {
																	goto l304
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l304
																}
																position++
															}
														}

														goto l297
													l304:
														position, tokenIndex = position304, tokenIndex304
													}
													if !matchDot() {
														goto l297
													}
												}
											l302:
											l300:
												{
													position301, tokenIndex301 := position, tokenIndex
													{
														position306, tokenIndex306 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l307
														}
														goto l306
													l307:
														position, tokenIndex = position306, tokenIndex306
														{
															position308, tokenIndex308 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l308
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l308
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l308
																	}
																	position++
																case '\'':
																	if buffer[position] != rune('\'') {
																		goto l308
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l308
																	}
																	position++
																}
															}

															goto l301
														l308:
															position, tokenIndex = position308, tokenIndex308
														}
														if !matchDot() {
															goto l301
														}
													}
												l306:
													goto l300
												l301:
													position, tokenIndex = position301, tokenIndex301
												}
												add(rulePegText, position299)
											}
											{
												add(ruleAction75, position)
											}
											add(rulestrPart3, position298)
										}
										goto l296
									l297:
										position, tokenIndex = position297, tokenIndex297
									}
									add(rulePegText, position295)
								}
								if buffer[position] != rune('\'') {
									goto l281
								}
								position++
								{
									add(ruleAction87, position)
								}
							case '"':
								if buffer[position] != rune('"') {
									goto l281
								}
								position++
								{
									add(ruleAction84, position)
								}
								{
									position313 := position
								l314:
									{
										position315, tokenIndex315 := position, tokenIndex
										{
											position316 := position
											{
												position317 := position
												{
													position320, tokenIndex320 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l321
													}
													goto l320
												l321:
													position, tokenIndex = position320, tokenIndex320
													{
														position322, tokenIndex322 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l322
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l322
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l322
																}
																position++
															case '"':
																if buffer[position] != rune('"') {
																	goto l322
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l322
																}
																position++
															}
														}

														goto l315
													l322:
														position, tokenIndex = position322, tokenIndex322
													}
													if !matchDot() {
														goto l315
													}
												}
											l320:
											l318:
												{
													position319, tokenIndex319 := position, tokenIndex
													{
														position324, tokenIndex324 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l325
														}
														goto l324
													l325:
														position, tokenIndex = position324, tokenIndex324
														{
															position326, tokenIndex326 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l326
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l326
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l326
																	}
																	position++
																case '"':
																	if buffer[position] != rune('"') {
																		goto l326
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l326
																	}
																	position++
																}
															}

															goto l319
														l326:
															position, tokenIndex = position326, tokenIndex326
														}
														if !matchDot() {
															goto l319
														}
													}
												l324:
													goto l318
												l319:
													position, tokenIndex = position319, tokenIndex319
												}
												add(rulePegText, position317)
											}
											{
												add(ruleAction74, position)
											}
											add(rulestrPart2, position316)
										}
										goto l314
									l315:
										position, tokenIndex = position315, tokenIndex315
									}
									add(rulePegText, position313)
								}
								if buffer[position] != rune('"') {
									goto l281
								}
								position++
								{
									add(ruleAction85, position)
								}
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l281
								}
								position++
								{
									add(ruleAction80, position)
								}
								{
									position331 := position
								l332:
									{
										position333, tokenIndex333 := position, tokenIndex
										{
											position334, tokenIndex334 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l335
											}
											position++
											if !_rules[rulesp]() {
												goto l335
											}
											if !_rules[rulee]() {
												goto l335
											}
											{
												add(ruleAction81, position)
											}
											if buffer[position] != rune('}') {
												goto l335
											}
											position++
											goto l334
										l335:
											position, tokenIndex = position334, tokenIndex334
											if buffer[position] != rune('{') {
												goto l337
											}
											position++
											if buffer[position] != rune('%') {
												goto l337
											}
											position++
											if !_rules[rulesp]() {
												goto l337
											}
											if !_rules[rulee]() {
												goto l337
											}
											{
												add(ruleAction82, position)
											}
											if buffer[position] != rune('%') {
												goto l337
											}
											position++
											if buffer[position] != rune('}') {
												goto l337
											}
											position++
											goto l334
										l337:
											position, tokenIndex = position334, tokenIndex334
											{
												position339 := position
												{
													position340 := position
													{
														position343, tokenIndex343 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l344
														}
														goto l343
													l344:
														position, tokenIndex = position343, tokenIndex343
														{
															position345, tokenIndex345 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l345
																	}
																	position++
																case '\x1e':
																	if buffer[position] != rune('\x1e') {
																		goto l345
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l345
																	}
																	position++
																}
															}

															goto l333
														l345:
															position, tokenIndex = position345, tokenIndex345
														}
														if !matchDot() {
															goto l333
														}
													}
												l343:
												l341:
													{
														position342, tokenIndex342 := position, tokenIndex
														{
															position347, tokenIndex347 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l348
															}
															goto l347
														l348:
															position, tokenIndex = position347, tokenIndex347
															{
																position349, tokenIndex349 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l349
																		}
																		position++
																	case '\x1e':
																		if buffer[position] != rune('\x1e') {
																			goto l349
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l349
																		}
																		position++
																	}
																}

																goto l342
															l349:
																position, tokenIndex = position349, tokenIndex349
															}
															if !matchDot() {
																goto l342
															}
														}
													l347:
														goto l341
													l342:
														position, tokenIndex = position342, tokenIndex342
													}
													add(rulePegText, position340)
												}
												{
													add(ruleAction73, position)
												}
												add(rulestrPart1, position339)
											}
										}
									l334:
										goto l332
									l333:
										position, tokenIndex = position333, tokenIndex333
									}
									add(rulePegText, position331)
								}
								if buffer[position] != rune('\x1e') {
									goto l281
								}
								position++
								{
									add(ruleAction83, position)
								}
							default:
								if buffer[position] != rune('`') {
									goto l281
								}
								position++
								{
									add(ruleAction76, position)
								}
								{
									position354 := position
								l355:
									{
										position356, tokenIndex356 := position, tokenIndex
										{
											position357, tokenIndex357 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l358
											}
											position++
											if !_rules[rulesp]() {
												goto l358
											}
											if !_rules[rulee]() {
												goto l358
											}
											{
												add(ruleAction77, position)
											}
											if buffer[position] != rune('}') {
												goto l358
											}
											position++
											goto l357
										l358:
											position, tokenIndex = position357, tokenIndex357
											if buffer[position] != rune('{') {
												goto l360
											}
											position++
											if buffer[position] != rune('{') {
												goto l360
											}
											position++
											if !_rules[rulesp]() {
												goto l360
											}
											if !_rules[rulee]() {
												goto l360
											}
											{
												add(ruleAction78, position)
											}
											if buffer[position] != rune('}') {
												goto l360
											}
											position++
											if buffer[position] != rune('}') {
												goto l360
											}
											position++
											goto l357
										l360:
											position, tokenIndex = position357, tokenIndex357
											{
												position362 := position
												{
													position363 := position
													{
														position366, tokenIndex366 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l367
														}
														goto l366
													l367:
														position, tokenIndex = position366, tokenIndex366
														{
															position368, tokenIndex368 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l368
																	}
																	position++
																case '`':
																	if buffer[position] != rune('`') {
																		goto l368
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l368
																	}
																	position++
																}
															}

															goto l356
														l368:
															position, tokenIndex = position368, tokenIndex368
														}
														if !matchDot() {
															goto l356
														}
													}
												l366:
												l364:
													{
														position365, tokenIndex365 := position, tokenIndex
														{
															position370, tokenIndex370 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l371
															}
															goto l370
														l371:
															position, tokenIndex = position370, tokenIndex370
															{
																position372, tokenIndex372 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l372
																		}
																		position++
																	case '`':
																		if buffer[position] != rune('`') {
																			goto l372
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l372
																		}
																		position++
																	}
																}

																goto l365
															l372:
																position, tokenIndex = position372, tokenIndex372
															}
															if !matchDot() {
																goto l365
															}
														}
													l370:
														goto l364
													l365:
														position, tokenIndex = position365, tokenIndex365
													}
													add(rulePegText, position363)
												}
												{
													add(ruleAction72, position)
												}
												add(rulestrPart, position362)
											}
										}
									l357:
										goto l355
									l356:
										position, tokenIndex = position356, tokenIndex356
									}
									add(rulePegText, position354)
								}
								if buffer[position] != rune('`') {
									goto l281
								}
								position++
								{
									add(ruleAction79, position)
								}
							}
						}

						if !_rules[rulesp]() {
							goto l281
						}
						add(rulefstring, position292)
					}
				}
			l283:
				add(rulevalue, position282)
			}
			return true
		l281:
			position, tokenIndex = position281, tokenIndex281
			return false
		},
		/* 29 number <- <(<[0-9]+> sp Action71)> */
		func() bool {
			position376, tokenIndex376 := position, tokenIndex
			{
				position377 := position
				{
					position378 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l376
					}
					position++
				l379:
					{
						position380, tokenIndex380 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l380
						}
						position++
						goto l379
					l380:
						position, tokenIndex = position380, tokenIndex380
					}
					add(rulePegText, position378)
				}
				if !_rules[rulesp]() {
					goto l376
				}
				{
					add(ruleAction71, position)
				}
				add(rulenumber, position377)
			}
			return true
		l376:
			position, tokenIndex = position376, tokenIndex376
			return false
		},
		/* 30 identifier <- <(<(!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position382, tokenIndex382 := position, tokenIndex
			{
				position383 := position
				{
					position384 := position
					{
						position385, tokenIndex385 := position, tokenIndex
						{
							switch buffer[position] {
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l385
								}
								position++
							case '\r':
								if buffer[position] != rune('\r') {
									goto l385
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l385
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l385
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l385
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l385
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l385
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l385
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l385
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l385
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l385
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l385
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l385
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l385
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l385
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l385
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l385
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l385
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l385
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l385
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l385
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l385
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l385
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l385
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l385
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l385
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l385
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l385
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l385
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l385
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l385
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l385
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l385
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l385
								}
								position++
							}
						}

						goto l382
					l385:
						position, tokenIndex = position385, tokenIndex385
					}
					if !matchDot() {
						goto l382
					}
				l387:
					{
						position388, tokenIndex388 := position, tokenIndex
						{
							position389, tokenIndex389 := position, tokenIndex
							{
								switch buffer[position] {
								case '\x1e':
									if buffer[position] != rune('\x1e') {
										goto l389
									}
									position++
								case '\r':
									if buffer[position] != rune('\r') {
										goto l389
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l389
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l389
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l389
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l389
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l389
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l389
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l389
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l389
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l389
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l389
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l389
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l389
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l389
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l389
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l389
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l389
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l389
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l389
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l389
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l389
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l389
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l389
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l389
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l389
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l389
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l389
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l389
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l389
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l389
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l389
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l389
									}
									position++
								}
							}

							goto l388
						l389:
							position, tokenIndex = position389, tokenIndex389
						}
						if !matchDot() {
							goto l388
						}
						goto l387
					l388:
						position, tokenIndex = position388, tokenIndex388
					}
					add(rulePegText, position384)
				}
				if !_rules[rulesp]() {
					goto l382
				}
				add(ruleidentifier, position383)
			}
			return true
		l382:
			position, tokenIndex = position382, tokenIndex382
			return false
		},
		/* 31 sub <- <(open e0 close)> */
		nil,
		/* 32 add <- <(('+' / '＋') sp)> */
		func() bool {
			position392, tokenIndex392 := position, tokenIndex
			{
				position393 := position
				{
					position394, tokenIndex394 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l395
					}
					position++
					goto l394
				l395:
					position, tokenIndex = position394, tokenIndex394
					if buffer[position] != rune('＋') {
						goto l392
					}
					position++
				}
			l394:
				if !_rules[rulesp]() {
					goto l392
				}
				add(ruleadd, position393)
			}
			return true
		l392:
			position, tokenIndex = position392, tokenIndex392
			return false
		},
		/* 33 minus <- <(('-' / '－') sp)> */
		func() bool {
			position396, tokenIndex396 := position, tokenIndex
			{
				position397 := position
				{
					position398, tokenIndex398 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l399
					}
					position++
					goto l398
				l399:
					position, tokenIndex = position398, tokenIndex398
					if buffer[position] != rune('－') {
						goto l396
					}
					position++
				}
			l398:
				if !_rules[rulesp]() {
					goto l396
				}
				add(ruleminus, position397)
			}
			return true
		l396:
			position, tokenIndex = position396, tokenIndex396
			return false
		},
		/* 34 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 35 divide <- <(('/' / '／') sp)> */
		nil,
		/* 36 modulus <- <('%' sp)> */
		nil,
		/* 37 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 38 open <- <('(' sp)> */
		nil,
		/* 39 close <- <(')' sp)> */
		nil,
		/* 40 bitwiseOr <- <('|' sp)> */
		nil,
		/* 41 logicOr <- <('|' '|' sp)> */
		nil,
		/* 42 bitwiseAnd <- <(('&' / ('&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 43 logicAnd <- <((('&' '&') / ('&' 'a' 'm' 'p' ';' '&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 44 sp <- <((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' '))*> */
		func() bool {
			{
				position411 := position
			l412:
				{
					position413, tokenIndex413 := position, tokenIndex
					{
						switch buffer[position] {
						case '\r':
							if buffer[position] != rune('\r') {
								goto l413
							}
							position++
						case '\n':
							if buffer[position] != rune('\n') {
								goto l413
							}
							position++
						case '\t':
							if buffer[position] != rune('\t') {
								goto l413
							}
							position++
						default:
							if buffer[position] != rune(' ') {
								goto l413
							}
							position++
						}
					}

					goto l412
				l413:
					position, tokenIndex = position413, tokenIndex413
				}
				add(rulesp, position411)
			}
			return true
		},
		/* 45 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 46 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 47 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 48 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 49 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 50 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 51 strPart <- <(<(escape / (!((&('\\') '\\') | (&('`') '`') | (&('{') '{')) .))+> Action72)> */
		nil,
		/* 52 strPart1 <- <(<(escape / (!((&('\\') '\\') | (&('\x1e') '\x1e') | (&('{') '{')) .))+> Action73)> */
		nil,
		/* 53 strPart2 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('"') '"') | (&('{') '{')) .))+> Action74)> */
		nil,
		/* 54 strPart3 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('\'') '\'') | (&('{') '{')) .))+> Action75)> */
		nil,
		/* 55 fstring <- <(((&('\'') ('\'' Action86 <strPart3*> '\'' Action87)) | (&('"') ('"' Action84 <strPart2*> '"' Action85)) | (&('\x1e') ('\x1e' Action80 <(('{' sp e Action81 '}') / ('{' '%' sp e Action82 ('%' '}')) / strPart1)*> '\x1e' Action83)) | (&('`') ('`' Action76 <(('{' sp e Action77 '}') / ('{' '{' sp e Action78 ('}' '}')) / strPart)*> '`' Action79))) sp)> */
		nil,
		/* 56 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		func() bool {
			position426, tokenIndex426 := position, tokenIndex
			{
				position427 := position
				if buffer[position] != rune('\\') {
					goto l426
				}
				position++
				{
					switch buffer[position] {
					case '\\':
						if buffer[position] != rune('\\') {
							goto l426
						}
						position++
					case '\'':
						if buffer[position] != rune('\'') {
							goto l426
						}
						position++
					case '"':
						if buffer[position] != rune('"') {
							goto l426
						}
						position++
					case 'r':
						if buffer[position] != rune('r') {
							goto l426
						}
						position++
					case 'f':
						if buffer[position] != rune('f') {
							goto l426
						}
						position++
					case 'n':
						if buffer[position] != rune('n') {
							goto l426
						}
						position++
					case 't':
						if buffer[position] != rune('t') {
							goto l426
						}
						position++
					default:
						if buffer[position] != rune('b') {
							goto l426
						}
						position++
					}
				}

				add(ruleescape, position427)
			}
			return true
		l426:
			position, tokenIndex = position426, tokenIndex426
			return false
		},
		/* 58 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 59 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 60 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 61 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 62 Action4 <- <{p.AddOperator(TypePop)}> */
		nil,
		/* 63 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 64 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 65 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 66 Action8 <- <{ p.AddValueStr(""); }> */
		nil,
		/* 67 Action9 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 68 Action10 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 69 Action11 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 70 Action12 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 71 Action13 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 72 Action14 <- <{ p.CounterPush() }> */
		nil,
		/* 73 Action15 <- <{p.CounterAdd(1)}> */
		nil,
		/* 74 Action16 <- <{ p.AddValueStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.PopAndSetOffset() } }> */
		nil,
		/* 75 Action17 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 76 Action18 <- <{ p.AddOperator(TypeBitwiseOr) }> */
		nil,
		/* 77 Action19 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 78 Action20 <- <{ p.AddOperator(TypeBitwiseAnd) }> */
		nil,
		/* 79 Action21 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 80 Action22 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 81 Action23 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 82 Action24 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 83 Action25 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 84 Action26 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 85 Action27 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 86 Action28 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 87 Action29 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 88 Action30 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 89 Action31 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 90 Action32 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 91 Action33 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 92 Action34 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 93 Action35 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 94 Action36 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 95 Action37 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 96 Action38 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 97 Action39 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 98 Action40 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 99 Action41 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 100 Action42 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 101 Action43 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 102 Action44 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 103 Action45 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 104 Action46 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 105 Action47 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 106 Action48 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 107 Action49 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 108 Action50 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 109 Action51 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 110 Action52 <- <{ p.AddOperator(TypeWodSetInit) }> */
		nil,
		/* 111 Action53 <- <{ p.AddOperator(TypeWodSetPool) }> */
		nil,
		/* 112 Action54 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 113 Action55 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 114 Action56 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 115 Action57 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 116 Action58 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 117 Action59 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 118 Action60 <- <{ p.AddOperator(TypeWodSetPoints) }> */
		nil,
		/* 119 Action61 <- <{ p.AddOperator(TypeWodSetThreshold) }> */
		nil,
		/* 120 Action62 <- <{ p.AddOperator(TypeDiceWod) }> */
		nil,
		/* 121 Action63 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 122 Action64 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 123 Action65 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 124 Action66 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 125 Action67 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 126 Action68 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 127 Action69 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 128 Action70 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 130 Action71 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 131 Action72 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 132 Action73 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 133 Action74 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 134 Action75 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 135 Action76 <- <{ p.CounterPush() }> */
		nil,
		/* 136 Action77 <- <{p.CounterAdd(1)}> */
		nil,
		/* 137 Action78 <- <{p.CounterAdd(1)}> */
		nil,
		/* 138 Action79 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 139 Action80 <- <{ p.CounterPush() }> */
		nil,
		/* 140 Action81 <- <{p.CounterAdd(1)}> */
		nil,
		/* 141 Action82 <- <{p.CounterAdd(1)}> */
		nil,
		/* 142 Action83 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 143 Action84 <- <{ p.CounterPush() }> */
		nil,
		/* 144 Action85 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 145 Action86 <- <{ p.CounterPush() }> */
		nil,
		/* 146 Action87 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
