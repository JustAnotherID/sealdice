package dice

// Code generated by C:\Users\fy0\go\bin\peg.exe -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rulee0m
	rulee0
	ruleeTernary
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	rulePegText
	ruleAction53
	ruleAction54
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"e0m",
	"e0",
	"eTernary",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"PegText",
	"Action53",
	"Action54",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [99]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypeClearDetail)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddLeftValueMark()
		case ruleAction9:
			p.AddOperator(TypeCompLT)
		case ruleAction10:
			p.AddLeftValueMark()
		case ruleAction11:
			p.AddOperator(TypeCompLE)
		case ruleAction12:
			p.AddLeftValueMark()
		case ruleAction13:
			p.AddOperator(TypeCompEQ)
		case ruleAction14:
			p.AddLeftValueMark()
		case ruleAction15:
			p.AddOperator(TypeCompNE)
		case ruleAction16:
			p.AddLeftValueMark()
		case ruleAction17:
			p.AddOperator(TypeCompGE)
		case ruleAction18:
			p.AddLeftValueMark()
		case ruleAction19:
			p.AddOperator(TypeCompGT)
		case ruleAction20:
			p.AddLeftValueMark()
		case ruleAction21:
			p.AddOperator(TypeAdd)
		case ruleAction22:
			p.AddLeftValueMark()
		case ruleAction23:
			p.AddOperator(TypeSubtract)
		case ruleAction24:
			p.AddLeftValueMark()
		case ruleAction25:
			p.AddOperator(TypeMultiply)
		case ruleAction26:
			p.AddLeftValueMark()
		case ruleAction27:
			p.AddOperator(TypeDivide)
		case ruleAction28:
			p.AddLeftValueMark()
		case ruleAction29:
			p.AddOperator(TypeModulus)
		case ruleAction30:
			p.AddLeftValueMark()
		case ruleAction31:
			p.AddOperator(TypeExponentiation)
		case ruleAction32:
			p.AddOperator(TypeNegation)
		case ruleAction33:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction34:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction35:
			p.AddOperator(TypeDiceSetK)
		case ruleAction36:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction37:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction38:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction39:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction40:
			p.AddOperator(TypeDice)
		case ruleAction41:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction42:
			p.AddOperator(TypeDice)
		case ruleAction43:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction44:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction45:
			p.AddLeftValueMark()
		case ruleAction46:
			p.AddOperator(TypeDice)
		case ruleAction47:
			p.AddOperator(TypeDicePenalty)
		case ruleAction48:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction49:
			p.AddOperator(TypeDiceBonus)
		case ruleAction50:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction51:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction52:
			p.AddLoadVarname(string(text))
		case ruleAction53:
			p.AddValue(string(text))
		case ruleAction54:
			p.AddFormatString(string(text))

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2 := position
				l3:
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l4
						}
						if buffer[position] != rune(';') {
							goto l4
						}
						position++
						if !_rules[rulesp]() {
							goto l4
						}
						{
							add(ruleAction1, position)
						}
						goto l3
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
					if !_rules[ruleeOne]() {
						goto l0
					}
					add(rulee, position2)
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <((eOne ';' sp Action1)* eOne)> */
		nil,
		/* 2 eOne <- <(sp (fstring / e0))> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				if !_rules[rulesp]() {
					goto l8
				}
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if buffer[position] != rune('`') {
							goto l11
						}
						position++
						{
							position13 := position
						l14:
							{
								position15, tokenIndex15 := position, tokenIndex
								{
									position16, tokenIndex16 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l17
									}
									position++
									if !_rules[rulesp]() {
										goto l17
									}
									{
										position18 := position
									l19:
										{
											position20, tokenIndex20 := position, tokenIndex
											if !_rules[rulee0]() {
												goto l20
											}
											if buffer[position] != rune(';') {
												goto l20
											}
											position++
											if !_rules[rulesp]() {
												goto l20
											}
											{
												add(ruleAction4, position)
											}
											goto l19
										l20:
											position, tokenIndex = position20, tokenIndex20
										}
										if !_rules[rulee0]() {
											goto l17
										}
										add(rulee0m, position18)
									}
									if !_rules[rulesp]() {
										goto l17
									}
									if buffer[position] != rune('}') {
										goto l17
									}
									position++
									goto l16
								l17:
									position, tokenIndex = position16, tokenIndex16
									{
										position23 := position
										if buffer[position] != rune('\\') {
											goto l22
										}
										position++
										{
											switch buffer[position] {
											case '\\':
												if buffer[position] != rune('\\') {
													goto l22
												}
												position++
											case '\'':
												if buffer[position] != rune('\'') {
													goto l22
												}
												position++
											case '"':
												if buffer[position] != rune('"') {
													goto l22
												}
												position++
											case 'r':
												if buffer[position] != rune('r') {
													goto l22
												}
												position++
											case 'f':
												if buffer[position] != rune('f') {
													goto l22
												}
												position++
											case 'n':
												if buffer[position] != rune('n') {
													goto l22
												}
												position++
											case 't':
												if buffer[position] != rune('t') {
													goto l22
												}
												position++
											default:
												if buffer[position] != rune('b') {
													goto l22
												}
												position++
											}
										}

										add(ruleescape, position23)
									}
									goto l16
								l22:
									position, tokenIndex = position16, tokenIndex16
									{
										position25, tokenIndex25 := position, tokenIndex
										{
											switch buffer[position] {
											case '\r':
												if buffer[position] != rune('\r') {
													goto l25
												}
												position++
											case '\n':
												if buffer[position] != rune('\n') {
													goto l25
												}
												position++
											case '\\':
												if buffer[position] != rune('\\') {
													goto l25
												}
												position++
											default:
												if buffer[position] != rune('`') {
													goto l25
												}
												position++
											}
										}

										goto l15
									l25:
										position, tokenIndex = position25, tokenIndex25
									}
									if !matchDot() {
										goto l15
									}
								}
							l16:
								goto l14
							l15:
								position, tokenIndex = position15, tokenIndex15
							}
							add(rulePegText, position13)
						}
						if buffer[position] != rune('`') {
							goto l11
						}
						position++
						if !_rules[rulesp]() {
							goto l11
						}
						{
							add(ruleAction54, position)
						}
						add(rulefstring, position12)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulee0]() {
						goto l8
					}
				}
			l10:
				add(ruleeOne, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' e0 Action3)> */
		nil,
		/* 4 e0m <- <((e0 ';' sp Action4)* e0)> */
		nil,
		/* 5 e0 <- <eTernary> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				{
					position32 := position
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[ruleeComp]() {
							goto l34
						}
						if buffer[position] != rune('?') {
							goto l34
						}
						position++
						if !_rules[rulesp]() {
							goto l34
						}
						{
							add(ruleAction5, position)
						}
						if !_rules[ruleeComp]() {
							goto l34
						}
						if buffer[position] != rune(':') {
							goto l34
						}
						position++
						if !_rules[rulesp]() {
							goto l34
						}
						{
							add(ruleAction6, position)
						}
						if !_rules[ruleeComp]() {
							goto l34
						}
						{
							add(ruleAction7, position)
						}
						goto l33
					l34:
						position, tokenIndex = position33, tokenIndex33
						if !_rules[ruleeComp]() {
							goto l30
						}
					}
				l33:
					add(ruleeTernary, position32)
				}
				add(rulee0, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 6 eTernary <- <((eComp '?' sp Action5 eComp ':' sp Action6 eComp Action7) / eComp)> */
		nil,
		/* 7 eComp <- <(e1 ((lt Action8 e1 Action9) / (ge Action16 e1 Action17) / ((&('>') (gt Action18 e1 Action19)) | (&('!') (ne Action14 e1 Action15)) | (&('=') (eq Action12 e1 Action13)) | (&('<') (le Action10 e1 Action11))))*)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[rulee1]() {
					goto l39
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position43, tokenIndex43 := position, tokenIndex
						{
							position45 := position
							{
								position46, tokenIndex46 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l47
								}
								position++
								goto l46
							l47:
								position, tokenIndex = position46, tokenIndex46
								if buffer[position] != rune('＜') {
									goto l44
								}
								position++
							}
						l46:
							if !_rules[rulesp]() {
								goto l44
							}
							add(rulelt, position45)
						}
						{
							add(ruleAction8, position)
						}
						if !_rules[rulee1]() {
							goto l44
						}
						{
							add(ruleAction9, position)
						}
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						{
							position51 := position
							{
								position52, tokenIndex52 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l53
								}
								position++
								if buffer[position] != rune('=') {
									goto l53
								}
								position++
								goto l52
							l53:
								position, tokenIndex = position52, tokenIndex52
								if buffer[position] != rune('＞') {
									goto l50
								}
								position++
								if buffer[position] != rune('＝') {
									goto l50
								}
								position++
							}
						l52:
							if !_rules[rulesp]() {
								goto l50
							}
							add(rulege, position51)
						}
						{
							add(ruleAction16, position)
						}
						if !_rules[rulee1]() {
							goto l50
						}
						{
							add(ruleAction17, position)
						}
						goto l43
					l50:
						position, tokenIndex = position43, tokenIndex43
						{
							switch buffer[position] {
							case '>':
								{
									position57 := position
									{
										position58, tokenIndex58 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l59
										}
										position++
										goto l58
									l59:
										position, tokenIndex = position58, tokenIndex58
										if buffer[position] != rune('＞') {
											goto l42
										}
										position++
									}
								l58:
									if !_rules[rulesp]() {
										goto l42
									}
									add(rulegt, position57)
								}
								{
									add(ruleAction18, position)
								}
								if !_rules[rulee1]() {
									goto l42
								}
								{
									add(ruleAction19, position)
								}
							case '!':
								{
									position62 := position
									{
										position63, tokenIndex63 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l64
										}
										position++
										if buffer[position] != rune('=') {
											goto l64
										}
										position++
										goto l63
									l64:
										position, tokenIndex = position63, tokenIndex63
										if buffer[position] != rune('！') {
											goto l42
										}
										position++
										if buffer[position] != rune('＝') {
											goto l42
										}
										position++
									}
								l63:
									if !_rules[rulesp]() {
										goto l42
									}
									add(rulene, position62)
								}
								{
									add(ruleAction14, position)
								}
								if !_rules[rulee1]() {
									goto l42
								}
								{
									add(ruleAction15, position)
								}
							case '=':
								{
									position67 := position
									{
										position68, tokenIndex68 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l69
										}
										position++
										if buffer[position] != rune('=') {
											goto l69
										}
										position++
										goto l68
									l69:
										position, tokenIndex = position68, tokenIndex68
										if buffer[position] != rune('＝') {
											goto l42
										}
										position++
										if buffer[position] != rune('＝') {
											goto l42
										}
										position++
									}
								l68:
									if !_rules[rulesp]() {
										goto l42
									}
									add(ruleeq, position67)
								}
								{
									add(ruleAction12, position)
								}
								if !_rules[rulee1]() {
									goto l42
								}
								{
									add(ruleAction13, position)
								}
							default:
								{
									position72 := position
									{
										position73, tokenIndex73 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l74
										}
										position++
										if buffer[position] != rune('=') {
											goto l74
										}
										position++
										goto l73
									l74:
										position, tokenIndex = position73, tokenIndex73
										if buffer[position] != rune('＜') {
											goto l42
										}
										position++
										if buffer[position] != rune('＝') {
											goto l42
										}
										position++
									}
								l73:
									if !_rules[rulesp]() {
										goto l42
									}
									add(rulele, position72)
								}
								{
									add(ruleAction10, position)
								}
								if !_rules[rulee1]() {
									goto l42
								}
								{
									add(ruleAction11, position)
								}
							}
						}

					}
				l43:
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				add(ruleeComp, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 8 e1 <- <(e2 ((add Action20 e2 Action21) / (minus Action22 e2 Action23))*)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if !_rules[rulee2]() {
					goto l77
				}
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					{
						position81, tokenIndex81 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l82
						}
						{
							add(ruleAction20, position)
						}
						if !_rules[rulee2]() {
							goto l82
						}
						{
							add(ruleAction21, position)
						}
						goto l81
					l82:
						position, tokenIndex = position81, tokenIndex81
						if !_rules[ruleminus]() {
							goto l80
						}
						{
							add(ruleAction22, position)
						}
						if !_rules[rulee2]() {
							goto l80
						}
						{
							add(ruleAction23, position)
						}
					}
				l81:
					goto l79
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
				add(rulee1, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 9 e2 <- <(e3 ((&('%') (modulus Action28 e3 Action29)) | (&('/') (divide Action26 e3 Action27)) | (&('*') (multiply Action24 e3 Action25)))*)> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				if !_rules[rulee3]() {
					goto l87
				}
			l89:
				{
					position90, tokenIndex90 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position92 := position
								if buffer[position] != rune('%') {
									goto l90
								}
								position++
								if !_rules[rulesp]() {
									goto l90
								}
								add(rulemodulus, position92)
							}
							{
								add(ruleAction28, position)
							}
							if !_rules[rulee3]() {
								goto l90
							}
							{
								add(ruleAction29, position)
							}
						case '/':
							{
								position95 := position
								{
									position96, tokenIndex96 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l97
									}
									position++
									goto l96
								l97:
									position, tokenIndex = position96, tokenIndex96
									if buffer[position] != rune('／') {
										goto l90
									}
									position++
								}
							l96:
								if !_rules[rulesp]() {
									goto l90
								}
								add(ruledivide, position95)
							}
							{
								add(ruleAction26, position)
							}
							if !_rules[rulee3]() {
								goto l90
							}
							{
								add(ruleAction27, position)
							}
						default:
							{
								position100 := position
								{
									position101, tokenIndex101 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l102
									}
									position++
									goto l101
								l102:
									position, tokenIndex = position101, tokenIndex101
									if buffer[position] != rune('＊') {
										goto l90
									}
									position++
								}
							l101:
								if !_rules[rulesp]() {
									goto l90
								}
								add(rulemultiply, position100)
							}
							{
								add(ruleAction24, position)
							}
							if !_rules[rulee3]() {
								goto l90
							}
							{
								add(ruleAction25, position)
							}
						}
					}

					goto l89
				l90:
					position, tokenIndex = position90, tokenIndex90
				}
				add(rulee2, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 10 e3 <- <(e4 (exponentiation Action30 e4 Action31)*)> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				if !_rules[rulee4]() {
					goto l105
				}
			l107:
				{
					position108, tokenIndex108 := position, tokenIndex
					{
						position109 := position
						{
							position110, tokenIndex110 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l111
							}
							position++
							if !_rules[rulesp]() {
								goto l111
							}
							goto l110
						l111:
							position, tokenIndex = position110, tokenIndex110
							if buffer[position] != rune('*') {
								goto l108
							}
							position++
							if buffer[position] != rune('*') {
								goto l108
							}
							position++
							if !_rules[rulesp]() {
								goto l108
							}
						}
					l110:
						add(ruleexponentiation, position109)
					}
					{
						add(ruleAction30, position)
					}
					if !_rules[rulee4]() {
						goto l108
					}
					{
						add(ruleAction31, position)
					}
					goto l107
				l108:
					position, tokenIndex = position108, tokenIndex108
				}
				add(rulee3, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 11 e4 <- <((minus e5 Action32) / e5)> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				{
					position116, tokenIndex116 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l117
					}
					if !_rules[rulee5]() {
						goto l117
					}
					{
						add(ruleAction32, position)
					}
					goto l116
				l117:
					position, tokenIndex = position116, tokenIndex116
					if !_rules[rulee5]() {
						goto l114
					}
				}
			l116:
				add(rulee4, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 12 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l122
					}
					if !_rules[ruleeDice]() {
						goto l122
					}
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleeDice]() {
						goto l119
					}
				}
			l121:
				add(rulee5, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 13 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action33 sp) / ((('劣' '势') / ('k' 'l')) Action34 sp))> */
		func() bool {
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				{
					position125, tokenIndex125 := position, tokenIndex
					{
						position127, tokenIndex127 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l128
						}
						position++
						if buffer[position] != rune('势') {
							goto l128
						}
						position++
						goto l127
					l128:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('k') {
							goto l126
						}
						position++
						if buffer[position] != rune('h') {
							goto l126
						}
						position++
					}
				l127:
					{
						add(ruleAction33, position)
					}
					if !_rules[rulesp]() {
						goto l126
					}
					goto l125
				l126:
					position, tokenIndex = position125, tokenIndex125
					{
						position130, tokenIndex130 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l131
						}
						position++
						if buffer[position] != rune('势') {
							goto l131
						}
						position++
						goto l130
					l131:
						position, tokenIndex = position130, tokenIndex130
						if buffer[position] != rune('k') {
							goto l123
						}
						position++
						if buffer[position] != rune('l') {
							goto l123
						}
						position++
					}
				l130:
					{
						add(ruleAction34, position)
					}
					if !_rules[rulesp]() {
						goto l123
					}
				}
			l125:
				add(ruledndDiceSuffix, position124)
			}
			return true
		l123:
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 14 kqDiceOp <- <(('k' eDice2 Action35)? ('q' eDice2 Action36)? ('d' 'l' eDice2 Action37)? ('d' 'h' eDice2 Action38)?)> */
		func() bool {
			{
				position134 := position
				{
					position135, tokenIndex135 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l135
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l135
					}
					{
						add(ruleAction35, position)
					}
					goto l136
				l135:
					position, tokenIndex = position135, tokenIndex135
				}
			l136:
				{
					position138, tokenIndex138 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l138
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l138
					}
					{
						add(ruleAction36, position)
					}
					goto l139
				l138:
					position, tokenIndex = position138, tokenIndex138
				}
			l139:
				{
					position141, tokenIndex141 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l141
					}
					position++
					if buffer[position] != rune('l') {
						goto l141
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l141
					}
					{
						add(ruleAction37, position)
					}
					goto l142
				l141:
					position, tokenIndex = position141, tokenIndex141
				}
			l142:
				{
					position144, tokenIndex144 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l144
					}
					position++
					if buffer[position] != rune('h') {
						goto l144
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l144
					}
					{
						add(ruleAction38, position)
					}
					goto l145
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
			l145:
				add(rulekqDiceOp, position134)
			}
			return true
		},
		/* 15 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				{
					position149, tokenIndex149 := position, tokenIndex
					{
						position150, tokenIndex150 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l151
						}
						position++
						goto l150
					l151:
						position, tokenIndex = position150, tokenIndex150
						if buffer[position] != rune('D') {
							goto l147
						}
						position++
					}
				l150:
					{
						position152, tokenIndex152 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l153
						}
						goto l152
					l153:
						position, tokenIndex = position152, tokenIndex152
						if buffer[position] != rune('(') {
							goto l147
						}
						position++
					}
				l152:
					position, tokenIndex = position149, tokenIndex149
				}
				add(rule_dnumber, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		/* 16 eDice <- <((_dnumber ('d' / 'D') Action39 eDice2 dndDiceSuffix Action40) / (_dnumber ('d' / 'D') Action41 eDice2 kqDiceOp Action42) / (('d' / 'D') dndDiceSuffix Action43) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action44) / (eDice2 (('d' / 'D') Action45 &(number / '(') eDice2 kqDiceOp Action46)*))> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				{
					position156, tokenIndex156 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l157
					}
					{
						position158, tokenIndex158 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l159
						}
						position++
						goto l158
					l159:
						position, tokenIndex = position158, tokenIndex158
						if buffer[position] != rune('D') {
							goto l157
						}
						position++
					}
				l158:
					{
						add(ruleAction39, position)
					}
					if !_rules[ruleeDice2]() {
						goto l157
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l157
					}
					{
						add(ruleAction40, position)
					}
					goto l156
				l157:
					position, tokenIndex = position156, tokenIndex156
					if !_rules[rule_dnumber]() {
						goto l162
					}
					{
						position163, tokenIndex163 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l164
						}
						position++
						goto l163
					l164:
						position, tokenIndex = position163, tokenIndex163
						if buffer[position] != rune('D') {
							goto l162
						}
						position++
					}
				l163:
					{
						add(ruleAction41, position)
					}
					if !_rules[ruleeDice2]() {
						goto l162
					}
					if !_rules[rulekqDiceOp]() {
						goto l162
					}
					{
						add(ruleAction42, position)
					}
					goto l156
				l162:
					position, tokenIndex = position156, tokenIndex156
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l169
						}
						position++
						goto l168
					l169:
						position, tokenIndex = position168, tokenIndex168
						if buffer[position] != rune('D') {
							goto l167
						}
						position++
					}
				l168:
					if !_rules[ruledndDiceSuffix]() {
						goto l167
					}
					{
						add(ruleAction43, position)
					}
					goto l156
				l167:
					position, tokenIndex = position156, tokenIndex156
					{
						position172, tokenIndex172 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l173
						}
						position++
						goto l172
					l173:
						position, tokenIndex = position172, tokenIndex172
						if buffer[position] != rune('D') {
							goto l171
						}
						position++
					}
				l172:
					{
						position174, tokenIndex174 := position, tokenIndex
						{
							position175, tokenIndex175 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l175
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l175
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l175
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l175
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l175
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l175
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l175
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l175
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l175
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l175
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l175
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l175
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l175
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l175
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l175
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l175
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l175
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l175
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l175
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l175
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l175
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l175
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l175
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l175
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l175
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l175
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l175
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l175
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l175
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l175
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l175
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l175
									}
									position++
								}
							}

							goto l174
						l175:
							position, tokenIndex = position175, tokenIndex175
						}
						if !matchDot() {
							goto l174
						}
						goto l171
					l174:
						position, tokenIndex = position174, tokenIndex174
					}
					if !_rules[rulesp]() {
						goto l171
					}
					{
						add(ruleAction44, position)
					}
					goto l156
				l171:
					position, tokenIndex = position156, tokenIndex156
					if !_rules[ruleeDice2]() {
						goto l154
					}
				l178:
					{
						position179, tokenIndex179 := position, tokenIndex
						{
							position180, tokenIndex180 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l181
							}
							position++
							goto l180
						l181:
							position, tokenIndex = position180, tokenIndex180
							if buffer[position] != rune('D') {
								goto l179
							}
							position++
						}
					l180:
						{
							add(ruleAction45, position)
						}
						{
							position183, tokenIndex183 := position, tokenIndex
							{
								position184, tokenIndex184 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l185
								}
								goto l184
							l185:
								position, tokenIndex = position184, tokenIndex184
								if buffer[position] != rune('(') {
									goto l179
								}
								position++
							}
						l184:
							position, tokenIndex = position183, tokenIndex183
						}
						if !_rules[ruleeDice2]() {
							goto l179
						}
						if !_rules[rulekqDiceOp]() {
							goto l179
						}
						{
							add(ruleAction46, position)
						}
						goto l178
					l179:
						position, tokenIndex = position179, tokenIndex179
					}
				}
			l156:
				add(ruleeDice, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 17 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				{
					position189, tokenIndex189 := position, tokenIndex
					{
						position190, tokenIndex190 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l191
						}
						goto l190
					l191:
						position, tokenIndex = position190, tokenIndex190
						if buffer[position] != rune('(') {
							goto l187
						}
						position++
					}
				l190:
					position, tokenIndex = position189, tokenIndex189
				}
				add(rulelaNumberOrLeftParen, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 18 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action47) / (('p' / 'P') Action48) / eDice3)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					{
						position196, tokenIndex196 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l197
						}
						position++
						goto l196
					l197:
						position, tokenIndex = position196, tokenIndex196
						if buffer[position] != rune('P') {
							goto l195
						}
						position++
					}
				l196:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l195
					}
					if !_rules[ruleeDice3]() {
						goto l195
					}
					{
						add(ruleAction47, position)
					}
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					{
						position200, tokenIndex200 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l201
						}
						position++
						goto l200
					l201:
						position, tokenIndex = position200, tokenIndex200
						if buffer[position] != rune('P') {
							goto l199
						}
						position++
					}
				l200:
					{
						add(ruleAction48, position)
					}
					goto l194
				l199:
					position, tokenIndex = position194, tokenIndex194
					if !_rules[ruleeDice3]() {
						goto l192
					}
				}
			l194:
				add(ruleeDice2, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 19 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action49) / (('b' / 'B') Action50) / eDice4)> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				{
					position205, tokenIndex205 := position, tokenIndex
					{
						position207, tokenIndex207 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l208
						}
						position++
						goto l207
					l208:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('B') {
							goto l206
						}
						position++
					}
				l207:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l206
					}
					if !_rules[rulevalue]() {
						goto l206
					}
					{
						add(ruleAction49, position)
					}
					goto l205
				l206:
					position, tokenIndex = position205, tokenIndex205
					{
						position211, tokenIndex211 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l212
						}
						position++
						goto l211
					l212:
						position, tokenIndex = position211, tokenIndex211
						if buffer[position] != rune('B') {
							goto l210
						}
						position++
					}
				l211:
					{
						add(ruleAction50, position)
					}
					goto l205
				l210:
					position, tokenIndex = position205, tokenIndex205
					{
						position214 := position
						{
							position215, tokenIndex215 := position, tokenIndex
							{
								position217, tokenIndex217 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l218
								}
								position++
								goto l217
							l218:
								position, tokenIndex = position217, tokenIndex217
								if buffer[position] != rune('F') {
									goto l216
								}
								position++
							}
						l217:
							if !_rules[rulesp]() {
								goto l216
							}
							{
								add(ruleAction51, position)
							}
							goto l215
						l216:
							position, tokenIndex = position215, tokenIndex215
							if !_rules[rulevalue]() {
								goto l203
							}
						}
					l215:
						add(ruleeDice4, position214)
					}
				}
			l205:
				add(ruleeDice3, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 20 eDice4 <- <((('f' / 'F') sp Action51) / value)> */
		nil,
		/* 21 value <- <(number / assign_expr / (identifier Action52) / sub)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				{
					position223, tokenIndex223 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l224
					}
					goto l223
				l224:
					position, tokenIndex = position223, tokenIndex223
					{
						position226 := position
						if !_rules[ruleidentifier]() {
							goto l225
						}
						{
							add(ruleAction2, position)
						}
						if buffer[position] != rune('=') {
							goto l225
						}
						position++
						if !_rules[rulee0]() {
							goto l225
						}
						{
							add(ruleAction3, position)
						}
						add(ruleassign_expr, position226)
					}
					goto l223
				l225:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[ruleidentifier]() {
						goto l229
					}
					{
						add(ruleAction52, position)
					}
					goto l223
				l229:
					position, tokenIndex = position223, tokenIndex223
					{
						position231 := position
						{
							position232 := position
							if buffer[position] != rune('(') {
								goto l221
							}
							position++
							if !_rules[rulesp]() {
								goto l221
							}
							add(ruleopen, position232)
						}
						if !_rules[rulee0]() {
							goto l221
						}
						{
							position233 := position
							if buffer[position] != rune(')') {
								goto l221
							}
							position++
							if !_rules[rulesp]() {
								goto l221
							}
							add(ruleclose, position233)
						}
						add(rulesub, position231)
					}
				}
			l223:
				add(rulevalue, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 22 number <- <(<[0-9]+> sp Action53)> */
		func() bool {
			position234, tokenIndex234 := position, tokenIndex
			{
				position235 := position
				{
					position236 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l234
					}
					position++
				l237:
					{
						position238, tokenIndex238 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l238
						}
						position++
						goto l237
					l238:
						position, tokenIndex = position238, tokenIndex238
					}
					add(rulePegText, position236)
				}
				if !_rules[rulesp]() {
					goto l234
				}
				{
					add(ruleAction53, position)
				}
				add(rulenumber, position235)
			}
			return true
		l234:
			position, tokenIndex = position234, tokenIndex234
			return false
		},
		/* 23 identifier <- <(<(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				{
					position242 := position
					{
						position243, tokenIndex243 := position, tokenIndex
						{
							switch buffer[position] {
							case '\r':
								if buffer[position] != rune('\r') {
									goto l243
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l243
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l243
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l243
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l243
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l243
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l243
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l243
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l243
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l243
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l243
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l243
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l243
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l243
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l243
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l243
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l243
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l243
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l243
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l243
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l243
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l243
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l243
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l243
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l243
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l243
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l243
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l243
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l243
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l243
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l243
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l243
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l243
								}
								position++
							}
						}

						goto l240
					l243:
						position, tokenIndex = position243, tokenIndex243
					}
					if !matchDot() {
						goto l240
					}
				l245:
					{
						position246, tokenIndex246 := position, tokenIndex
						{
							position247, tokenIndex247 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l247
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l247
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l247
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l247
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l247
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l247
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l247
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l247
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l247
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l247
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l247
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l247
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l247
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l247
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l247
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l247
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l247
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l247
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l247
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l247
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l247
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l247
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l247
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l247
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l247
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l247
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l247
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l247
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l247
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l247
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l247
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l247
									}
									position++
								}
							}

							goto l246
						l247:
							position, tokenIndex = position247, tokenIndex247
						}
						if !matchDot() {
							goto l246
						}
						goto l245
					l246:
						position, tokenIndex = position246, tokenIndex246
					}
					add(rulePegText, position242)
				}
				if !_rules[rulesp]() {
					goto l240
				}
				add(ruleidentifier, position241)
			}
			return true
		l240:
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 24 sub <- <(open e0 close)> */
		nil,
		/* 25 add <- <(('+' / '＋') sp)> */
		func() bool {
			position250, tokenIndex250 := position, tokenIndex
			{
				position251 := position
				{
					position252, tokenIndex252 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l253
					}
					position++
					goto l252
				l253:
					position, tokenIndex = position252, tokenIndex252
					if buffer[position] != rune('＋') {
						goto l250
					}
					position++
				}
			l252:
				if !_rules[rulesp]() {
					goto l250
				}
				add(ruleadd, position251)
			}
			return true
		l250:
			position, tokenIndex = position250, tokenIndex250
			return false
		},
		/* 26 minus <- <(('-' / '－') sp)> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				{
					position256, tokenIndex256 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l257
					}
					position++
					goto l256
				l257:
					position, tokenIndex = position256, tokenIndex256
					if buffer[position] != rune('－') {
						goto l254
					}
					position++
				}
			l256:
				if !_rules[rulesp]() {
					goto l254
				}
				add(ruleminus, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 27 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 28 divide <- <(('/' / '／') sp)> */
		nil,
		/* 29 modulus <- <('%' sp)> */
		nil,
		/* 30 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 31 open <- <('(' sp)> */
		nil,
		/* 32 close <- <(')' sp)> */
		nil,
		/* 33 sp <- <(' ' / '\t')*> */
		func() bool {
			{
				position265 := position
			l266:
				{
					position267, tokenIndex267 := position, tokenIndex
					{
						position268, tokenIndex268 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l269
						}
						position++
						goto l268
					l269:
						position, tokenIndex = position268, tokenIndex268
						if buffer[position] != rune('\t') {
							goto l267
						}
						position++
					}
				l268:
					goto l266
				l267:
					position, tokenIndex = position267, tokenIndex267
				}
				add(rulesp, position265)
			}
			return true
		},
		/* 34 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 35 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 36 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 37 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 38 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 39 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 40 fstring <- <('`' <(('{' sp e0m sp '}') / escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('`') '`')) .))*> '`' sp Action54)> */
		nil,
		/* 41 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 43 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 44 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 45 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 46 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 47 Action4 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 48 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 49 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 50 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 51 Action8 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 52 Action9 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 53 Action10 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 54 Action11 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 55 Action12 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 56 Action13 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 57 Action14 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 58 Action15 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 59 Action16 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 60 Action17 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 61 Action18 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 62 Action19 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 63 Action20 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 64 Action21 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 65 Action22 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 66 Action23 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 67 Action24 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 68 Action25 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 69 Action26 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 70 Action27 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 71 Action28 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 72 Action29 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 73 Action30 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 74 Action31 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 75 Action32 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 76 Action33 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 77 Action34 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 78 Action35 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 79 Action36 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 80 Action37 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 81 Action38 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 82 Action39 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 83 Action40 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 84 Action41 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 85 Action42 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 86 Action43 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 87 Action44 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 88 Action45 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 89 Action46 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 90 Action47 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 91 Action48 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 92 Action49 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 93 Action50 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 94 Action51 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 95 Action52 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 97 Action53 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 98 Action54 <- <{ p.AddFormatString(string(text)) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
