package dice

// Code generated by C:\Users\fy0\go\bin\peg.exe -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rules0
	ruleblock
	rulestmtElse
	rulestmtIf
	rulee0
	ruleeSimpleSwitch
	ruleeTernary
	ruleeBitwise
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulebitwiseOr
	rulelogicOr
	rulebitwiseAnd
	rulelogicAnd
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulestrPart
	rulestrPart1
	rulestrPart2
	rulestrPart3
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	rulePegText
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
	ruleAction71
	ruleAction72
	ruleAction73
	ruleAction74
	ruleAction75
	ruleAction76
	ruleAction77
	ruleAction78
	ruleAction79
	ruleAction80
	ruleAction81
	ruleAction82
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"s0",
	"block",
	"stmtElse",
	"stmtIf",
	"e0",
	"eSimpleSwitch",
	"eTernary",
	"eBitwise",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"bitwiseOr",
	"logicOr",
	"bitwiseAnd",
	"logicAnd",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"strPart",
	"strPart1",
	"strPart2",
	"strPart3",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"PegText",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
	"Action71",
	"Action72",
	"Action73",
	"Action74",
	"Action75",
	"Action76",
	"Action77",
	"Action78",
	"Action79",
	"Action80",
	"Action81",
	"Action82",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [140]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypePop)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddValueStr("")
		case ruleAction9:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction10:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction11:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction12:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction13:
			p.PopAndSetOffset()
		case ruleAction14:
			p.CounterPush()
		case ruleAction15:
			p.CounterAdd(1)
		case ruleAction16:
			p.AddValueStr("")
			limit := p.CounterPop() + 1
			for i := int64(0); i < limit; i++ {
				p.PopAndSetOffset()
			}
		case ruleAction17:
			p.AddLeftValueMark()
		case ruleAction18:
			p.AddOperator(TypeBitwiseOr)
		case ruleAction19:
			p.AddLeftValueMark()
		case ruleAction20:
			p.AddOperator(TypeBitwiseAnd)
		case ruleAction21:
			p.AddLeftValueMark()
		case ruleAction22:
			p.AddOperator(TypeCompLT)
		case ruleAction23:
			p.AddLeftValueMark()
		case ruleAction24:
			p.AddOperator(TypeCompLE)
		case ruleAction25:
			p.AddLeftValueMark()
		case ruleAction26:
			p.AddOperator(TypeCompEQ)
		case ruleAction27:
			p.AddLeftValueMark()
		case ruleAction28:
			p.AddOperator(TypeCompNE)
		case ruleAction29:
			p.AddLeftValueMark()
		case ruleAction30:
			p.AddOperator(TypeCompGE)
		case ruleAction31:
			p.AddLeftValueMark()
		case ruleAction32:
			p.AddOperator(TypeCompGT)
		case ruleAction33:
			p.AddLeftValueMark()
		case ruleAction34:
			p.AddOperator(TypeAdd)
		case ruleAction35:
			p.AddLeftValueMark()
		case ruleAction36:
			p.AddOperator(TypeSubtract)
		case ruleAction37:
			p.AddLeftValueMark()
		case ruleAction38:
			p.AddOperator(TypeMultiply)
		case ruleAction39:
			p.AddLeftValueMark()
		case ruleAction40:
			p.AddOperator(TypeDivide)
		case ruleAction41:
			p.AddLeftValueMark()
		case ruleAction42:
			p.AddOperator(TypeModulus)
		case ruleAction43:
			p.AddLeftValueMark()
		case ruleAction44:
			p.AddOperator(TypeExponentiation)
		case ruleAction45:
			p.AddOperator(TypeNegation)
		case ruleAction46:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction47:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction48:
			p.AddOperator(TypeDiceSetK)
		case ruleAction49:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction50:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction51:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction52:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction53:
			p.AddOperator(TypeDice)
		case ruleAction54:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction55:
			p.AddOperator(TypeDice)
		case ruleAction56:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction57:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction58:
			p.AddLeftValueMark()
		case ruleAction59:
			p.AddOperator(TypeDice)
		case ruleAction60:
			p.AddOperator(TypeDicePenalty)
		case ruleAction61:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction62:
			p.AddOperator(TypeDiceBonus)
		case ruleAction63:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction64:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction65:
			p.AddLoadVarname(string(text))
		case ruleAction66:
			p.AddValue(string(text))
		case ruleAction67:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction68:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction69:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction70:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction71:
			p.CounterPush()
		case ruleAction72:
			p.CounterAdd(1)
		case ruleAction73:
			p.CounterAdd(1)
		case ruleAction74:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction75:
			p.CounterPush()
		case ruleAction76:
			p.CounterAdd(1)
		case ruleAction77:
			p.CounterAdd(1)
		case ruleAction78:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction79:
			p.CounterPush()
		case ruleAction80:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction81:
			p.CounterPush()
		case ruleAction82:
			p.AddFormatString(string(text), p.CounterPop())

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulee]() {
					goto l0
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <(eOne (';' sp Action1 eOne?)*)> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				if !_rules[ruleeOne]() {
					goto l3
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if buffer[position] != rune(';') {
						goto l6
					}
					position++
					if !_rules[rulesp]() {
						goto l6
					}
					{
						add(ruleAction1, position)
					}
					{
						position8, tokenIndex8 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l8
						}
						goto l9
					l8:
						position, tokenIndex = position8, tokenIndex8
					}
				l9:
					goto l5
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(rulee, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 eOne <- <(sp (s0 / e0 / assign_expr))> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[rulesp]() {
					goto l10
				}
				{
					position12, tokenIndex12 := position, tokenIndex
					{
						position14 := position
						{
							position15 := position
							if buffer[position] != rune('i') {
								goto l13
							}
							position++
							if buffer[position] != rune('f') {
								goto l13
							}
							position++
							if !_rules[rulesp]() {
								goto l13
							}
							if !_rules[rulee0]() {
								goto l13
							}
							{
								add(ruleAction5, position)
							}
							if !_rules[ruleblock]() {
								goto l13
							}
							{
								add(ruleAction6, position)
							}
							{
								position18, tokenIndex18 := position, tokenIndex
								{
									position20 := position
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if buffer[position] != rune('l') {
										goto l18
									}
									position++
									if buffer[position] != rune('s') {
										goto l18
									}
									position++
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if !_rules[rulesp]() {
										goto l18
									}
									if !_rules[ruleblock]() {
										goto l18
									}
									add(rulestmtElse, position20)
								}
								goto l19
							l18:
								position, tokenIndex = position18, tokenIndex18
							}
						l19:
							{
								add(ruleAction7, position)
							}
							{
								add(ruleAction8, position)
							}
							add(rulestmtIf, position15)
						}
						add(rules0, position14)
					}
					goto l12
				l13:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[rulee0]() {
						goto l23
					}
					goto l12
				l23:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleassign_expr]() {
						goto l10
					}
				}
			l12:
				add(ruleeOne, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' sp e0 Action3)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if !_rules[ruleidentifier]() {
					goto l24
				}
				{
					add(ruleAction2, position)
				}
				if buffer[position] != rune('=') {
					goto l24
				}
				position++
				if !_rules[rulesp]() {
					goto l24
				}
				if !_rules[rulee0]() {
					goto l24
				}
				{
					add(ruleAction3, position)
				}
				add(ruleassign_expr, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 4 s0 <- <stmtIf> */
		nil,
		/* 5 block <- <((('{' sp '}') / ('{' sp e Action4 '}')) sp)> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				{
					position31, tokenIndex31 := position, tokenIndex
					if buffer[position] != rune('{') {
						goto l32
					}
					position++
					if !_rules[rulesp]() {
						goto l32
					}
					if buffer[position] != rune('}') {
						goto l32
					}
					position++
					goto l31
				l32:
					position, tokenIndex = position31, tokenIndex31
					if buffer[position] != rune('{') {
						goto l29
					}
					position++
					if !_rules[rulesp]() {
						goto l29
					}
					if !_rules[rulee]() {
						goto l29
					}
					{
						add(ruleAction4, position)
					}
					if buffer[position] != rune('}') {
						goto l29
					}
					position++
				}
			l31:
				if !_rules[rulesp]() {
					goto l29
				}
				add(ruleblock, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 6 stmtElse <- <('e' 'l' 's' 'e' sp block)> */
		nil,
		/* 7 stmtIf <- <('i' 'f' sp e0 Action5 block Action6 stmtElse? Action7 Action8)> */
		nil,
		/* 8 e0 <- <eTernary> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				{
					position38 := position
					{
						position39, tokenIndex39 := position, tokenIndex
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune('?') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction11, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune(':') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction12, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						{
							add(ruleAction13, position)
						}
						goto l39
					l40:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeSimpleSwitch]() {
							goto l44
						}
						{
							add(ruleAction14, position)
						}
					l46:
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l47
							}
							position++
							if !_rules[rulesp]() {
								goto l47
							}
							if !_rules[ruleeSimpleSwitch]() {
								goto l47
							}
							{
								add(ruleAction15, position)
							}
							goto l46
						l47:
							position, tokenIndex = position47, tokenIndex47
						}
						{
							add(ruleAction16, position)
						}
						goto l39
					l44:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeBitwise]() {
							goto l36
						}
					}
				l39:
					add(ruleeTernary, position38)
				}
				add(rulee0, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 9 eSimpleSwitch <- <(eBitwise '?' sp Action9 eBitwise Action10)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				if buffer[position] != rune('?') {
					goto l50
				}
				position++
				if !_rules[rulesp]() {
					goto l50
				}
				{
					add(ruleAction9, position)
				}
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				{
					add(ruleAction10, position)
				}
				add(ruleeSimpleSwitch, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 10 eTernary <- <((eBitwise '?' sp Action11 eBitwise ':' sp Action12 eBitwise Action13) / (eSimpleSwitch Action14 (',' sp eSimpleSwitch Action15)* Action16) / eBitwise)> */
		nil,
		/* 11 eBitwise <- <(eComp (((logicOr / bitwiseOr) Action17 eComp Action18) / ((logicAnd / bitwiseAnd) Action19 eComp Action20))*)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleeComp]() {
					goto l55
				}
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						{
							position61, tokenIndex61 := position, tokenIndex
							{
								position63 := position
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if !_rules[rulesp]() {
									goto l62
								}
								add(rulelogicOr, position63)
							}
							goto l61
						l62:
							position, tokenIndex = position61, tokenIndex61
							{
								position64 := position
								if buffer[position] != rune('|') {
									goto l60
								}
								position++
								if !_rules[rulesp]() {
									goto l60
								}
								add(rulebitwiseOr, position64)
							}
						}
					l61:
						{
							add(ruleAction17, position)
						}
						if !_rules[ruleeComp]() {
							goto l60
						}
						{
							add(ruleAction18, position)
						}
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						{
							position67, tokenIndex67 := position, tokenIndex
							{
								position69 := position
								{
									position70, tokenIndex70 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									goto l70
								l71:
									position, tokenIndex = position70, tokenIndex70
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
								}
							l70:
								if !_rules[rulesp]() {
									goto l68
								}
								add(rulelogicAnd, position69)
							}
							goto l67
						l68:
							position, tokenIndex = position67, tokenIndex67
							{
								position72 := position
								{
									position73, tokenIndex73 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l74
									}
									position++
									goto l73
								l74:
									position, tokenIndex = position73, tokenIndex73
									if buffer[position] != rune('&') {
										goto l58
									}
									position++
									if buffer[position] != rune('a') {
										goto l58
									}
									position++
									if buffer[position] != rune('m') {
										goto l58
									}
									position++
									if buffer[position] != rune('p') {
										goto l58
									}
									position++
									if buffer[position] != rune(';') {
										goto l58
									}
									position++
								}
							l73:
								if !_rules[rulesp]() {
									goto l58
								}
								add(rulebitwiseAnd, position72)
							}
						}
					l67:
						{
							add(ruleAction19, position)
						}
						if !_rules[ruleeComp]() {
							goto l58
						}
						{
							add(ruleAction20, position)
						}
					}
				l59:
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(ruleeBitwise, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 12 eComp <- <(e1 ((lt Action21 e1 Action22) / (ge Action29 e1 Action30) / ((&('>') (gt Action31 e1 Action32)) | (&('!') (ne Action27 e1 Action28)) | (&('=') (eq Action25 e1 Action26)) | (&('<') (le Action23 e1 Action24))))*)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if !_rules[rulee1]() {
					goto l77
				}
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					{
						position81, tokenIndex81 := position, tokenIndex
						{
							position83 := position
							{
								position84, tokenIndex84 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l85
								}
								position++
								goto l84
							l85:
								position, tokenIndex = position84, tokenIndex84
								if buffer[position] != rune('＜') {
									goto l82
								}
								position++
							}
						l84:
							if !_rules[rulesp]() {
								goto l82
							}
							add(rulelt, position83)
						}
						{
							add(ruleAction21, position)
						}
						if !_rules[rulee1]() {
							goto l82
						}
						{
							add(ruleAction22, position)
						}
						goto l81
					l82:
						position, tokenIndex = position81, tokenIndex81
						{
							position89 := position
							{
								position90, tokenIndex90 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l91
								}
								position++
								if buffer[position] != rune('=') {
									goto l91
								}
								position++
								goto l90
							l91:
								position, tokenIndex = position90, tokenIndex90
								if buffer[position] != rune('＞') {
									goto l88
								}
								position++
								if buffer[position] != rune('＝') {
									goto l88
								}
								position++
							}
						l90:
							if !_rules[rulesp]() {
								goto l88
							}
							add(rulege, position89)
						}
						{
							add(ruleAction29, position)
						}
						if !_rules[rulee1]() {
							goto l88
						}
						{
							add(ruleAction30, position)
						}
						goto l81
					l88:
						position, tokenIndex = position81, tokenIndex81
						{
							switch buffer[position] {
							case '>':
								{
									position95 := position
									{
										position96, tokenIndex96 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l97
										}
										position++
										goto l96
									l97:
										position, tokenIndex = position96, tokenIndex96
										if buffer[position] != rune('＞') {
											goto l80
										}
										position++
									}
								l96:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulegt, position95)
								}
								{
									add(ruleAction31, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction32, position)
								}
							case '!':
								{
									position100 := position
									{
										position101, tokenIndex101 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l102
										}
										position++
										if buffer[position] != rune('=') {
											goto l102
										}
										position++
										goto l101
									l102:
										position, tokenIndex = position101, tokenIndex101
										if buffer[position] != rune('！') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l101:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulene, position100)
								}
								{
									add(ruleAction27, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction28, position)
								}
							case '=':
								{
									position105 := position
									{
										position106, tokenIndex106 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										goto l106
									l107:
										position, tokenIndex = position106, tokenIndex106
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l106:
									if !_rules[rulesp]() {
										goto l80
									}
									add(ruleeq, position105)
								}
								{
									add(ruleAction25, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction26, position)
								}
							default:
								{
									position110 := position
									{
										position111, tokenIndex111 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l112
										}
										position++
										if buffer[position] != rune('=') {
											goto l112
										}
										position++
										goto l111
									l112:
										position, tokenIndex = position111, tokenIndex111
										if buffer[position] != rune('＜') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l111:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulele, position110)
								}
								{
									add(ruleAction23, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction24, position)
								}
							}
						}

					}
				l81:
					goto l79
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
				add(ruleeComp, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 13 e1 <- <(e2 ((add Action33 e2 Action34) / (minus Action35 e2 Action36))*)> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				if !_rules[rulee2]() {
					goto l115
				}
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					{
						position119, tokenIndex119 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l120
						}
						{
							add(ruleAction33, position)
						}
						if !_rules[rulee2]() {
							goto l120
						}
						{
							add(ruleAction34, position)
						}
						goto l119
					l120:
						position, tokenIndex = position119, tokenIndex119
						if !_rules[ruleminus]() {
							goto l118
						}
						{
							add(ruleAction35, position)
						}
						if !_rules[rulee2]() {
							goto l118
						}
						{
							add(ruleAction36, position)
						}
					}
				l119:
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(rulee1, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 14 e2 <- <(e3 ((&('%') (modulus Action41 e3 Action42)) | (&('/') (divide Action39 e3 Action40)) | (&('*') (multiply Action37 e3 Action38)))*)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				if !_rules[rulee3]() {
					goto l125
				}
			l127:
				{
					position128, tokenIndex128 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position130 := position
								if buffer[position] != rune('%') {
									goto l128
								}
								position++
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemodulus, position130)
							}
							{
								add(ruleAction41, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction42, position)
							}
						case '/':
							{
								position133 := position
								{
									position134, tokenIndex134 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l135
									}
									position++
									goto l134
								l135:
									position, tokenIndex = position134, tokenIndex134
									if buffer[position] != rune('／') {
										goto l128
									}
									position++
								}
							l134:
								if !_rules[rulesp]() {
									goto l128
								}
								add(ruledivide, position133)
							}
							{
								add(ruleAction39, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction40, position)
							}
						default:
							{
								position138 := position
								{
									position139, tokenIndex139 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l140
									}
									position++
									goto l139
								l140:
									position, tokenIndex = position139, tokenIndex139
									if buffer[position] != rune('＊') {
										goto l128
									}
									position++
								}
							l139:
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemultiply, position138)
							}
							{
								add(ruleAction37, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction38, position)
							}
						}
					}

					goto l127
				l128:
					position, tokenIndex = position128, tokenIndex128
				}
				add(rulee2, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 15 e3 <- <(e4 (exponentiation Action43 e4 Action44)*)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if !_rules[rulee4]() {
					goto l143
				}
			l145:
				{
					position146, tokenIndex146 := position, tokenIndex
					{
						position147 := position
						{
							position148, tokenIndex148 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l149
							}
							position++
							if !_rules[rulesp]() {
								goto l149
							}
							goto l148
						l149:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if !_rules[rulesp]() {
								goto l146
							}
						}
					l148:
						add(ruleexponentiation, position147)
					}
					{
						add(ruleAction43, position)
					}
					if !_rules[rulee4]() {
						goto l146
					}
					{
						add(ruleAction44, position)
					}
					goto l145
				l146:
					position, tokenIndex = position146, tokenIndex146
				}
				add(rulee3, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 16 e4 <- <((minus e5 Action45) / e5)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l155
					}
					if !_rules[rulee5]() {
						goto l155
					}
					{
						add(ruleAction45, position)
					}
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[rulee5]() {
						goto l152
					}
				}
			l154:
				add(rulee4, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 17 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				{
					position159, tokenIndex159 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l160
					}
					if !_rules[ruleeDice]() {
						goto l160
					}
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if !_rules[ruleeDice]() {
						goto l157
					}
				}
			l159:
				add(rulee5, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 18 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action46 sp) / ((('劣' '势') / ('k' 'l')) Action47 sp))> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position163, tokenIndex163 := position, tokenIndex
					{
						position165, tokenIndex165 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l166
						}
						position++
						if buffer[position] != rune('势') {
							goto l166
						}
						position++
						goto l165
					l166:
						position, tokenIndex = position165, tokenIndex165
						if buffer[position] != rune('k') {
							goto l164
						}
						position++
						if buffer[position] != rune('h') {
							goto l164
						}
						position++
					}
				l165:
					{
						add(ruleAction46, position)
					}
					if !_rules[rulesp]() {
						goto l164
					}
					goto l163
				l164:
					position, tokenIndex = position163, tokenIndex163
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l169
						}
						position++
						if buffer[position] != rune('势') {
							goto l169
						}
						position++
						goto l168
					l169:
						position, tokenIndex = position168, tokenIndex168
						if buffer[position] != rune('k') {
							goto l161
						}
						position++
						if buffer[position] != rune('l') {
							goto l161
						}
						position++
					}
				l168:
					{
						add(ruleAction47, position)
					}
					if !_rules[rulesp]() {
						goto l161
					}
				}
			l163:
				add(ruledndDiceSuffix, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 19 kqDiceOp <- <(('k' eDice2 Action48)? ('q' eDice2 Action49)? ('d' 'l' eDice2 Action50)? ('d' 'h' eDice2 Action51)?)> */
		func() bool {
			{
				position172 := position
				{
					position173, tokenIndex173 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l173
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l173
					}
					{
						add(ruleAction48, position)
					}
					goto l174
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
			l174:
				{
					position176, tokenIndex176 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l176
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l176
					}
					{
						add(ruleAction49, position)
					}
					goto l177
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
			l177:
				{
					position179, tokenIndex179 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l179
					}
					position++
					if buffer[position] != rune('l') {
						goto l179
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l179
					}
					{
						add(ruleAction50, position)
					}
					goto l180
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
			l180:
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l182
					}
					position++
					if buffer[position] != rune('h') {
						goto l182
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l182
					}
					{
						add(ruleAction51, position)
					}
					goto l183
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
			l183:
				add(rulekqDiceOp, position172)
			}
			return true
		},
		/* 20 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					{
						position188, tokenIndex188 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l189
						}
						position++
						goto l188
					l189:
						position, tokenIndex = position188, tokenIndex188
						if buffer[position] != rune('D') {
							goto l185
						}
						position++
					}
				l188:
					{
						position190, tokenIndex190 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l191
						}
						goto l190
					l191:
						position, tokenIndex = position190, tokenIndex190
						if buffer[position] != rune('(') {
							goto l185
						}
						position++
					}
				l190:
					position, tokenIndex = position187, tokenIndex187
				}
				add(rule_dnumber, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 21 eDice <- <((_dnumber ('d' / 'D') Action52 eDice2 dndDiceSuffix Action53) / (_dnumber ('d' / 'D') Action54 eDice2 kqDiceOp Action55) / (('d' / 'D') dndDiceSuffix Action56) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action57) / (eDice2 (('d' / 'D') Action58 &(number / '(') eDice2 kqDiceOp Action59)*))> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l195
					}
					{
						position196, tokenIndex196 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l197
						}
						position++
						goto l196
					l197:
						position, tokenIndex = position196, tokenIndex196
						if buffer[position] != rune('D') {
							goto l195
						}
						position++
					}
				l196:
					{
						add(ruleAction52, position)
					}
					if !_rules[ruleeDice2]() {
						goto l195
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l195
					}
					{
						add(ruleAction53, position)
					}
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					if !_rules[rule_dnumber]() {
						goto l200
					}
					{
						position201, tokenIndex201 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l202
						}
						position++
						goto l201
					l202:
						position, tokenIndex = position201, tokenIndex201
						if buffer[position] != rune('D') {
							goto l200
						}
						position++
					}
				l201:
					{
						add(ruleAction54, position)
					}
					if !_rules[ruleeDice2]() {
						goto l200
					}
					if !_rules[rulekqDiceOp]() {
						goto l200
					}
					{
						add(ruleAction55, position)
					}
					goto l194
				l200:
					position, tokenIndex = position194, tokenIndex194
					{
						position206, tokenIndex206 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l207
						}
						position++
						goto l206
					l207:
						position, tokenIndex = position206, tokenIndex206
						if buffer[position] != rune('D') {
							goto l205
						}
						position++
					}
				l206:
					if !_rules[ruledndDiceSuffix]() {
						goto l205
					}
					{
						add(ruleAction56, position)
					}
					goto l194
				l205:
					position, tokenIndex = position194, tokenIndex194
					{
						position210, tokenIndex210 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l211
						}
						position++
						goto l210
					l211:
						position, tokenIndex = position210, tokenIndex210
						if buffer[position] != rune('D') {
							goto l209
						}
						position++
					}
				l210:
					{
						position212, tokenIndex212 := position, tokenIndex
						{
							position213, tokenIndex213 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l213
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l213
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l213
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l213
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l213
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l213
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l213
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l213
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l213
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l213
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l213
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l213
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l213
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l213
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l213
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l213
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l213
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l213
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l213
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l213
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l213
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l213
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l213
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l213
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l213
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l213
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l213
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l213
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l213
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l213
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l213
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l213
									}
									position++
								}
							}

							goto l212
						l213:
							position, tokenIndex = position213, tokenIndex213
						}
						if !matchDot() {
							goto l212
						}
						goto l209
					l212:
						position, tokenIndex = position212, tokenIndex212
					}
					if !_rules[rulesp]() {
						goto l209
					}
					{
						add(ruleAction57, position)
					}
					goto l194
				l209:
					position, tokenIndex = position194, tokenIndex194
					if !_rules[ruleeDice2]() {
						goto l192
					}
				l216:
					{
						position217, tokenIndex217 := position, tokenIndex
						{
							position218, tokenIndex218 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l219
							}
							position++
							goto l218
						l219:
							position, tokenIndex = position218, tokenIndex218
							if buffer[position] != rune('D') {
								goto l217
							}
							position++
						}
					l218:
						{
							add(ruleAction58, position)
						}
						{
							position221, tokenIndex221 := position, tokenIndex
							{
								position222, tokenIndex222 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l223
								}
								goto l222
							l223:
								position, tokenIndex = position222, tokenIndex222
								if buffer[position] != rune('(') {
									goto l217
								}
								position++
							}
						l222:
							position, tokenIndex = position221, tokenIndex221
						}
						if !_rules[ruleeDice2]() {
							goto l217
						}
						if !_rules[rulekqDiceOp]() {
							goto l217
						}
						{
							add(ruleAction59, position)
						}
						goto l216
					l217:
						position, tokenIndex = position217, tokenIndex217
					}
				}
			l194:
				add(ruleeDice, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 22 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				{
					position227, tokenIndex227 := position, tokenIndex
					{
						position228, tokenIndex228 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l229
						}
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('(') {
							goto l225
						}
						position++
					}
				l228:
					position, tokenIndex = position227, tokenIndex227
				}
				add(rulelaNumberOrLeftParen, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 23 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action60) / (('p' / 'P') Action61) / eDice3)> */
		func() bool {
			position230, tokenIndex230 := position, tokenIndex
			{
				position231 := position
				{
					position232, tokenIndex232 := position, tokenIndex
					{
						position234, tokenIndex234 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l235
						}
						position++
						goto l234
					l235:
						position, tokenIndex = position234, tokenIndex234
						if buffer[position] != rune('P') {
							goto l233
						}
						position++
					}
				l234:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l233
					}
					if !_rules[ruleeDice3]() {
						goto l233
					}
					{
						add(ruleAction60, position)
					}
					goto l232
				l233:
					position, tokenIndex = position232, tokenIndex232
					{
						position238, tokenIndex238 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l239
						}
						position++
						goto l238
					l239:
						position, tokenIndex = position238, tokenIndex238
						if buffer[position] != rune('P') {
							goto l237
						}
						position++
					}
				l238:
					{
						add(ruleAction61, position)
					}
					goto l232
				l237:
					position, tokenIndex = position232, tokenIndex232
					if !_rules[ruleeDice3]() {
						goto l230
					}
				}
			l232:
				add(ruleeDice2, position231)
			}
			return true
		l230:
			position, tokenIndex = position230, tokenIndex230
			return false
		},
		/* 24 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action62) / (('b' / 'B') Action63) / eDice4)> */
		func() bool {
			position241, tokenIndex241 := position, tokenIndex
			{
				position242 := position
				{
					position243, tokenIndex243 := position, tokenIndex
					{
						position245, tokenIndex245 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l246
						}
						position++
						goto l245
					l246:
						position, tokenIndex = position245, tokenIndex245
						if buffer[position] != rune('B') {
							goto l244
						}
						position++
					}
				l245:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l244
					}
					if !_rules[rulevalue]() {
						goto l244
					}
					{
						add(ruleAction62, position)
					}
					goto l243
				l244:
					position, tokenIndex = position243, tokenIndex243
					{
						position249, tokenIndex249 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l250
						}
						position++
						goto l249
					l250:
						position, tokenIndex = position249, tokenIndex249
						if buffer[position] != rune('B') {
							goto l248
						}
						position++
					}
				l249:
					{
						add(ruleAction63, position)
					}
					goto l243
				l248:
					position, tokenIndex = position243, tokenIndex243
					{
						position252 := position
						{
							position253, tokenIndex253 := position, tokenIndex
							{
								position255, tokenIndex255 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l256
								}
								position++
								goto l255
							l256:
								position, tokenIndex = position255, tokenIndex255
								if buffer[position] != rune('F') {
									goto l254
								}
								position++
							}
						l255:
							if !_rules[rulesp]() {
								goto l254
							}
							{
								add(ruleAction64, position)
							}
							goto l253
						l254:
							position, tokenIndex = position253, tokenIndex253
							if !_rules[rulevalue]() {
								goto l241
							}
						}
					l253:
						add(ruleeDice4, position252)
					}
				}
			l243:
				add(ruleeDice3, position242)
			}
			return true
		l241:
			position, tokenIndex = position241, tokenIndex241
			return false
		},
		/* 25 eDice4 <- <((('f' / 'F') sp Action64) / value)> */
		nil,
		/* 26 value <- <(number / assign_expr / (identifier Action65) / sub / fstring)> */
		func() bool {
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				{
					position261, tokenIndex261 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l262
					}
					goto l261
				l262:
					position, tokenIndex = position261, tokenIndex261
					if !_rules[ruleassign_expr]() {
						goto l263
					}
					goto l261
				l263:
					position, tokenIndex = position261, tokenIndex261
					if !_rules[ruleidentifier]() {
						goto l264
					}
					{
						add(ruleAction65, position)
					}
					goto l261
				l264:
					position, tokenIndex = position261, tokenIndex261
					{
						position267 := position
						{
							position268 := position
							if buffer[position] != rune('(') {
								goto l266
							}
							position++
							if !_rules[rulesp]() {
								goto l266
							}
							add(ruleopen, position268)
						}
						if !_rules[rulee0]() {
							goto l266
						}
						{
							position269 := position
							if buffer[position] != rune(')') {
								goto l266
							}
							position++
							if !_rules[rulesp]() {
								goto l266
							}
							add(ruleclose, position269)
						}
						add(rulesub, position267)
					}
					goto l261
				l266:
					position, tokenIndex = position261, tokenIndex261
					{
						position270 := position
						{
							switch buffer[position] {
							case '\'':
								if buffer[position] != rune('\'') {
									goto l259
								}
								position++
								{
									add(ruleAction81, position)
								}
								{
									position273 := position
								l274:
									{
										position275, tokenIndex275 := position, tokenIndex
										{
											position276 := position
											{
												position277 := position
												{
													position280, tokenIndex280 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l281
													}
													goto l280
												l281:
													position, tokenIndex = position280, tokenIndex280
													{
														position282, tokenIndex282 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l282
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l282
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l282
																}
																position++
															case '\'':
																if buffer[position] != rune('\'') {
																	goto l282
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l282
																}
																position++
															}
														}

														goto l275
													l282:
														position, tokenIndex = position282, tokenIndex282
													}
													if !matchDot() {
														goto l275
													}
												}
											l280:
											l278:
												{
													position279, tokenIndex279 := position, tokenIndex
													{
														position284, tokenIndex284 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l285
														}
														goto l284
													l285:
														position, tokenIndex = position284, tokenIndex284
														{
															position286, tokenIndex286 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l286
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l286
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l286
																	}
																	position++
																case '\'':
																	if buffer[position] != rune('\'') {
																		goto l286
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l286
																	}
																	position++
																}
															}

															goto l279
														l286:
															position, tokenIndex = position286, tokenIndex286
														}
														if !matchDot() {
															goto l279
														}
													}
												l284:
													goto l278
												l279:
													position, tokenIndex = position279, tokenIndex279
												}
												add(rulePegText, position277)
											}
											{
												add(ruleAction70, position)
											}
											add(rulestrPart3, position276)
										}
										goto l274
									l275:
										position, tokenIndex = position275, tokenIndex275
									}
									add(rulePegText, position273)
								}
								if buffer[position] != rune('\'') {
									goto l259
								}
								position++
								{
									add(ruleAction82, position)
								}
							case '"':
								if buffer[position] != rune('"') {
									goto l259
								}
								position++
								{
									add(ruleAction79, position)
								}
								{
									position291 := position
								l292:
									{
										position293, tokenIndex293 := position, tokenIndex
										{
											position294 := position
											{
												position295 := position
												{
													position298, tokenIndex298 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l299
													}
													goto l298
												l299:
													position, tokenIndex = position298, tokenIndex298
													{
														position300, tokenIndex300 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l300
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l300
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l300
																}
																position++
															case '"':
																if buffer[position] != rune('"') {
																	goto l300
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l300
																}
																position++
															}
														}

														goto l293
													l300:
														position, tokenIndex = position300, tokenIndex300
													}
													if !matchDot() {
														goto l293
													}
												}
											l298:
											l296:
												{
													position297, tokenIndex297 := position, tokenIndex
													{
														position302, tokenIndex302 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l303
														}
														goto l302
													l303:
														position, tokenIndex = position302, tokenIndex302
														{
															position304, tokenIndex304 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l304
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l304
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l304
																	}
																	position++
																case '"':
																	if buffer[position] != rune('"') {
																		goto l304
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l304
																	}
																	position++
																}
															}

															goto l297
														l304:
															position, tokenIndex = position304, tokenIndex304
														}
														if !matchDot() {
															goto l297
														}
													}
												l302:
													goto l296
												l297:
													position, tokenIndex = position297, tokenIndex297
												}
												add(rulePegText, position295)
											}
											{
												add(ruleAction69, position)
											}
											add(rulestrPart2, position294)
										}
										goto l292
									l293:
										position, tokenIndex = position293, tokenIndex293
									}
									add(rulePegText, position291)
								}
								if buffer[position] != rune('"') {
									goto l259
								}
								position++
								{
									add(ruleAction80, position)
								}
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l259
								}
								position++
								{
									add(ruleAction75, position)
								}
								{
									position309 := position
								l310:
									{
										position311, tokenIndex311 := position, tokenIndex
										{
											position312, tokenIndex312 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l313
											}
											position++
											if !_rules[rulesp]() {
												goto l313
											}
											if !_rules[rulee]() {
												goto l313
											}
											{
												add(ruleAction76, position)
											}
											if buffer[position] != rune('}') {
												goto l313
											}
											position++
											goto l312
										l313:
											position, tokenIndex = position312, tokenIndex312
											if buffer[position] != rune('{') {
												goto l315
											}
											position++
											if buffer[position] != rune('%') {
												goto l315
											}
											position++
											if !_rules[rulesp]() {
												goto l315
											}
											if !_rules[rulee]() {
												goto l315
											}
											{
												add(ruleAction77, position)
											}
											if buffer[position] != rune('%') {
												goto l315
											}
											position++
											if buffer[position] != rune('}') {
												goto l315
											}
											position++
											goto l312
										l315:
											position, tokenIndex = position312, tokenIndex312
											{
												position317 := position
												{
													position318 := position
													{
														position321, tokenIndex321 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l322
														}
														goto l321
													l322:
														position, tokenIndex = position321, tokenIndex321
														{
															position323, tokenIndex323 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l323
																	}
																	position++
																case '\x1e':
																	if buffer[position] != rune('\x1e') {
																		goto l323
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l323
																	}
																	position++
																}
															}

															goto l311
														l323:
															position, tokenIndex = position323, tokenIndex323
														}
														if !matchDot() {
															goto l311
														}
													}
												l321:
												l319:
													{
														position320, tokenIndex320 := position, tokenIndex
														{
															position325, tokenIndex325 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l326
															}
															goto l325
														l326:
															position, tokenIndex = position325, tokenIndex325
															{
																position327, tokenIndex327 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l327
																		}
																		position++
																	case '\x1e':
																		if buffer[position] != rune('\x1e') {
																			goto l327
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l327
																		}
																		position++
																	}
																}

																goto l320
															l327:
																position, tokenIndex = position327, tokenIndex327
															}
															if !matchDot() {
																goto l320
															}
														}
													l325:
														goto l319
													l320:
														position, tokenIndex = position320, tokenIndex320
													}
													add(rulePegText, position318)
												}
												{
													add(ruleAction68, position)
												}
												add(rulestrPart1, position317)
											}
										}
									l312:
										goto l310
									l311:
										position, tokenIndex = position311, tokenIndex311
									}
									add(rulePegText, position309)
								}
								if buffer[position] != rune('\x1e') {
									goto l259
								}
								position++
								{
									add(ruleAction78, position)
								}
							default:
								if buffer[position] != rune('`') {
									goto l259
								}
								position++
								{
									add(ruleAction71, position)
								}
								{
									position332 := position
								l333:
									{
										position334, tokenIndex334 := position, tokenIndex
										{
											position335, tokenIndex335 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l336
											}
											position++
											if !_rules[rulesp]() {
												goto l336
											}
											if !_rules[rulee]() {
												goto l336
											}
											{
												add(ruleAction72, position)
											}
											if buffer[position] != rune('}') {
												goto l336
											}
											position++
											goto l335
										l336:
											position, tokenIndex = position335, tokenIndex335
											if buffer[position] != rune('{') {
												goto l338
											}
											position++
											if buffer[position] != rune('{') {
												goto l338
											}
											position++
											if !_rules[rulesp]() {
												goto l338
											}
											if !_rules[rulee]() {
												goto l338
											}
											{
												add(ruleAction73, position)
											}
											if buffer[position] != rune('}') {
												goto l338
											}
											position++
											if buffer[position] != rune('}') {
												goto l338
											}
											position++
											goto l335
										l338:
											position, tokenIndex = position335, tokenIndex335
											{
												position340 := position
												{
													position341 := position
													{
														position344, tokenIndex344 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l345
														}
														goto l344
													l345:
														position, tokenIndex = position344, tokenIndex344
														{
															position346, tokenIndex346 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l346
																	}
																	position++
																case '`':
																	if buffer[position] != rune('`') {
																		goto l346
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l346
																	}
																	position++
																}
															}

															goto l334
														l346:
															position, tokenIndex = position346, tokenIndex346
														}
														if !matchDot() {
															goto l334
														}
													}
												l344:
												l342:
													{
														position343, tokenIndex343 := position, tokenIndex
														{
															position348, tokenIndex348 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l349
															}
															goto l348
														l349:
															position, tokenIndex = position348, tokenIndex348
															{
																position350, tokenIndex350 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l350
																		}
																		position++
																	case '`':
																		if buffer[position] != rune('`') {
																			goto l350
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l350
																		}
																		position++
																	}
																}

																goto l343
															l350:
																position, tokenIndex = position350, tokenIndex350
															}
															if !matchDot() {
																goto l343
															}
														}
													l348:
														goto l342
													l343:
														position, tokenIndex = position343, tokenIndex343
													}
													add(rulePegText, position341)
												}
												{
													add(ruleAction67, position)
												}
												add(rulestrPart, position340)
											}
										}
									l335:
										goto l333
									l334:
										position, tokenIndex = position334, tokenIndex334
									}
									add(rulePegText, position332)
								}
								if buffer[position] != rune('`') {
									goto l259
								}
								position++
								{
									add(ruleAction74, position)
								}
							}
						}

						if !_rules[rulesp]() {
							goto l259
						}
						add(rulefstring, position270)
					}
				}
			l261:
				add(rulevalue, position260)
			}
			return true
		l259:
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 27 number <- <(<[0-9]+> sp Action66)> */
		func() bool {
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				{
					position356 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l354
					}
					position++
				l357:
					{
						position358, tokenIndex358 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l358
						}
						position++
						goto l357
					l358:
						position, tokenIndex = position358, tokenIndex358
					}
					add(rulePegText, position356)
				}
				if !_rules[rulesp]() {
					goto l354
				}
				{
					add(ruleAction66, position)
				}
				add(rulenumber, position355)
			}
			return true
		l354:
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 28 identifier <- <(<(!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				{
					position362 := position
					{
						position363, tokenIndex363 := position, tokenIndex
						{
							switch buffer[position] {
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l363
								}
								position++
							case '\r':
								if buffer[position] != rune('\r') {
									goto l363
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l363
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l363
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l363
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l363
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l363
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l363
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l363
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l363
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l363
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l363
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l363
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l363
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l363
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l363
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l363
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l363
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l363
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l363
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l363
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l363
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l363
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l363
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l363
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l363
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l363
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l363
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l363
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l363
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l363
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l363
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l363
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l363
								}
								position++
							}
						}

						goto l360
					l363:
						position, tokenIndex = position363, tokenIndex363
					}
					if !matchDot() {
						goto l360
					}
				l365:
					{
						position366, tokenIndex366 := position, tokenIndex
						{
							position367, tokenIndex367 := position, tokenIndex
							{
								switch buffer[position] {
								case '\x1e':
									if buffer[position] != rune('\x1e') {
										goto l367
									}
									position++
								case '\r':
									if buffer[position] != rune('\r') {
										goto l367
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l367
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l367
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l367
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l367
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l367
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l367
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l367
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l367
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l367
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l367
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l367
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l367
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l367
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l367
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l367
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l367
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l367
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l367
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l367
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l367
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l367
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l367
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l367
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l367
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l367
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l367
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l367
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l367
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l367
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l367
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l367
									}
									position++
								}
							}

							goto l366
						l367:
							position, tokenIndex = position367, tokenIndex367
						}
						if !matchDot() {
							goto l366
						}
						goto l365
					l366:
						position, tokenIndex = position366, tokenIndex366
					}
					add(rulePegText, position362)
				}
				if !_rules[rulesp]() {
					goto l360
				}
				add(ruleidentifier, position361)
			}
			return true
		l360:
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 29 sub <- <(open e0 close)> */
		nil,
		/* 30 add <- <(('+' / '＋') sp)> */
		func() bool {
			position370, tokenIndex370 := position, tokenIndex
			{
				position371 := position
				{
					position372, tokenIndex372 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l373
					}
					position++
					goto l372
				l373:
					position, tokenIndex = position372, tokenIndex372
					if buffer[position] != rune('＋') {
						goto l370
					}
					position++
				}
			l372:
				if !_rules[rulesp]() {
					goto l370
				}
				add(ruleadd, position371)
			}
			return true
		l370:
			position, tokenIndex = position370, tokenIndex370
			return false
		},
		/* 31 minus <- <(('-' / '－') sp)> */
		func() bool {
			position374, tokenIndex374 := position, tokenIndex
			{
				position375 := position
				{
					position376, tokenIndex376 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l377
					}
					position++
					goto l376
				l377:
					position, tokenIndex = position376, tokenIndex376
					if buffer[position] != rune('－') {
						goto l374
					}
					position++
				}
			l376:
				if !_rules[rulesp]() {
					goto l374
				}
				add(ruleminus, position375)
			}
			return true
		l374:
			position, tokenIndex = position374, tokenIndex374
			return false
		},
		/* 32 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 33 divide <- <(('/' / '／') sp)> */
		nil,
		/* 34 modulus <- <('%' sp)> */
		nil,
		/* 35 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 36 open <- <('(' sp)> */
		nil,
		/* 37 close <- <(')' sp)> */
		nil,
		/* 38 bitwiseOr <- <('|' sp)> */
		nil,
		/* 39 logicOr <- <('|' '|' sp)> */
		nil,
		/* 40 bitwiseAnd <- <(('&' / ('&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 41 logicAnd <- <((('&' '&') / ('&' 'a' 'm' 'p' ';' '&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 42 sp <- <((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' '))*> */
		func() bool {
			{
				position389 := position
			l390:
				{
					position391, tokenIndex391 := position, tokenIndex
					{
						switch buffer[position] {
						case '\r':
							if buffer[position] != rune('\r') {
								goto l391
							}
							position++
						case '\n':
							if buffer[position] != rune('\n') {
								goto l391
							}
							position++
						case '\t':
							if buffer[position] != rune('\t') {
								goto l391
							}
							position++
						default:
							if buffer[position] != rune(' ') {
								goto l391
							}
							position++
						}
					}

					goto l390
				l391:
					position, tokenIndex = position391, tokenIndex391
				}
				add(rulesp, position389)
			}
			return true
		},
		/* 43 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 44 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 45 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 46 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 47 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 48 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 49 strPart <- <(<(escape / (!((&('\\') '\\') | (&('`') '`') | (&('{') '{')) .))+> Action67)> */
		nil,
		/* 50 strPart1 <- <(<(escape / (!((&('\\') '\\') | (&('\x1e') '\x1e') | (&('{') '{')) .))+> Action68)> */
		nil,
		/* 51 strPart2 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('"') '"') | (&('{') '{')) .))+> Action69)> */
		nil,
		/* 52 strPart3 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('\'') '\'') | (&('{') '{')) .))+> Action70)> */
		nil,
		/* 53 fstring <- <(((&('\'') ('\'' Action81 <strPart3*> '\'' Action82)) | (&('"') ('"' Action79 <strPart2*> '"' Action80)) | (&('\x1e') ('\x1e' Action75 <(('{' sp e Action76 '}') / ('{' '%' sp e Action77 ('%' '}')) / strPart1)*> '\x1e' Action78)) | (&('`') ('`' Action71 <(('{' sp e Action72 '}') / ('{' '{' sp e Action73 ('}' '}')) / strPart)*> '`' Action74))) sp)> */
		nil,
		/* 54 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		func() bool {
			position404, tokenIndex404 := position, tokenIndex
			{
				position405 := position
				if buffer[position] != rune('\\') {
					goto l404
				}
				position++
				{
					switch buffer[position] {
					case '\\':
						if buffer[position] != rune('\\') {
							goto l404
						}
						position++
					case '\'':
						if buffer[position] != rune('\'') {
							goto l404
						}
						position++
					case '"':
						if buffer[position] != rune('"') {
							goto l404
						}
						position++
					case 'r':
						if buffer[position] != rune('r') {
							goto l404
						}
						position++
					case 'f':
						if buffer[position] != rune('f') {
							goto l404
						}
						position++
					case 'n':
						if buffer[position] != rune('n') {
							goto l404
						}
						position++
					case 't':
						if buffer[position] != rune('t') {
							goto l404
						}
						position++
					default:
						if buffer[position] != rune('b') {
							goto l404
						}
						position++
					}
				}

				add(ruleescape, position405)
			}
			return true
		l404:
			position, tokenIndex = position404, tokenIndex404
			return false
		},
		/* 56 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 57 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 58 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 59 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 60 Action4 <- <{p.AddOperator(TypePop)}> */
		nil,
		/* 61 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 62 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 63 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 64 Action8 <- <{ p.AddValueStr(""); }> */
		nil,
		/* 65 Action9 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 66 Action10 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 67 Action11 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 68 Action12 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 69 Action13 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 70 Action14 <- <{ p.CounterPush() }> */
		nil,
		/* 71 Action15 <- <{p.CounterAdd(1)}> */
		nil,
		/* 72 Action16 <- <{ p.AddValueStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.PopAndSetOffset() } }> */
		nil,
		/* 73 Action17 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 74 Action18 <- <{ p.AddOperator(TypeBitwiseOr) }> */
		nil,
		/* 75 Action19 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 76 Action20 <- <{ p.AddOperator(TypeBitwiseAnd) }> */
		nil,
		/* 77 Action21 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 78 Action22 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 79 Action23 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 80 Action24 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 81 Action25 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 82 Action26 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 83 Action27 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 84 Action28 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 85 Action29 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 86 Action30 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 87 Action31 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 88 Action32 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 89 Action33 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 90 Action34 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 91 Action35 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 92 Action36 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 93 Action37 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 94 Action38 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 95 Action39 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 96 Action40 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 97 Action41 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 98 Action42 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 99 Action43 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 100 Action44 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 101 Action45 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 102 Action46 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 103 Action47 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 104 Action48 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 105 Action49 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 106 Action50 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 107 Action51 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 108 Action52 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 109 Action53 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 110 Action54 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 111 Action55 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 112 Action56 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 113 Action57 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 114 Action58 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 115 Action59 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 116 Action60 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 117 Action61 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 118 Action62 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 119 Action63 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 120 Action64 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 121 Action65 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 123 Action66 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 124 Action67 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 125 Action68 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 126 Action69 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 127 Action70 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 128 Action71 <- <{ p.CounterPush() }> */
		nil,
		/* 129 Action72 <- <{p.CounterAdd(1)}> */
		nil,
		/* 130 Action73 <- <{p.CounterAdd(1)}> */
		nil,
		/* 131 Action74 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 132 Action75 <- <{ p.CounterPush() }> */
		nil,
		/* 133 Action76 <- <{p.CounterAdd(1)}> */
		nil,
		/* 134 Action77 <- <{p.CounterAdd(1)}> */
		nil,
		/* 135 Action78 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 136 Action79 <- <{ p.CounterPush() }> */
		nil,
		/* 137 Action80 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 138 Action81 <- <{ p.CounterPush() }> */
		nil,
		/* 139 Action82 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
