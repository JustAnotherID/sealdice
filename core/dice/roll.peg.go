package dice

// Code generated by peg -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rules0
	ruleblock
	rulestmtElse
	rulestmtIf
	rulee0
	ruleeSimpleSwitch
	ruleeTernary
	ruleeBitwise
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulebitwiseOr
	rulelogicOr
	rulebitwiseAnd
	rulelogicAnd
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulestrPart
	rulestrPart1
	rulestrPart2
	rulestrPart3
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	rulePegText
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
	ruleAction71
	ruleAction72
	ruleAction73
	ruleAction74
	ruleAction75
	ruleAction76
	ruleAction77
	ruleAction78
	ruleAction79
	ruleAction80
	ruleAction81
	ruleAction82
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"s0",
	"block",
	"stmtElse",
	"stmtIf",
	"e0",
	"eSimpleSwitch",
	"eTernary",
	"eBitwise",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"bitwiseOr",
	"logicOr",
	"bitwiseAnd",
	"logicAnd",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"strPart",
	"strPart1",
	"strPart2",
	"strPart3",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"PegText",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
	"Action71",
	"Action72",
	"Action73",
	"Action74",
	"Action75",
	"Action76",
	"Action77",
	"Action78",
	"Action79",
	"Action80",
	"Action81",
	"Action82",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [140]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypePop)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddValueStr("")
		case ruleAction9:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction10:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction11:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction12:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction13:
			p.PopAndSetOffset()
		case ruleAction14:
			p.CounterPush()
		case ruleAction15:
			p.CounterAdd(1)
		case ruleAction16:
			p.AddValueStr("")
			limit := p.CounterPop() + 1
			for i := int64(0); i < limit; i++ {
				p.PopAndSetOffset()
			}
		case ruleAction17:
			p.AddLeftValueMark()
		case ruleAction18:
			p.AddOperator(TypeBitwiseOr)
		case ruleAction19:
			p.AddLeftValueMark()
		case ruleAction20:
			p.AddOperator(TypeBitwiseAnd)
		case ruleAction21:
			p.AddLeftValueMark()
		case ruleAction22:
			p.AddOperator(TypeCompLT)
		case ruleAction23:
			p.AddLeftValueMark()
		case ruleAction24:
			p.AddOperator(TypeCompLE)
		case ruleAction25:
			p.AddLeftValueMark()
		case ruleAction26:
			p.AddOperator(TypeCompEQ)
		case ruleAction27:
			p.AddLeftValueMark()
		case ruleAction28:
			p.AddOperator(TypeCompNE)
		case ruleAction29:
			p.AddLeftValueMark()
		case ruleAction30:
			p.AddOperator(TypeCompGE)
		case ruleAction31:
			p.AddLeftValueMark()
		case ruleAction32:
			p.AddOperator(TypeCompGT)
		case ruleAction33:
			p.AddLeftValueMark()
		case ruleAction34:
			p.AddOperator(TypeAdd)
		case ruleAction35:
			p.AddLeftValueMark()
		case ruleAction36:
			p.AddOperator(TypeSubtract)
		case ruleAction37:
			p.AddLeftValueMark()
		case ruleAction38:
			p.AddOperator(TypeMultiply)
		case ruleAction39:
			p.AddLeftValueMark()
		case ruleAction40:
			p.AddOperator(TypeDivide)
		case ruleAction41:
			p.AddLeftValueMark()
		case ruleAction42:
			p.AddOperator(TypeModulus)
		case ruleAction43:
			p.AddLeftValueMark()
		case ruleAction44:
			p.AddOperator(TypeExponentiation)
		case ruleAction45:
			p.AddOperator(TypeNegation)
		case ruleAction46:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction47:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction48:
			p.AddOperator(TypeDiceSetK)
		case ruleAction49:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction50:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction51:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction52:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction53:
			p.AddOperator(TypeDice)
		case ruleAction54:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction55:
			p.AddOperator(TypeDice)
		case ruleAction56:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction57:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction58:
			p.AddLeftValueMark()
		case ruleAction59:
			p.AddOperator(TypeDice)
		case ruleAction60:
			p.AddOperator(TypeDicePenalty)
		case ruleAction61:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction62:
			p.AddOperator(TypeDiceBonus)
		case ruleAction63:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction64:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction65:
			p.AddLoadVarname(string(text))
		case ruleAction66:
			p.AddValue(string(text))
		case ruleAction67:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction68:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction69:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction70:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction71:
			p.CounterPush()
		case ruleAction72:
			p.CounterAdd(1)
		case ruleAction73:
			p.CounterAdd(1)
		case ruleAction74:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction75:
			p.CounterPush()
		case ruleAction76:
			p.CounterAdd(1)
		case ruleAction77:
			p.CounterAdd(1)
		case ruleAction78:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction79:
			p.CounterPush()
		case ruleAction80:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction81:
			p.CounterPush()
		case ruleAction82:
			p.AddFormatString(string(text), p.CounterPop())

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulee]() {
					goto l0
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <(eOne (';' sp Action1 eOne?)*)> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				if !_rules[ruleeOne]() {
					goto l3
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if buffer[position] != rune(';') {
						goto l6
					}
					position++
					if !_rules[rulesp]() {
						goto l6
					}
					{
						add(ruleAction1, position)
					}
					{
						position8, tokenIndex8 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l8
						}
						goto l9
					l8:
						position, tokenIndex = position8, tokenIndex8
					}
				l9:
					goto l5
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(rulee, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 eOne <- <(sp (fstring / s0 / e0 / assign_expr))> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[rulesp]() {
					goto l10
				}
				{
					position12, tokenIndex12 := position, tokenIndex
					if !_rules[rulefstring]() {
						goto l13
					}
					goto l12
				l13:
					position, tokenIndex = position12, tokenIndex12
					{
						position15 := position
						{
							position16 := position
							if buffer[position] != rune('i') {
								goto l14
							}
							position++
							if buffer[position] != rune('f') {
								goto l14
							}
							position++
							if !_rules[rulesp]() {
								goto l14
							}
							if !_rules[rulee0]() {
								goto l14
							}
							{
								add(ruleAction5, position)
							}
							if !_rules[ruleblock]() {
								goto l14
							}
							{
								add(ruleAction6, position)
							}
							{
								position19, tokenIndex19 := position, tokenIndex
								{
									position21 := position
									if buffer[position] != rune('e') {
										goto l19
									}
									position++
									if buffer[position] != rune('l') {
										goto l19
									}
									position++
									if buffer[position] != rune('s') {
										goto l19
									}
									position++
									if buffer[position] != rune('e') {
										goto l19
									}
									position++
									if !_rules[rulesp]() {
										goto l19
									}
									if !_rules[ruleblock]() {
										goto l19
									}
									add(rulestmtElse, position21)
								}
								goto l20
							l19:
								position, tokenIndex = position19, tokenIndex19
							}
						l20:
							{
								add(ruleAction7, position)
							}
							{
								add(ruleAction8, position)
							}
							add(rulestmtIf, position16)
						}
						add(rules0, position15)
					}
					goto l12
				l14:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[rulee0]() {
						goto l24
					}
					goto l12
				l24:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleassign_expr]() {
						goto l10
					}
				}
			l12:
				add(ruleeOne, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' sp e0 Action3)> */
		func() bool {
			position25, tokenIndex25 := position, tokenIndex
			{
				position26 := position
				if !_rules[ruleidentifier]() {
					goto l25
				}
				{
					add(ruleAction2, position)
				}
				if buffer[position] != rune('=') {
					goto l25
				}
				position++
				if !_rules[rulesp]() {
					goto l25
				}
				if !_rules[rulee0]() {
					goto l25
				}
				{
					add(ruleAction3, position)
				}
				add(ruleassign_expr, position26)
			}
			return true
		l25:
			position, tokenIndex = position25, tokenIndex25
			return false
		},
		/* 4 s0 <- <stmtIf> */
		nil,
		/* 5 block <- <((('{' sp '}') / ('{' sp e Action4 '}')) sp)> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				{
					position32, tokenIndex32 := position, tokenIndex
					if buffer[position] != rune('{') {
						goto l33
					}
					position++
					if !_rules[rulesp]() {
						goto l33
					}
					if buffer[position] != rune('}') {
						goto l33
					}
					position++
					goto l32
				l33:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('{') {
						goto l30
					}
					position++
					if !_rules[rulesp]() {
						goto l30
					}
					if !_rules[rulee]() {
						goto l30
					}
					{
						add(ruleAction4, position)
					}
					if buffer[position] != rune('}') {
						goto l30
					}
					position++
				}
			l32:
				if !_rules[rulesp]() {
					goto l30
				}
				add(ruleblock, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 6 stmtElse <- <('e' 'l' 's' 'e' sp block)> */
		nil,
		/* 7 stmtIf <- <('i' 'f' sp e0 Action5 block Action6 stmtElse? Action7 Action8)> */
		nil,
		/* 8 e0 <- <eTernary> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				{
					position39 := position
					{
						position40, tokenIndex40 := position, tokenIndex
						if !_rules[ruleeBitwise]() {
							goto l41
						}
						if buffer[position] != rune('?') {
							goto l41
						}
						position++
						if !_rules[rulesp]() {
							goto l41
						}
						{
							add(ruleAction11, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l41
						}
						if buffer[position] != rune(':') {
							goto l41
						}
						position++
						if !_rules[rulesp]() {
							goto l41
						}
						{
							add(ruleAction12, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l41
						}
						{
							add(ruleAction13, position)
						}
						goto l40
					l41:
						position, tokenIndex = position40, tokenIndex40
						if !_rules[ruleeSimpleSwitch]() {
							goto l45
						}
						{
							add(ruleAction14, position)
						}
					l47:
						{
							position48, tokenIndex48 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l48
							}
							position++
							if !_rules[rulesp]() {
								goto l48
							}
							if !_rules[ruleeSimpleSwitch]() {
								goto l48
							}
							{
								add(ruleAction15, position)
							}
							goto l47
						l48:
							position, tokenIndex = position48, tokenIndex48
						}
						{
							add(ruleAction16, position)
						}
						goto l40
					l45:
						position, tokenIndex = position40, tokenIndex40
						if !_rules[ruleeBitwise]() {
							goto l37
						}
					}
				l40:
					add(ruleeTernary, position39)
				}
				add(rulee0, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 9 eSimpleSwitch <- <(eBitwise '?' sp Action9 eBitwise Action10)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if !_rules[ruleeBitwise]() {
					goto l51
				}
				if buffer[position] != rune('?') {
					goto l51
				}
				position++
				if !_rules[rulesp]() {
					goto l51
				}
				{
					add(ruleAction9, position)
				}
				if !_rules[ruleeBitwise]() {
					goto l51
				}
				{
					add(ruleAction10, position)
				}
				add(ruleeSimpleSwitch, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 10 eTernary <- <((eBitwise '?' sp Action11 eBitwise ':' sp Action12 eBitwise Action13) / (eSimpleSwitch Action14 (',' sp eSimpleSwitch Action15)* Action16) / eBitwise)> */
		nil,
		/* 11 eBitwise <- <(eComp (((logicOr / bitwiseOr) Action17 eComp Action18) / ((logicAnd / bitwiseAnd) Action19 eComp Action20))*)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleeComp]() {
					goto l56
				}
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					{
						position60, tokenIndex60 := position, tokenIndex
						{
							position62, tokenIndex62 := position, tokenIndex
							{
								position64 := position
								if buffer[position] != rune('|') {
									goto l63
								}
								position++
								if buffer[position] != rune('|') {
									goto l63
								}
								position++
								if !_rules[rulesp]() {
									goto l63
								}
								add(rulelogicOr, position64)
							}
							goto l62
						l63:
							position, tokenIndex = position62, tokenIndex62
							{
								position65 := position
								if buffer[position] != rune('|') {
									goto l61
								}
								position++
								if !_rules[rulesp]() {
									goto l61
								}
								add(rulebitwiseOr, position65)
							}
						}
					l62:
						{
							add(ruleAction17, position)
						}
						if !_rules[ruleeComp]() {
							goto l61
						}
						{
							add(ruleAction18, position)
						}
						goto l60
					l61:
						position, tokenIndex = position60, tokenIndex60
						{
							position68, tokenIndex68 := position, tokenIndex
							{
								position70 := position
								{
									position71, tokenIndex71 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l72
									}
									position++
									if buffer[position] != rune('&') {
										goto l72
									}
									position++
									goto l71
								l72:
									position, tokenIndex = position71, tokenIndex71
									if buffer[position] != rune('&') {
										goto l69
									}
									position++
									if buffer[position] != rune('a') {
										goto l69
									}
									position++
									if buffer[position] != rune('m') {
										goto l69
									}
									position++
									if buffer[position] != rune('p') {
										goto l69
									}
									position++
									if buffer[position] != rune(';') {
										goto l69
									}
									position++
									if buffer[position] != rune('&') {
										goto l69
									}
									position++
									if buffer[position] != rune('a') {
										goto l69
									}
									position++
									if buffer[position] != rune('m') {
										goto l69
									}
									position++
									if buffer[position] != rune('p') {
										goto l69
									}
									position++
									if buffer[position] != rune(';') {
										goto l69
									}
									position++
								}
							l71:
								if !_rules[rulesp]() {
									goto l69
								}
								add(rulelogicAnd, position70)
							}
							goto l68
						l69:
							position, tokenIndex = position68, tokenIndex68
							{
								position73 := position
								{
									position74, tokenIndex74 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l75
									}
									position++
									goto l74
								l75:
									position, tokenIndex = position74, tokenIndex74
									if buffer[position] != rune('&') {
										goto l59
									}
									position++
									if buffer[position] != rune('a') {
										goto l59
									}
									position++
									if buffer[position] != rune('m') {
										goto l59
									}
									position++
									if buffer[position] != rune('p') {
										goto l59
									}
									position++
									if buffer[position] != rune(';') {
										goto l59
									}
									position++
								}
							l74:
								if !_rules[rulesp]() {
									goto l59
								}
								add(rulebitwiseAnd, position73)
							}
						}
					l68:
						{
							add(ruleAction19, position)
						}
						if !_rules[ruleeComp]() {
							goto l59
						}
						{
							add(ruleAction20, position)
						}
					}
				l60:
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				add(ruleeBitwise, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 12 eComp <- <(e1 ((lt Action21 e1 Action22) / (ge Action29 e1 Action30) / ((&('>') (gt Action31 e1 Action32)) | (&('!') (ne Action27 e1 Action28)) | (&('=') (eq Action25 e1 Action26)) | (&('<') (le Action23 e1 Action24))))*)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if !_rules[rulee1]() {
					goto l78
				}
			l80:
				{
					position81, tokenIndex81 := position, tokenIndex
					{
						position82, tokenIndex82 := position, tokenIndex
						{
							position84 := position
							{
								position85, tokenIndex85 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l86
								}
								position++
								goto l85
							l86:
								position, tokenIndex = position85, tokenIndex85
								if buffer[position] != rune('＜') {
									goto l83
								}
								position++
							}
						l85:
							if !_rules[rulesp]() {
								goto l83
							}
							add(rulelt, position84)
						}
						{
							add(ruleAction21, position)
						}
						if !_rules[rulee1]() {
							goto l83
						}
						{
							add(ruleAction22, position)
						}
						goto l82
					l83:
						position, tokenIndex = position82, tokenIndex82
						{
							position90 := position
							{
								position91, tokenIndex91 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l92
								}
								position++
								if buffer[position] != rune('=') {
									goto l92
								}
								position++
								goto l91
							l92:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('＞') {
									goto l89
								}
								position++
								if buffer[position] != rune('＝') {
									goto l89
								}
								position++
							}
						l91:
							if !_rules[rulesp]() {
								goto l89
							}
							add(rulege, position90)
						}
						{
							add(ruleAction29, position)
						}
						if !_rules[rulee1]() {
							goto l89
						}
						{
							add(ruleAction30, position)
						}
						goto l82
					l89:
						position, tokenIndex = position82, tokenIndex82
						{
							switch buffer[position] {
							case '>':
								{
									position96 := position
									{
										position97, tokenIndex97 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l98
										}
										position++
										goto l97
									l98:
										position, tokenIndex = position97, tokenIndex97
										if buffer[position] != rune('＞') {
											goto l81
										}
										position++
									}
								l97:
									if !_rules[rulesp]() {
										goto l81
									}
									add(rulegt, position96)
								}
								{
									add(ruleAction31, position)
								}
								if !_rules[rulee1]() {
									goto l81
								}
								{
									add(ruleAction32, position)
								}
							case '!':
								{
									position101 := position
									{
										position102, tokenIndex102 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l103
										}
										position++
										if buffer[position] != rune('=') {
											goto l103
										}
										position++
										goto l102
									l103:
										position, tokenIndex = position102, tokenIndex102
										if buffer[position] != rune('！') {
											goto l81
										}
										position++
										if buffer[position] != rune('＝') {
											goto l81
										}
										position++
									}
								l102:
									if !_rules[rulesp]() {
										goto l81
									}
									add(rulene, position101)
								}
								{
									add(ruleAction27, position)
								}
								if !_rules[rulee1]() {
									goto l81
								}
								{
									add(ruleAction28, position)
								}
							case '=':
								{
									position106 := position
									{
										position107, tokenIndex107 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l108
										}
										position++
										if buffer[position] != rune('=') {
											goto l108
										}
										position++
										goto l107
									l108:
										position, tokenIndex = position107, tokenIndex107
										if buffer[position] != rune('＝') {
											goto l81
										}
										position++
										if buffer[position] != rune('＝') {
											goto l81
										}
										position++
									}
								l107:
									if !_rules[rulesp]() {
										goto l81
									}
									add(ruleeq, position106)
								}
								{
									add(ruleAction25, position)
								}
								if !_rules[rulee1]() {
									goto l81
								}
								{
									add(ruleAction26, position)
								}
							default:
								{
									position111 := position
									{
										position112, tokenIndex112 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l113
										}
										position++
										if buffer[position] != rune('=') {
											goto l113
										}
										position++
										goto l112
									l113:
										position, tokenIndex = position112, tokenIndex112
										if buffer[position] != rune('＜') {
											goto l81
										}
										position++
										if buffer[position] != rune('＝') {
											goto l81
										}
										position++
									}
								l112:
									if !_rules[rulesp]() {
										goto l81
									}
									add(rulele, position111)
								}
								{
									add(ruleAction23, position)
								}
								if !_rules[rulee1]() {
									goto l81
								}
								{
									add(ruleAction24, position)
								}
							}
						}

					}
				l82:
					goto l80
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
				add(ruleeComp, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 13 e1 <- <(e2 ((add Action33 e2 Action34) / (minus Action35 e2 Action36))*)> */
		func() bool {
			position116, tokenIndex116 := position, tokenIndex
			{
				position117 := position
				if !_rules[rulee2]() {
					goto l116
				}
			l118:
				{
					position119, tokenIndex119 := position, tokenIndex
					{
						position120, tokenIndex120 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l121
						}
						{
							add(ruleAction33, position)
						}
						if !_rules[rulee2]() {
							goto l121
						}
						{
							add(ruleAction34, position)
						}
						goto l120
					l121:
						position, tokenIndex = position120, tokenIndex120
						if !_rules[ruleminus]() {
							goto l119
						}
						{
							add(ruleAction35, position)
						}
						if !_rules[rulee2]() {
							goto l119
						}
						{
							add(ruleAction36, position)
						}
					}
				l120:
					goto l118
				l119:
					position, tokenIndex = position119, tokenIndex119
				}
				add(rulee1, position117)
			}
			return true
		l116:
			position, tokenIndex = position116, tokenIndex116
			return false
		},
		/* 14 e2 <- <(e3 ((&('%') (modulus Action41 e3 Action42)) | (&('/') (divide Action39 e3 Action40)) | (&('*') (multiply Action37 e3 Action38)))*)> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if !_rules[rulee3]() {
					goto l126
				}
			l128:
				{
					position129, tokenIndex129 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position131 := position
								if buffer[position] != rune('%') {
									goto l129
								}
								position++
								if !_rules[rulesp]() {
									goto l129
								}
								add(rulemodulus, position131)
							}
							{
								add(ruleAction41, position)
							}
							if !_rules[rulee3]() {
								goto l129
							}
							{
								add(ruleAction42, position)
							}
						case '/':
							{
								position134 := position
								{
									position135, tokenIndex135 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l136
									}
									position++
									goto l135
								l136:
									position, tokenIndex = position135, tokenIndex135
									if buffer[position] != rune('／') {
										goto l129
									}
									position++
								}
							l135:
								if !_rules[rulesp]() {
									goto l129
								}
								add(ruledivide, position134)
							}
							{
								add(ruleAction39, position)
							}
							if !_rules[rulee3]() {
								goto l129
							}
							{
								add(ruleAction40, position)
							}
						default:
							{
								position139 := position
								{
									position140, tokenIndex140 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l141
									}
									position++
									goto l140
								l141:
									position, tokenIndex = position140, tokenIndex140
									if buffer[position] != rune('＊') {
										goto l129
									}
									position++
								}
							l140:
								if !_rules[rulesp]() {
									goto l129
								}
								add(rulemultiply, position139)
							}
							{
								add(ruleAction37, position)
							}
							if !_rules[rulee3]() {
								goto l129
							}
							{
								add(ruleAction38, position)
							}
						}
					}

					goto l128
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
				add(rulee2, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 15 e3 <- <(e4 (exponentiation Action43 e4 Action44)*)> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if !_rules[rulee4]() {
					goto l144
				}
			l146:
				{
					position147, tokenIndex147 := position, tokenIndex
					{
						position148 := position
						{
							position149, tokenIndex149 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l150
							}
							position++
							if !_rules[rulesp]() {
								goto l150
							}
							goto l149
						l150:
							position, tokenIndex = position149, tokenIndex149
							if buffer[position] != rune('*') {
								goto l147
							}
							position++
							if buffer[position] != rune('*') {
								goto l147
							}
							position++
							if !_rules[rulesp]() {
								goto l147
							}
						}
					l149:
						add(ruleexponentiation, position148)
					}
					{
						add(ruleAction43, position)
					}
					if !_rules[rulee4]() {
						goto l147
					}
					{
						add(ruleAction44, position)
					}
					goto l146
				l147:
					position, tokenIndex = position147, tokenIndex147
				}
				add(rulee3, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 16 e4 <- <((minus e5 Action45) / e5)> */
		func() bool {
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				{
					position155, tokenIndex155 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l156
					}
					if !_rules[rulee5]() {
						goto l156
					}
					{
						add(ruleAction45, position)
					}
					goto l155
				l156:
					position, tokenIndex = position155, tokenIndex155
					if !_rules[rulee5]() {
						goto l153
					}
				}
			l155:
				add(rulee4, position154)
			}
			return true
		l153:
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 17 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				{
					position160, tokenIndex160 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l161
					}
					if !_rules[ruleeDice]() {
						goto l161
					}
					goto l160
				l161:
					position, tokenIndex = position160, tokenIndex160
					if !_rules[ruleeDice]() {
						goto l158
					}
				}
			l160:
				add(rulee5, position159)
			}
			return true
		l158:
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 18 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action46 sp) / ((('劣' '势') / ('k' 'l')) Action47 sp))> */
		func() bool {
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164, tokenIndex164 := position, tokenIndex
					{
						position166, tokenIndex166 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l167
						}
						position++
						if buffer[position] != rune('势') {
							goto l167
						}
						position++
						goto l166
					l167:
						position, tokenIndex = position166, tokenIndex166
						if buffer[position] != rune('k') {
							goto l165
						}
						position++
						if buffer[position] != rune('h') {
							goto l165
						}
						position++
					}
				l166:
					{
						add(ruleAction46, position)
					}
					if !_rules[rulesp]() {
						goto l165
					}
					goto l164
				l165:
					position, tokenIndex = position164, tokenIndex164
					{
						position169, tokenIndex169 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l170
						}
						position++
						if buffer[position] != rune('势') {
							goto l170
						}
						position++
						goto l169
					l170:
						position, tokenIndex = position169, tokenIndex169
						if buffer[position] != rune('k') {
							goto l162
						}
						position++
						if buffer[position] != rune('l') {
							goto l162
						}
						position++
					}
				l169:
					{
						add(ruleAction47, position)
					}
					if !_rules[rulesp]() {
						goto l162
					}
				}
			l164:
				add(ruledndDiceSuffix, position163)
			}
			return true
		l162:
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 19 kqDiceOp <- <(('k' eDice2 Action48)? ('q' eDice2 Action49)? ('d' 'l' eDice2 Action50)? ('d' 'h' eDice2 Action51)?)> */
		func() bool {
			{
				position173 := position
				{
					position174, tokenIndex174 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l174
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l174
					}
					{
						add(ruleAction48, position)
					}
					goto l175
				l174:
					position, tokenIndex = position174, tokenIndex174
				}
			l175:
				{
					position177, tokenIndex177 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l177
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l177
					}
					{
						add(ruleAction49, position)
					}
					goto l178
				l177:
					position, tokenIndex = position177, tokenIndex177
				}
			l178:
				{
					position180, tokenIndex180 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l180
					}
					position++
					if buffer[position] != rune('l') {
						goto l180
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l180
					}
					{
						add(ruleAction50, position)
					}
					goto l181
				l180:
					position, tokenIndex = position180, tokenIndex180
				}
			l181:
				{
					position183, tokenIndex183 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l183
					}
					position++
					if buffer[position] != rune('h') {
						goto l183
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l183
					}
					{
						add(ruleAction51, position)
					}
					goto l184
				l183:
					position, tokenIndex = position183, tokenIndex183
				}
			l184:
				add(rulekqDiceOp, position173)
			}
			return true
		},
		/* 20 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188, tokenIndex188 := position, tokenIndex
					{
						position189, tokenIndex189 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l190
						}
						position++
						goto l189
					l190:
						position, tokenIndex = position189, tokenIndex189
						if buffer[position] != rune('D') {
							goto l186
						}
						position++
					}
				l189:
					{
						position191, tokenIndex191 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l192
						}
						goto l191
					l192:
						position, tokenIndex = position191, tokenIndex191
						if buffer[position] != rune('(') {
							goto l186
						}
						position++
					}
				l191:
					position, tokenIndex = position188, tokenIndex188
				}
				add(rule_dnumber, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 21 eDice <- <((_dnumber ('d' / 'D') Action52 eDice2 dndDiceSuffix Action53) / (_dnumber ('d' / 'D') Action54 eDice2 kqDiceOp Action55) / (('d' / 'D') dndDiceSuffix Action56) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action57) / (eDice2 (('d' / 'D') Action58 &(number / '(') eDice2 kqDiceOp Action59)*))> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				{
					position195, tokenIndex195 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l196
					}
					{
						position197, tokenIndex197 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l198
						}
						position++
						goto l197
					l198:
						position, tokenIndex = position197, tokenIndex197
						if buffer[position] != rune('D') {
							goto l196
						}
						position++
					}
				l197:
					{
						add(ruleAction52, position)
					}
					if !_rules[ruleeDice2]() {
						goto l196
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l196
					}
					{
						add(ruleAction53, position)
					}
					goto l195
				l196:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[rule_dnumber]() {
						goto l201
					}
					{
						position202, tokenIndex202 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l203
						}
						position++
						goto l202
					l203:
						position, tokenIndex = position202, tokenIndex202
						if buffer[position] != rune('D') {
							goto l201
						}
						position++
					}
				l202:
					{
						add(ruleAction54, position)
					}
					if !_rules[ruleeDice2]() {
						goto l201
					}
					if !_rules[rulekqDiceOp]() {
						goto l201
					}
					{
						add(ruleAction55, position)
					}
					goto l195
				l201:
					position, tokenIndex = position195, tokenIndex195
					{
						position207, tokenIndex207 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l208
						}
						position++
						goto l207
					l208:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('D') {
							goto l206
						}
						position++
					}
				l207:
					if !_rules[ruledndDiceSuffix]() {
						goto l206
					}
					{
						add(ruleAction56, position)
					}
					goto l195
				l206:
					position, tokenIndex = position195, tokenIndex195
					{
						position211, tokenIndex211 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l212
						}
						position++
						goto l211
					l212:
						position, tokenIndex = position211, tokenIndex211
						if buffer[position] != rune('D') {
							goto l210
						}
						position++
					}
				l211:
					{
						position213, tokenIndex213 := position, tokenIndex
						{
							position214, tokenIndex214 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l214
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l214
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l214
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l214
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l214
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l214
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l214
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l214
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l214
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l214
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l214
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l214
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l214
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l214
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l214
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l214
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l214
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l214
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l214
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l214
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l214
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l214
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l214
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l214
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l214
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l214
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l214
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l214
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l214
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l214
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l214
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l214
									}
									position++
								}
							}

							goto l213
						l214:
							position, tokenIndex = position214, tokenIndex214
						}
						if !matchDot() {
							goto l213
						}
						goto l210
					l213:
						position, tokenIndex = position213, tokenIndex213
					}
					if !_rules[rulesp]() {
						goto l210
					}
					{
						add(ruleAction57, position)
					}
					goto l195
				l210:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[ruleeDice2]() {
						goto l193
					}
				l217:
					{
						position218, tokenIndex218 := position, tokenIndex
						{
							position219, tokenIndex219 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l220
							}
							position++
							goto l219
						l220:
							position, tokenIndex = position219, tokenIndex219
							if buffer[position] != rune('D') {
								goto l218
							}
							position++
						}
					l219:
						{
							add(ruleAction58, position)
						}
						{
							position222, tokenIndex222 := position, tokenIndex
							{
								position223, tokenIndex223 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l224
								}
								goto l223
							l224:
								position, tokenIndex = position223, tokenIndex223
								if buffer[position] != rune('(') {
									goto l218
								}
								position++
							}
						l223:
							position, tokenIndex = position222, tokenIndex222
						}
						if !_rules[ruleeDice2]() {
							goto l218
						}
						if !_rules[rulekqDiceOp]() {
							goto l218
						}
						{
							add(ruleAction59, position)
						}
						goto l217
					l218:
						position, tokenIndex = position218, tokenIndex218
					}
				}
			l195:
				add(ruleeDice, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 22 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position226, tokenIndex226 := position, tokenIndex
			{
				position227 := position
				{
					position228, tokenIndex228 := position, tokenIndex
					{
						position229, tokenIndex229 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l230
						}
						goto l229
					l230:
						position, tokenIndex = position229, tokenIndex229
						if buffer[position] != rune('(') {
							goto l226
						}
						position++
					}
				l229:
					position, tokenIndex = position228, tokenIndex228
				}
				add(rulelaNumberOrLeftParen, position227)
			}
			return true
		l226:
			position, tokenIndex = position226, tokenIndex226
			return false
		},
		/* 23 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action60) / (('p' / 'P') Action61) / eDice3)> */
		func() bool {
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				{
					position233, tokenIndex233 := position, tokenIndex
					{
						position235, tokenIndex235 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l236
						}
						position++
						goto l235
					l236:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('P') {
							goto l234
						}
						position++
					}
				l235:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l234
					}
					if !_rules[ruleeDice3]() {
						goto l234
					}
					{
						add(ruleAction60, position)
					}
					goto l233
				l234:
					position, tokenIndex = position233, tokenIndex233
					{
						position239, tokenIndex239 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l240
						}
						position++
						goto l239
					l240:
						position, tokenIndex = position239, tokenIndex239
						if buffer[position] != rune('P') {
							goto l238
						}
						position++
					}
				l239:
					{
						add(ruleAction61, position)
					}
					goto l233
				l238:
					position, tokenIndex = position233, tokenIndex233
					if !_rules[ruleeDice3]() {
						goto l231
					}
				}
			l233:
				add(ruleeDice2, position232)
			}
			return true
		l231:
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 24 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action62) / (('b' / 'B') Action63) / eDice4)> */
		func() bool {
			position242, tokenIndex242 := position, tokenIndex
			{
				position243 := position
				{
					position244, tokenIndex244 := position, tokenIndex
					{
						position246, tokenIndex246 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l247
						}
						position++
						goto l246
					l247:
						position, tokenIndex = position246, tokenIndex246
						if buffer[position] != rune('B') {
							goto l245
						}
						position++
					}
				l246:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l245
					}
					if !_rules[rulevalue]() {
						goto l245
					}
					{
						add(ruleAction62, position)
					}
					goto l244
				l245:
					position, tokenIndex = position244, tokenIndex244
					{
						position250, tokenIndex250 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l251
						}
						position++
						goto l250
					l251:
						position, tokenIndex = position250, tokenIndex250
						if buffer[position] != rune('B') {
							goto l249
						}
						position++
					}
				l250:
					{
						add(ruleAction63, position)
					}
					goto l244
				l249:
					position, tokenIndex = position244, tokenIndex244
					{
						position253 := position
						{
							position254, tokenIndex254 := position, tokenIndex
							{
								position256, tokenIndex256 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l257
								}
								position++
								goto l256
							l257:
								position, tokenIndex = position256, tokenIndex256
								if buffer[position] != rune('F') {
									goto l255
								}
								position++
							}
						l256:
							if !_rules[rulesp]() {
								goto l255
							}
							{
								add(ruleAction64, position)
							}
							goto l254
						l255:
							position, tokenIndex = position254, tokenIndex254
							if !_rules[rulevalue]() {
								goto l242
							}
						}
					l254:
						add(ruleeDice4, position253)
					}
				}
			l244:
				add(ruleeDice3, position243)
			}
			return true
		l242:
			position, tokenIndex = position242, tokenIndex242
			return false
		},
		/* 25 eDice4 <- <((('f' / 'F') sp Action64) / value)> */
		nil,
		/* 26 value <- <(number / assign_expr / (identifier Action65) / sub / fstring)> */
		func() bool {
			position260, tokenIndex260 := position, tokenIndex
			{
				position261 := position
				{
					position262, tokenIndex262 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l263
					}
					goto l262
				l263:
					position, tokenIndex = position262, tokenIndex262
					if !_rules[ruleassign_expr]() {
						goto l264
					}
					goto l262
				l264:
					position, tokenIndex = position262, tokenIndex262
					if !_rules[ruleidentifier]() {
						goto l265
					}
					{
						add(ruleAction65, position)
					}
					goto l262
				l265:
					position, tokenIndex = position262, tokenIndex262
					{
						position268 := position
						{
							position269 := position
							if buffer[position] != rune('(') {
								goto l267
							}
							position++
							if !_rules[rulesp]() {
								goto l267
							}
							add(ruleopen, position269)
						}
						if !_rules[rulee0]() {
							goto l267
						}
						{
							position270 := position
							if buffer[position] != rune(')') {
								goto l267
							}
							position++
							if !_rules[rulesp]() {
								goto l267
							}
							add(ruleclose, position270)
						}
						add(rulesub, position268)
					}
					goto l262
				l267:
					position, tokenIndex = position262, tokenIndex262
					if !_rules[rulefstring]() {
						goto l260
					}
				}
			l262:
				add(rulevalue, position261)
			}
			return true
		l260:
			position, tokenIndex = position260, tokenIndex260
			return false
		},
		/* 27 number <- <(<[0-9]+> sp Action66)> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				{
					position273 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l271
					}
					position++
				l274:
					{
						position275, tokenIndex275 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l275
						}
						position++
						goto l274
					l275:
						position, tokenIndex = position275, tokenIndex275
					}
					add(rulePegText, position273)
				}
				if !_rules[rulesp]() {
					goto l271
				}
				{
					add(ruleAction66, position)
				}
				add(rulenumber, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 28 identifier <- <(<(!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				{
					position279 := position
					{
						position280, tokenIndex280 := position, tokenIndex
						{
							switch buffer[position] {
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l280
								}
								position++
							case '\r':
								if buffer[position] != rune('\r') {
									goto l280
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l280
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l280
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l280
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l280
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l280
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l280
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l280
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l280
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l280
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l280
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l280
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l280
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l280
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l280
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l280
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l280
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l280
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l280
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l280
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l280
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l280
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l280
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l280
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l280
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l280
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l280
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l280
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l280
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l280
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l280
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l280
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l280
								}
								position++
							}
						}

						goto l277
					l280:
						position, tokenIndex = position280, tokenIndex280
					}
					if !matchDot() {
						goto l277
					}
				l282:
					{
						position283, tokenIndex283 := position, tokenIndex
						{
							position284, tokenIndex284 := position, tokenIndex
							{
								switch buffer[position] {
								case '\x1e':
									if buffer[position] != rune('\x1e') {
										goto l284
									}
									position++
								case '\r':
									if buffer[position] != rune('\r') {
										goto l284
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l284
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l284
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l284
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l284
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l284
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l284
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l284
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l284
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l284
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l284
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l284
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l284
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l284
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l284
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l284
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l284
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l284
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l284
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l284
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l284
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l284
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l284
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l284
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l284
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l284
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l284
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l284
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l284
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l284
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l284
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l284
									}
									position++
								}
							}

							goto l283
						l284:
							position, tokenIndex = position284, tokenIndex284
						}
						if !matchDot() {
							goto l283
						}
						goto l282
					l283:
						position, tokenIndex = position283, tokenIndex283
					}
					add(rulePegText, position279)
				}
				if !_rules[rulesp]() {
					goto l277
				}
				add(ruleidentifier, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 29 sub <- <(open e0 close)> */
		nil,
		/* 30 add <- <(('+' / '＋') sp)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				{
					position289, tokenIndex289 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l290
					}
					position++
					goto l289
				l290:
					position, tokenIndex = position289, tokenIndex289
					if buffer[position] != rune('＋') {
						goto l287
					}
					position++
				}
			l289:
				if !_rules[rulesp]() {
					goto l287
				}
				add(ruleadd, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 31 minus <- <(('-' / '－') sp)> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				{
					position293, tokenIndex293 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l294
					}
					position++
					goto l293
				l294:
					position, tokenIndex = position293, tokenIndex293
					if buffer[position] != rune('－') {
						goto l291
					}
					position++
				}
			l293:
				if !_rules[rulesp]() {
					goto l291
				}
				add(ruleminus, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 32 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 33 divide <- <(('/' / '／') sp)> */
		nil,
		/* 34 modulus <- <('%' sp)> */
		nil,
		/* 35 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 36 open <- <('(' sp)> */
		nil,
		/* 37 close <- <(')' sp)> */
		nil,
		/* 38 bitwiseOr <- <('|' sp)> */
		nil,
		/* 39 logicOr <- <('|' '|' sp)> */
		nil,
		/* 40 bitwiseAnd <- <(('&' / ('&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 41 logicAnd <- <((('&' '&') / ('&' 'a' 'm' 'p' ';' '&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 42 sp <- <((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' '))*> */
		func() bool {
			{
				position306 := position
			l307:
				{
					position308, tokenIndex308 := position, tokenIndex
					{
						switch buffer[position] {
						case '\r':
							if buffer[position] != rune('\r') {
								goto l308
							}
							position++
						case '\n':
							if buffer[position] != rune('\n') {
								goto l308
							}
							position++
						case '\t':
							if buffer[position] != rune('\t') {
								goto l308
							}
							position++
						default:
							if buffer[position] != rune(' ') {
								goto l308
							}
							position++
						}
					}

					goto l307
				l308:
					position, tokenIndex = position308, tokenIndex308
				}
				add(rulesp, position306)
			}
			return true
		},
		/* 43 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 44 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 45 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 46 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 47 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 48 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 49 strPart <- <(<(escape / (!((&('\\') '\\') | (&('`') '`') | (&('{') '{')) .))+> Action67)> */
		nil,
		/* 50 strPart1 <- <(<(escape / (!((&('\\') '\\') | (&('\x1e') '\x1e') | (&('{') '{')) .))+> Action68)> */
		nil,
		/* 51 strPart2 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('"') '"') | (&('{') '{')) .))+> Action69)> */
		nil,
		/* 52 strPart3 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('\'') '\'') | (&('{') '{')) .))+> Action70)> */
		nil,
		/* 53 fstring <- <(((&('\'') ('\'' Action81 <strPart3*> '\'' Action82)) | (&('"') ('"' Action79 <strPart2*> '"' Action80)) | (&('\x1e') ('\x1e' Action75 <(('{' sp e Action76 '}') / ('{' '%' sp e Action77 ('%' '}')) / strPart1)*> '\x1e' Action78)) | (&('`') ('`' Action71 <(('{' sp e Action72 '}') / ('{' '{' sp e Action73 ('}' '}')) / strPart)*> '`' Action74))) sp)> */
		func() bool {
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				{
					switch buffer[position] {
					case '\'':
						if buffer[position] != rune('\'') {
							goto l320
						}
						position++
						{
							add(ruleAction81, position)
						}
						{
							position324 := position
						l325:
							{
								position326, tokenIndex326 := position, tokenIndex
								{
									position327 := position
									{
										position328 := position
										{
											position331, tokenIndex331 := position, tokenIndex
											if !_rules[ruleescape]() {
												goto l332
											}
											goto l331
										l332:
											position, tokenIndex = position331, tokenIndex331
											{
												position333, tokenIndex333 := position, tokenIndex
												{
													switch buffer[position] {
													case '\r':
														if buffer[position] != rune('\r') {
															goto l333
														}
														position++
													case '\n':
														if buffer[position] != rune('\n') {
															goto l333
														}
														position++
													case '\\':
														if buffer[position] != rune('\\') {
															goto l333
														}
														position++
													case '\'':
														if buffer[position] != rune('\'') {
															goto l333
														}
														position++
													default:
														if buffer[position] != rune('{') {
															goto l333
														}
														position++
													}
												}

												goto l326
											l333:
												position, tokenIndex = position333, tokenIndex333
											}
											if !matchDot() {
												goto l326
											}
										}
									l331:
									l329:
										{
											position330, tokenIndex330 := position, tokenIndex
											{
												position335, tokenIndex335 := position, tokenIndex
												if !_rules[ruleescape]() {
													goto l336
												}
												goto l335
											l336:
												position, tokenIndex = position335, tokenIndex335
												{
													position337, tokenIndex337 := position, tokenIndex
													{
														switch buffer[position] {
														case '\r':
															if buffer[position] != rune('\r') {
																goto l337
															}
															position++
														case '\n':
															if buffer[position] != rune('\n') {
																goto l337
															}
															position++
														case '\\':
															if buffer[position] != rune('\\') {
																goto l337
															}
															position++
														case '\'':
															if buffer[position] != rune('\'') {
																goto l337
															}
															position++
														default:
															if buffer[position] != rune('{') {
																goto l337
															}
															position++
														}
													}

													goto l330
												l337:
													position, tokenIndex = position337, tokenIndex337
												}
												if !matchDot() {
													goto l330
												}
											}
										l335:
											goto l329
										l330:
											position, tokenIndex = position330, tokenIndex330
										}
										add(rulePegText, position328)
									}
									{
										add(ruleAction70, position)
									}
									add(rulestrPart3, position327)
								}
								goto l325
							l326:
								position, tokenIndex = position326, tokenIndex326
							}
							add(rulePegText, position324)
						}
						if buffer[position] != rune('\'') {
							goto l320
						}
						position++
						{
							add(ruleAction82, position)
						}
					case '"':
						if buffer[position] != rune('"') {
							goto l320
						}
						position++
						{
							add(ruleAction79, position)
						}
						{
							position342 := position
						l343:
							{
								position344, tokenIndex344 := position, tokenIndex
								{
									position345 := position
									{
										position346 := position
										{
											position349, tokenIndex349 := position, tokenIndex
											if !_rules[ruleescape]() {
												goto l350
											}
											goto l349
										l350:
											position, tokenIndex = position349, tokenIndex349
											{
												position351, tokenIndex351 := position, tokenIndex
												{
													switch buffer[position] {
													case '\r':
														if buffer[position] != rune('\r') {
															goto l351
														}
														position++
													case '\n':
														if buffer[position] != rune('\n') {
															goto l351
														}
														position++
													case '\\':
														if buffer[position] != rune('\\') {
															goto l351
														}
														position++
													case '"':
														if buffer[position] != rune('"') {
															goto l351
														}
														position++
													default:
														if buffer[position] != rune('{') {
															goto l351
														}
														position++
													}
												}

												goto l344
											l351:
												position, tokenIndex = position351, tokenIndex351
											}
											if !matchDot() {
												goto l344
											}
										}
									l349:
									l347:
										{
											position348, tokenIndex348 := position, tokenIndex
											{
												position353, tokenIndex353 := position, tokenIndex
												if !_rules[ruleescape]() {
													goto l354
												}
												goto l353
											l354:
												position, tokenIndex = position353, tokenIndex353
												{
													position355, tokenIndex355 := position, tokenIndex
													{
														switch buffer[position] {
														case '\r':
															if buffer[position] != rune('\r') {
																goto l355
															}
															position++
														case '\n':
															if buffer[position] != rune('\n') {
																goto l355
															}
															position++
														case '\\':
															if buffer[position] != rune('\\') {
																goto l355
															}
															position++
														case '"':
															if buffer[position] != rune('"') {
																goto l355
															}
															position++
														default:
															if buffer[position] != rune('{') {
																goto l355
															}
															position++
														}
													}

													goto l348
												l355:
													position, tokenIndex = position355, tokenIndex355
												}
												if !matchDot() {
													goto l348
												}
											}
										l353:
											goto l347
										l348:
											position, tokenIndex = position348, tokenIndex348
										}
										add(rulePegText, position346)
									}
									{
										add(ruleAction69, position)
									}
									add(rulestrPart2, position345)
								}
								goto l343
							l344:
								position, tokenIndex = position344, tokenIndex344
							}
							add(rulePegText, position342)
						}
						if buffer[position] != rune('"') {
							goto l320
						}
						position++
						{
							add(ruleAction80, position)
						}
					case '\x1e':
						if buffer[position] != rune('\x1e') {
							goto l320
						}
						position++
						{
							add(ruleAction75, position)
						}
						{
							position360 := position
						l361:
							{
								position362, tokenIndex362 := position, tokenIndex
								{
									position363, tokenIndex363 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l364
									}
									position++
									if !_rules[rulesp]() {
										goto l364
									}
									if !_rules[rulee]() {
										goto l364
									}
									{
										add(ruleAction76, position)
									}
									if buffer[position] != rune('}') {
										goto l364
									}
									position++
									goto l363
								l364:
									position, tokenIndex = position363, tokenIndex363
									if buffer[position] != rune('{') {
										goto l366
									}
									position++
									if buffer[position] != rune('%') {
										goto l366
									}
									position++
									if !_rules[rulesp]() {
										goto l366
									}
									if !_rules[rulee]() {
										goto l366
									}
									{
										add(ruleAction77, position)
									}
									if buffer[position] != rune('%') {
										goto l366
									}
									position++
									if buffer[position] != rune('}') {
										goto l366
									}
									position++
									goto l363
								l366:
									position, tokenIndex = position363, tokenIndex363
									{
										position368 := position
										{
											position369 := position
											{
												position372, tokenIndex372 := position, tokenIndex
												if !_rules[ruleescape]() {
													goto l373
												}
												goto l372
											l373:
												position, tokenIndex = position372, tokenIndex372
												{
													position374, tokenIndex374 := position, tokenIndex
													{
														switch buffer[position] {
														case '\\':
															if buffer[position] != rune('\\') {
																goto l374
															}
															position++
														case '\x1e':
															if buffer[position] != rune('\x1e') {
																goto l374
															}
															position++
														default:
															if buffer[position] != rune('{') {
																goto l374
															}
															position++
														}
													}

													goto l362
												l374:
													position, tokenIndex = position374, tokenIndex374
												}
												if !matchDot() {
													goto l362
												}
											}
										l372:
										l370:
											{
												position371, tokenIndex371 := position, tokenIndex
												{
													position376, tokenIndex376 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l377
													}
													goto l376
												l377:
													position, tokenIndex = position376, tokenIndex376
													{
														position378, tokenIndex378 := position, tokenIndex
														{
															switch buffer[position] {
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l378
																}
																position++
															case '\x1e':
																if buffer[position] != rune('\x1e') {
																	goto l378
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l378
																}
																position++
															}
														}

														goto l371
													l378:
														position, tokenIndex = position378, tokenIndex378
													}
													if !matchDot() {
														goto l371
													}
												}
											l376:
												goto l370
											l371:
												position, tokenIndex = position371, tokenIndex371
											}
											add(rulePegText, position369)
										}
										{
											add(ruleAction68, position)
										}
										add(rulestrPart1, position368)
									}
								}
							l363:
								goto l361
							l362:
								position, tokenIndex = position362, tokenIndex362
							}
							add(rulePegText, position360)
						}
						if buffer[position] != rune('\x1e') {
							goto l320
						}
						position++
						{
							add(ruleAction78, position)
						}
					default:
						if buffer[position] != rune('`') {
							goto l320
						}
						position++
						{
							add(ruleAction71, position)
						}
						{
							position383 := position
						l384:
							{
								position385, tokenIndex385 := position, tokenIndex
								{
									position386, tokenIndex386 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l387
									}
									position++
									if !_rules[rulesp]() {
										goto l387
									}
									if !_rules[rulee]() {
										goto l387
									}
									{
										add(ruleAction72, position)
									}
									if buffer[position] != rune('}') {
										goto l387
									}
									position++
									goto l386
								l387:
									position, tokenIndex = position386, tokenIndex386
									if buffer[position] != rune('{') {
										goto l389
									}
									position++
									if buffer[position] != rune('{') {
										goto l389
									}
									position++
									if !_rules[rulesp]() {
										goto l389
									}
									if !_rules[rulee]() {
										goto l389
									}
									{
										add(ruleAction73, position)
									}
									if buffer[position] != rune('}') {
										goto l389
									}
									position++
									if buffer[position] != rune('}') {
										goto l389
									}
									position++
									goto l386
								l389:
									position, tokenIndex = position386, tokenIndex386
									{
										position391 := position
										{
											position392 := position
											{
												position395, tokenIndex395 := position, tokenIndex
												if !_rules[ruleescape]() {
													goto l396
												}
												goto l395
											l396:
												position, tokenIndex = position395, tokenIndex395
												{
													position397, tokenIndex397 := position, tokenIndex
													{
														switch buffer[position] {
														case '\\':
															if buffer[position] != rune('\\') {
																goto l397
															}
															position++
														case '`':
															if buffer[position] != rune('`') {
																goto l397
															}
															position++
														default:
															if buffer[position] != rune('{') {
																goto l397
															}
															position++
														}
													}

													goto l385
												l397:
													position, tokenIndex = position397, tokenIndex397
												}
												if !matchDot() {
													goto l385
												}
											}
										l395:
										l393:
											{
												position394, tokenIndex394 := position, tokenIndex
												{
													position399, tokenIndex399 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l400
													}
													goto l399
												l400:
													position, tokenIndex = position399, tokenIndex399
													{
														position401, tokenIndex401 := position, tokenIndex
														{
															switch buffer[position] {
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l401
																}
																position++
															case '`':
																if buffer[position] != rune('`') {
																	goto l401
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l401
																}
																position++
															}
														}

														goto l394
													l401:
														position, tokenIndex = position401, tokenIndex401
													}
													if !matchDot() {
														goto l394
													}
												}
											l399:
												goto l393
											l394:
												position, tokenIndex = position394, tokenIndex394
											}
											add(rulePegText, position392)
										}
										{
											add(ruleAction67, position)
										}
										add(rulestrPart, position391)
									}
								}
							l386:
								goto l384
							l385:
								position, tokenIndex = position385, tokenIndex385
							}
							add(rulePegText, position383)
						}
						if buffer[position] != rune('`') {
							goto l320
						}
						position++
						{
							add(ruleAction74, position)
						}
					}
				}

				if !_rules[rulesp]() {
					goto l320
				}
				add(rulefstring, position321)
			}
			return true
		l320:
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 54 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		func() bool {
			position405, tokenIndex405 := position, tokenIndex
			{
				position406 := position
				if buffer[position] != rune('\\') {
					goto l405
				}
				position++
				{
					switch buffer[position] {
					case '\\':
						if buffer[position] != rune('\\') {
							goto l405
						}
						position++
					case '\'':
						if buffer[position] != rune('\'') {
							goto l405
						}
						position++
					case '"':
						if buffer[position] != rune('"') {
							goto l405
						}
						position++
					case 'r':
						if buffer[position] != rune('r') {
							goto l405
						}
						position++
					case 'f':
						if buffer[position] != rune('f') {
							goto l405
						}
						position++
					case 'n':
						if buffer[position] != rune('n') {
							goto l405
						}
						position++
					case 't':
						if buffer[position] != rune('t') {
							goto l405
						}
						position++
					default:
						if buffer[position] != rune('b') {
							goto l405
						}
						position++
					}
				}

				add(ruleescape, position406)
			}
			return true
		l405:
			position, tokenIndex = position405, tokenIndex405
			return false
		},
		/* 56 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 57 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 58 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 59 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 60 Action4 <- <{p.AddOperator(TypePop)}> */
		nil,
		/* 61 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 62 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 63 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 64 Action8 <- <{ p.AddValueStr(""); }> */
		nil,
		/* 65 Action9 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 66 Action10 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 67 Action11 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 68 Action12 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 69 Action13 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 70 Action14 <- <{ p.CounterPush() }> */
		nil,
		/* 71 Action15 <- <{p.CounterAdd(1)}> */
		nil,
		/* 72 Action16 <- <{ p.AddValueStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.PopAndSetOffset() } }> */
		nil,
		/* 73 Action17 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 74 Action18 <- <{ p.AddOperator(TypeBitwiseOr) }> */
		nil,
		/* 75 Action19 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 76 Action20 <- <{ p.AddOperator(TypeBitwiseAnd) }> */
		nil,
		/* 77 Action21 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 78 Action22 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 79 Action23 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 80 Action24 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 81 Action25 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 82 Action26 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 83 Action27 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 84 Action28 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 85 Action29 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 86 Action30 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 87 Action31 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 88 Action32 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 89 Action33 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 90 Action34 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 91 Action35 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 92 Action36 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 93 Action37 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 94 Action38 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 95 Action39 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 96 Action40 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 97 Action41 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 98 Action42 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 99 Action43 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 100 Action44 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 101 Action45 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 102 Action46 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 103 Action47 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 104 Action48 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 105 Action49 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 106 Action50 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 107 Action51 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 108 Action52 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 109 Action53 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 110 Action54 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 111 Action55 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 112 Action56 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 113 Action57 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 114 Action58 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 115 Action59 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 116 Action60 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 117 Action61 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 118 Action62 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 119 Action63 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 120 Action64 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 121 Action65 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 123 Action66 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 124 Action67 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 125 Action68 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 126 Action69 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 127 Action70 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 128 Action71 <- <{ p.CounterPush() }> */
		nil,
		/* 129 Action72 <- <{p.CounterAdd(1)}> */
		nil,
		/* 130 Action73 <- <{p.CounterAdd(1)}> */
		nil,
		/* 131 Action74 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 132 Action75 <- <{ p.CounterPush() }> */
		nil,
		/* 133 Action76 <- <{p.CounterAdd(1)}> */
		nil,
		/* 134 Action77 <- <{p.CounterAdd(1)}> */
		nil,
		/* 135 Action78 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 136 Action79 <- <{ p.CounterPush() }> */
		nil,
		/* 137 Action80 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 138 Action81 <- <{ p.CounterPush() }> */
		nil,
		/* 139 Action82 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
