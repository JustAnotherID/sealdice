package dice

// Code generated by peg -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rulee0m
	rulee0
	ruleeTernary
	ruleeBitwise
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulebitwiseOr
	rulelogicOr
	rulebitwiseAnd
	rulelogicAnd
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	rulePegText
	ruleAction57
	ruleAction58
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"e0m",
	"e0",
	"eTernary",
	"eBitwise",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"bitwiseOr",
	"logicOr",
	"bitwiseAnd",
	"logicAnd",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"PegText",
	"Action57",
	"Action58",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [108]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypeClearDetail)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddLeftValueMark()
		case ruleAction9:
			p.AddOperator(TypeBitwiseOr)
		case ruleAction10:
			p.AddLeftValueMark()
		case ruleAction11:
			p.AddOperator(TypeBitwiseAnd)
		case ruleAction12:
			p.AddLeftValueMark()
		case ruleAction13:
			p.AddOperator(TypeCompLT)
		case ruleAction14:
			p.AddLeftValueMark()
		case ruleAction15:
			p.AddOperator(TypeCompLE)
		case ruleAction16:
			p.AddLeftValueMark()
		case ruleAction17:
			p.AddOperator(TypeCompEQ)
		case ruleAction18:
			p.AddLeftValueMark()
		case ruleAction19:
			p.AddOperator(TypeCompNE)
		case ruleAction20:
			p.AddLeftValueMark()
		case ruleAction21:
			p.AddOperator(TypeCompGE)
		case ruleAction22:
			p.AddLeftValueMark()
		case ruleAction23:
			p.AddOperator(TypeCompGT)
		case ruleAction24:
			p.AddLeftValueMark()
		case ruleAction25:
			p.AddOperator(TypeAdd)
		case ruleAction26:
			p.AddLeftValueMark()
		case ruleAction27:
			p.AddOperator(TypeSubtract)
		case ruleAction28:
			p.AddLeftValueMark()
		case ruleAction29:
			p.AddOperator(TypeMultiply)
		case ruleAction30:
			p.AddLeftValueMark()
		case ruleAction31:
			p.AddOperator(TypeDivide)
		case ruleAction32:
			p.AddLeftValueMark()
		case ruleAction33:
			p.AddOperator(TypeModulus)
		case ruleAction34:
			p.AddLeftValueMark()
		case ruleAction35:
			p.AddOperator(TypeExponentiation)
		case ruleAction36:
			p.AddOperator(TypeNegation)
		case ruleAction37:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction38:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction39:
			p.AddOperator(TypeDiceSetK)
		case ruleAction40:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction41:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction42:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction43:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction44:
			p.AddOperator(TypeDice)
		case ruleAction45:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction46:
			p.AddOperator(TypeDice)
		case ruleAction47:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction48:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction49:
			p.AddLeftValueMark()
		case ruleAction50:
			p.AddOperator(TypeDice)
		case ruleAction51:
			p.AddOperator(TypeDicePenalty)
		case ruleAction52:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction53:
			p.AddOperator(TypeDiceBonus)
		case ruleAction54:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction55:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction56:
			p.AddLoadVarname(string(text))
		case ruleAction57:
			p.AddValue(string(text))
		case ruleAction58:
			p.AddFormatString(string(text))

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2 := position
				l3:
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l4
						}
						if buffer[position] != rune(';') {
							goto l4
						}
						position++
						if !_rules[rulesp]() {
							goto l4
						}
						{
							add(ruleAction1, position)
						}
						goto l3
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
					if !_rules[ruleeOne]() {
						goto l0
					}
					add(rulee, position2)
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <((eOne ';' sp Action1)* eOne)> */
		nil,
		/* 2 eOne <- <(sp (fstring / e0))> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				if !_rules[rulesp]() {
					goto l8
				}
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if buffer[position] != rune('`') {
							goto l11
						}
						position++
						{
							position13 := position
						l14:
							{
								position15, tokenIndex15 := position, tokenIndex
								{
									position16, tokenIndex16 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l17
									}
									position++
									if !_rules[rulesp]() {
										goto l17
									}
									{
										position18 := position
									l19:
										{
											position20, tokenIndex20 := position, tokenIndex
											if !_rules[rulee0]() {
												goto l20
											}
											if buffer[position] != rune(';') {
												goto l20
											}
											position++
											if !_rules[rulesp]() {
												goto l20
											}
											{
												add(ruleAction4, position)
											}
											goto l19
										l20:
											position, tokenIndex = position20, tokenIndex20
										}
										if !_rules[rulee0]() {
											goto l17
										}
										add(rulee0m, position18)
									}
									if !_rules[rulesp]() {
										goto l17
									}
									if buffer[position] != rune('}') {
										goto l17
									}
									position++
									goto l16
								l17:
									position, tokenIndex = position16, tokenIndex16
									{
										position23 := position
										if buffer[position] != rune('\\') {
											goto l22
										}
										position++
										{
											switch buffer[position] {
											case '\\':
												if buffer[position] != rune('\\') {
													goto l22
												}
												position++
											case '\'':
												if buffer[position] != rune('\'') {
													goto l22
												}
												position++
											case '"':
												if buffer[position] != rune('"') {
													goto l22
												}
												position++
											case 'r':
												if buffer[position] != rune('r') {
													goto l22
												}
												position++
											case 'f':
												if buffer[position] != rune('f') {
													goto l22
												}
												position++
											case 'n':
												if buffer[position] != rune('n') {
													goto l22
												}
												position++
											case 't':
												if buffer[position] != rune('t') {
													goto l22
												}
												position++
											default:
												if buffer[position] != rune('b') {
													goto l22
												}
												position++
											}
										}

										add(ruleescape, position23)
									}
									goto l16
								l22:
									position, tokenIndex = position16, tokenIndex16
									{
										position25, tokenIndex25 := position, tokenIndex
										{
											switch buffer[position] {
											case '\r':
												if buffer[position] != rune('\r') {
													goto l25
												}
												position++
											case '\n':
												if buffer[position] != rune('\n') {
													goto l25
												}
												position++
											case '\\':
												if buffer[position] != rune('\\') {
													goto l25
												}
												position++
											default:
												if buffer[position] != rune('`') {
													goto l25
												}
												position++
											}
										}

										goto l15
									l25:
										position, tokenIndex = position25, tokenIndex25
									}
									if !matchDot() {
										goto l15
									}
								}
							l16:
								goto l14
							l15:
								position, tokenIndex = position15, tokenIndex15
							}
							add(rulePegText, position13)
						}
						if buffer[position] != rune('`') {
							goto l11
						}
						position++
						if !_rules[rulesp]() {
							goto l11
						}
						{
							add(ruleAction58, position)
						}
						add(rulefstring, position12)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulee0]() {
						goto l8
					}
				}
			l10:
				add(ruleeOne, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' e0 Action3)> */
		nil,
		/* 4 e0m <- <((e0 ';' sp Action4)* e0)> */
		nil,
		/* 5 e0 <- <eTernary> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				{
					position32 := position
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[ruleeBitwise]() {
							goto l34
						}
						if buffer[position] != rune('?') {
							goto l34
						}
						position++
						if !_rules[rulesp]() {
							goto l34
						}
						{
							add(ruleAction5, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l34
						}
						if buffer[position] != rune(':') {
							goto l34
						}
						position++
						if !_rules[rulesp]() {
							goto l34
						}
						{
							add(ruleAction6, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l34
						}
						{
							add(ruleAction7, position)
						}
						goto l33
					l34:
						position, tokenIndex = position33, tokenIndex33
						if !_rules[ruleeBitwise]() {
							goto l30
						}
					}
				l33:
					add(ruleeTernary, position32)
				}
				add(rulee0, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 6 eTernary <- <((eBitwise '?' sp Action5 eBitwise ':' sp Action6 eBitwise Action7) / eBitwise)> */
		nil,
		/* 7 eBitwise <- <(eComp (((logicOr / bitwiseOr) Action8 eComp Action9) / ((logicAnd / bitwiseAnd) Action10 eComp Action11))*)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[ruleeComp]() {
					goto l39
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position43, tokenIndex43 := position, tokenIndex
						{
							position45, tokenIndex45 := position, tokenIndex
							{
								position47 := position
								if buffer[position] != rune('|') {
									goto l46
								}
								position++
								if buffer[position] != rune('|') {
									goto l46
								}
								position++
								if !_rules[rulesp]() {
									goto l46
								}
								add(rulelogicOr, position47)
							}
							goto l45
						l46:
							position, tokenIndex = position45, tokenIndex45
							{
								position48 := position
								if buffer[position] != rune('|') {
									goto l44
								}
								position++
								if !_rules[rulesp]() {
									goto l44
								}
								add(rulebitwiseOr, position48)
							}
						}
					l45:
						{
							add(ruleAction8, position)
						}
						if !_rules[ruleeComp]() {
							goto l44
						}
						{
							add(ruleAction9, position)
						}
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						{
							position51, tokenIndex51 := position, tokenIndex
							{
								position53 := position
								{
									position54, tokenIndex54 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l55
									}
									position++
									if buffer[position] != rune('&') {
										goto l55
									}
									position++
									goto l54
								l55:
									position, tokenIndex = position54, tokenIndex54
									if buffer[position] != rune('&') {
										goto l52
									}
									position++
									if buffer[position] != rune('a') {
										goto l52
									}
									position++
									if buffer[position] != rune('m') {
										goto l52
									}
									position++
									if buffer[position] != rune('p') {
										goto l52
									}
									position++
									if buffer[position] != rune(';') {
										goto l52
									}
									position++
									if buffer[position] != rune('&') {
										goto l52
									}
									position++
									if buffer[position] != rune('a') {
										goto l52
									}
									position++
									if buffer[position] != rune('m') {
										goto l52
									}
									position++
									if buffer[position] != rune('p') {
										goto l52
									}
									position++
									if buffer[position] != rune(';') {
										goto l52
									}
									position++
								}
							l54:
								if !_rules[rulesp]() {
									goto l52
								}
								add(rulelogicAnd, position53)
							}
							goto l51
						l52:
							position, tokenIndex = position51, tokenIndex51
							{
								position56 := position
								{
									position57, tokenIndex57 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l58
									}
									position++
									goto l57
								l58:
									position, tokenIndex = position57, tokenIndex57
									if buffer[position] != rune('&') {
										goto l42
									}
									position++
									if buffer[position] != rune('a') {
										goto l42
									}
									position++
									if buffer[position] != rune('m') {
										goto l42
									}
									position++
									if buffer[position] != rune('p') {
										goto l42
									}
									position++
									if buffer[position] != rune(';') {
										goto l42
									}
									position++
								}
							l57:
								if !_rules[rulesp]() {
									goto l42
								}
								add(rulebitwiseAnd, position56)
							}
						}
					l51:
						{
							add(ruleAction10, position)
						}
						if !_rules[ruleeComp]() {
							goto l42
						}
						{
							add(ruleAction11, position)
						}
					}
				l43:
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				add(ruleeBitwise, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 8 eComp <- <(e1 ((lt Action12 e1 Action13) / (ge Action20 e1 Action21) / ((&('>') (gt Action22 e1 Action23)) | (&('!') (ne Action18 e1 Action19)) | (&('=') (eq Action16 e1 Action17)) | (&('<') (le Action14 e1 Action15))))*)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[rulee1]() {
					goto l61
				}
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					{
						position65, tokenIndex65 := position, tokenIndex
						{
							position67 := position
							{
								position68, tokenIndex68 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l69
								}
								position++
								goto l68
							l69:
								position, tokenIndex = position68, tokenIndex68
								if buffer[position] != rune('＜') {
									goto l66
								}
								position++
							}
						l68:
							if !_rules[rulesp]() {
								goto l66
							}
							add(rulelt, position67)
						}
						{
							add(ruleAction12, position)
						}
						if !_rules[rulee1]() {
							goto l66
						}
						{
							add(ruleAction13, position)
						}
						goto l65
					l66:
						position, tokenIndex = position65, tokenIndex65
						{
							position73 := position
							{
								position74, tokenIndex74 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l75
								}
								position++
								if buffer[position] != rune('=') {
									goto l75
								}
								position++
								goto l74
							l75:
								position, tokenIndex = position74, tokenIndex74
								if buffer[position] != rune('＞') {
									goto l72
								}
								position++
								if buffer[position] != rune('＝') {
									goto l72
								}
								position++
							}
						l74:
							if !_rules[rulesp]() {
								goto l72
							}
							add(rulege, position73)
						}
						{
							add(ruleAction20, position)
						}
						if !_rules[rulee1]() {
							goto l72
						}
						{
							add(ruleAction21, position)
						}
						goto l65
					l72:
						position, tokenIndex = position65, tokenIndex65
						{
							switch buffer[position] {
							case '>':
								{
									position79 := position
									{
										position80, tokenIndex80 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l81
										}
										position++
										goto l80
									l81:
										position, tokenIndex = position80, tokenIndex80
										if buffer[position] != rune('＞') {
											goto l64
										}
										position++
									}
								l80:
									if !_rules[rulesp]() {
										goto l64
									}
									add(rulegt, position79)
								}
								{
									add(ruleAction22, position)
								}
								if !_rules[rulee1]() {
									goto l64
								}
								{
									add(ruleAction23, position)
								}
							case '!':
								{
									position84 := position
									{
										position85, tokenIndex85 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l86
										}
										position++
										if buffer[position] != rune('=') {
											goto l86
										}
										position++
										goto l85
									l86:
										position, tokenIndex = position85, tokenIndex85
										if buffer[position] != rune('！') {
											goto l64
										}
										position++
										if buffer[position] != rune('＝') {
											goto l64
										}
										position++
									}
								l85:
									if !_rules[rulesp]() {
										goto l64
									}
									add(rulene, position84)
								}
								{
									add(ruleAction18, position)
								}
								if !_rules[rulee1]() {
									goto l64
								}
								{
									add(ruleAction19, position)
								}
							case '=':
								{
									position89 := position
									{
										position90, tokenIndex90 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l91
										}
										position++
										if buffer[position] != rune('=') {
											goto l91
										}
										position++
										goto l90
									l91:
										position, tokenIndex = position90, tokenIndex90
										if buffer[position] != rune('＝') {
											goto l64
										}
										position++
										if buffer[position] != rune('＝') {
											goto l64
										}
										position++
									}
								l90:
									if !_rules[rulesp]() {
										goto l64
									}
									add(ruleeq, position89)
								}
								{
									add(ruleAction16, position)
								}
								if !_rules[rulee1]() {
									goto l64
								}
								{
									add(ruleAction17, position)
								}
							default:
								{
									position94 := position
									{
										position95, tokenIndex95 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l96
										}
										position++
										if buffer[position] != rune('=') {
											goto l96
										}
										position++
										goto l95
									l96:
										position, tokenIndex = position95, tokenIndex95
										if buffer[position] != rune('＜') {
											goto l64
										}
										position++
										if buffer[position] != rune('＝') {
											goto l64
										}
										position++
									}
								l95:
									if !_rules[rulesp]() {
										goto l64
									}
									add(rulele, position94)
								}
								{
									add(ruleAction14, position)
								}
								if !_rules[rulee1]() {
									goto l64
								}
								{
									add(ruleAction15, position)
								}
							}
						}

					}
				l65:
					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
				add(ruleeComp, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 9 e1 <- <(e2 ((add Action24 e2 Action25) / (minus Action26 e2 Action27))*)> */
		func() bool {
			position99, tokenIndex99 := position, tokenIndex
			{
				position100 := position
				if !_rules[rulee2]() {
					goto l99
				}
			l101:
				{
					position102, tokenIndex102 := position, tokenIndex
					{
						position103, tokenIndex103 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l104
						}
						{
							add(ruleAction24, position)
						}
						if !_rules[rulee2]() {
							goto l104
						}
						{
							add(ruleAction25, position)
						}
						goto l103
					l104:
						position, tokenIndex = position103, tokenIndex103
						if !_rules[ruleminus]() {
							goto l102
						}
						{
							add(ruleAction26, position)
						}
						if !_rules[rulee2]() {
							goto l102
						}
						{
							add(ruleAction27, position)
						}
					}
				l103:
					goto l101
				l102:
					position, tokenIndex = position102, tokenIndex102
				}
				add(rulee1, position100)
			}
			return true
		l99:
			position, tokenIndex = position99, tokenIndex99
			return false
		},
		/* 10 e2 <- <(e3 ((&('%') (modulus Action32 e3 Action33)) | (&('/') (divide Action30 e3 Action31)) | (&('*') (multiply Action28 e3 Action29)))*)> */
		func() bool {
			position109, tokenIndex109 := position, tokenIndex
			{
				position110 := position
				if !_rules[rulee3]() {
					goto l109
				}
			l111:
				{
					position112, tokenIndex112 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position114 := position
								if buffer[position] != rune('%') {
									goto l112
								}
								position++
								if !_rules[rulesp]() {
									goto l112
								}
								add(rulemodulus, position114)
							}
							{
								add(ruleAction32, position)
							}
							if !_rules[rulee3]() {
								goto l112
							}
							{
								add(ruleAction33, position)
							}
						case '/':
							{
								position117 := position
								{
									position118, tokenIndex118 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l119
									}
									position++
									goto l118
								l119:
									position, tokenIndex = position118, tokenIndex118
									if buffer[position] != rune('／') {
										goto l112
									}
									position++
								}
							l118:
								if !_rules[rulesp]() {
									goto l112
								}
								add(ruledivide, position117)
							}
							{
								add(ruleAction30, position)
							}
							if !_rules[rulee3]() {
								goto l112
							}
							{
								add(ruleAction31, position)
							}
						default:
							{
								position122 := position
								{
									position123, tokenIndex123 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l124
									}
									position++
									goto l123
								l124:
									position, tokenIndex = position123, tokenIndex123
									if buffer[position] != rune('＊') {
										goto l112
									}
									position++
								}
							l123:
								if !_rules[rulesp]() {
									goto l112
								}
								add(rulemultiply, position122)
							}
							{
								add(ruleAction28, position)
							}
							if !_rules[rulee3]() {
								goto l112
							}
							{
								add(ruleAction29, position)
							}
						}
					}

					goto l111
				l112:
					position, tokenIndex = position112, tokenIndex112
				}
				add(rulee2, position110)
			}
			return true
		l109:
			position, tokenIndex = position109, tokenIndex109
			return false
		},
		/* 11 e3 <- <(e4 (exponentiation Action34 e4 Action35)*)> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				if !_rules[rulee4]() {
					goto l127
				}
			l129:
				{
					position130, tokenIndex130 := position, tokenIndex
					{
						position131 := position
						{
							position132, tokenIndex132 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l133
							}
							position++
							if !_rules[rulesp]() {
								goto l133
							}
							goto l132
						l133:
							position, tokenIndex = position132, tokenIndex132
							if buffer[position] != rune('*') {
								goto l130
							}
							position++
							if buffer[position] != rune('*') {
								goto l130
							}
							position++
							if !_rules[rulesp]() {
								goto l130
							}
						}
					l132:
						add(ruleexponentiation, position131)
					}
					{
						add(ruleAction34, position)
					}
					if !_rules[rulee4]() {
						goto l130
					}
					{
						add(ruleAction35, position)
					}
					goto l129
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
				add(rulee3, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 12 e4 <- <((minus e5 Action36) / e5)> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				{
					position138, tokenIndex138 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l139
					}
					if !_rules[rulee5]() {
						goto l139
					}
					{
						add(ruleAction36, position)
					}
					goto l138
				l139:
					position, tokenIndex = position138, tokenIndex138
					if !_rules[rulee5]() {
						goto l136
					}
				}
			l138:
				add(rulee4, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 13 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				{
					position143, tokenIndex143 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l144
					}
					if !_rules[ruleeDice]() {
						goto l144
					}
					goto l143
				l144:
					position, tokenIndex = position143, tokenIndex143
					if !_rules[ruleeDice]() {
						goto l141
					}
				}
			l143:
				add(rulee5, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 14 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action37 sp) / ((('劣' '势') / ('k' 'l')) Action38 sp))> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				{
					position147, tokenIndex147 := position, tokenIndex
					{
						position149, tokenIndex149 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l150
						}
						position++
						if buffer[position] != rune('势') {
							goto l150
						}
						position++
						goto l149
					l150:
						position, tokenIndex = position149, tokenIndex149
						if buffer[position] != rune('k') {
							goto l148
						}
						position++
						if buffer[position] != rune('h') {
							goto l148
						}
						position++
					}
				l149:
					{
						add(ruleAction37, position)
					}
					if !_rules[rulesp]() {
						goto l148
					}
					goto l147
				l148:
					position, tokenIndex = position147, tokenIndex147
					{
						position152, tokenIndex152 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l153
						}
						position++
						if buffer[position] != rune('势') {
							goto l153
						}
						position++
						goto l152
					l153:
						position, tokenIndex = position152, tokenIndex152
						if buffer[position] != rune('k') {
							goto l145
						}
						position++
						if buffer[position] != rune('l') {
							goto l145
						}
						position++
					}
				l152:
					{
						add(ruleAction38, position)
					}
					if !_rules[rulesp]() {
						goto l145
					}
				}
			l147:
				add(ruledndDiceSuffix, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 15 kqDiceOp <- <(('k' eDice2 Action39)? ('q' eDice2 Action40)? ('d' 'l' eDice2 Action41)? ('d' 'h' eDice2 Action42)?)> */
		func() bool {
			{
				position156 := position
				{
					position157, tokenIndex157 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l157
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l157
					}
					{
						add(ruleAction39, position)
					}
					goto l158
				l157:
					position, tokenIndex = position157, tokenIndex157
				}
			l158:
				{
					position160, tokenIndex160 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l160
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l160
					}
					{
						add(ruleAction40, position)
					}
					goto l161
				l160:
					position, tokenIndex = position160, tokenIndex160
				}
			l161:
				{
					position163, tokenIndex163 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l163
					}
					position++
					if buffer[position] != rune('l') {
						goto l163
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l163
					}
					{
						add(ruleAction41, position)
					}
					goto l164
				l163:
					position, tokenIndex = position163, tokenIndex163
				}
			l164:
				{
					position166, tokenIndex166 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l166
					}
					position++
					if buffer[position] != rune('h') {
						goto l166
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l166
					}
					{
						add(ruleAction42, position)
					}
					goto l167
				l166:
					position, tokenIndex = position166, tokenIndex166
				}
			l167:
				add(rulekqDiceOp, position156)
			}
			return true
		},
		/* 16 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				{
					position171, tokenIndex171 := position, tokenIndex
					{
						position172, tokenIndex172 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l173
						}
						position++
						goto l172
					l173:
						position, tokenIndex = position172, tokenIndex172
						if buffer[position] != rune('D') {
							goto l169
						}
						position++
					}
				l172:
					{
						position174, tokenIndex174 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l175
						}
						goto l174
					l175:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('(') {
							goto l169
						}
						position++
					}
				l174:
					position, tokenIndex = position171, tokenIndex171
				}
				add(rule_dnumber, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 17 eDice <- <((_dnumber ('d' / 'D') Action43 eDice2 dndDiceSuffix Action44) / (_dnumber ('d' / 'D') Action45 eDice2 kqDiceOp Action46) / (('d' / 'D') dndDiceSuffix Action47) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action48) / (eDice2 (('d' / 'D') Action49 &(number / '(') eDice2 kqDiceOp Action50)*))> */
		func() bool {
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				{
					position178, tokenIndex178 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l179
					}
					{
						position180, tokenIndex180 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l181
						}
						position++
						goto l180
					l181:
						position, tokenIndex = position180, tokenIndex180
						if buffer[position] != rune('D') {
							goto l179
						}
						position++
					}
				l180:
					{
						add(ruleAction43, position)
					}
					if !_rules[ruleeDice2]() {
						goto l179
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l179
					}
					{
						add(ruleAction44, position)
					}
					goto l178
				l179:
					position, tokenIndex = position178, tokenIndex178
					if !_rules[rule_dnumber]() {
						goto l184
					}
					{
						position185, tokenIndex185 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l186
						}
						position++
						goto l185
					l186:
						position, tokenIndex = position185, tokenIndex185
						if buffer[position] != rune('D') {
							goto l184
						}
						position++
					}
				l185:
					{
						add(ruleAction45, position)
					}
					if !_rules[ruleeDice2]() {
						goto l184
					}
					if !_rules[rulekqDiceOp]() {
						goto l184
					}
					{
						add(ruleAction46, position)
					}
					goto l178
				l184:
					position, tokenIndex = position178, tokenIndex178
					{
						position190, tokenIndex190 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l191
						}
						position++
						goto l190
					l191:
						position, tokenIndex = position190, tokenIndex190
						if buffer[position] != rune('D') {
							goto l189
						}
						position++
					}
				l190:
					if !_rules[ruledndDiceSuffix]() {
						goto l189
					}
					{
						add(ruleAction47, position)
					}
					goto l178
				l189:
					position, tokenIndex = position178, tokenIndex178
					{
						position194, tokenIndex194 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l195
						}
						position++
						goto l194
					l195:
						position, tokenIndex = position194, tokenIndex194
						if buffer[position] != rune('D') {
							goto l193
						}
						position++
					}
				l194:
					{
						position196, tokenIndex196 := position, tokenIndex
						{
							position197, tokenIndex197 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l197
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l197
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l197
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l197
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l197
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l197
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l197
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l197
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l197
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l197
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l197
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l197
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l197
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l197
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l197
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l197
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l197
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l197
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l197
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l197
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l197
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l197
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l197
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l197
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l197
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l197
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l197
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l197
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l197
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l197
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l197
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l197
									}
									position++
								}
							}

							goto l196
						l197:
							position, tokenIndex = position197, tokenIndex197
						}
						if !matchDot() {
							goto l196
						}
						goto l193
					l196:
						position, tokenIndex = position196, tokenIndex196
					}
					if !_rules[rulesp]() {
						goto l193
					}
					{
						add(ruleAction48, position)
					}
					goto l178
				l193:
					position, tokenIndex = position178, tokenIndex178
					if !_rules[ruleeDice2]() {
						goto l176
					}
				l200:
					{
						position201, tokenIndex201 := position, tokenIndex
						{
							position202, tokenIndex202 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l203
							}
							position++
							goto l202
						l203:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('D') {
								goto l201
							}
							position++
						}
					l202:
						{
							add(ruleAction49, position)
						}
						{
							position205, tokenIndex205 := position, tokenIndex
							{
								position206, tokenIndex206 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l207
								}
								goto l206
							l207:
								position, tokenIndex = position206, tokenIndex206
								if buffer[position] != rune('(') {
									goto l201
								}
								position++
							}
						l206:
							position, tokenIndex = position205, tokenIndex205
						}
						if !_rules[ruleeDice2]() {
							goto l201
						}
						if !_rules[rulekqDiceOp]() {
							goto l201
						}
						{
							add(ruleAction50, position)
						}
						goto l200
					l201:
						position, tokenIndex = position201, tokenIndex201
					}
				}
			l178:
				add(ruleeDice, position177)
			}
			return true
		l176:
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 18 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				{
					position211, tokenIndex211 := position, tokenIndex
					{
						position212, tokenIndex212 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l213
						}
						goto l212
					l213:
						position, tokenIndex = position212, tokenIndex212
						if buffer[position] != rune('(') {
							goto l209
						}
						position++
					}
				l212:
					position, tokenIndex = position211, tokenIndex211
				}
				add(rulelaNumberOrLeftParen, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 19 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action51) / (('p' / 'P') Action52) / eDice3)> */
		func() bool {
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				{
					position216, tokenIndex216 := position, tokenIndex
					{
						position218, tokenIndex218 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l219
						}
						position++
						goto l218
					l219:
						position, tokenIndex = position218, tokenIndex218
						if buffer[position] != rune('P') {
							goto l217
						}
						position++
					}
				l218:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l217
					}
					if !_rules[ruleeDice3]() {
						goto l217
					}
					{
						add(ruleAction51, position)
					}
					goto l216
				l217:
					position, tokenIndex = position216, tokenIndex216
					{
						position222, tokenIndex222 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l223
						}
						position++
						goto l222
					l223:
						position, tokenIndex = position222, tokenIndex222
						if buffer[position] != rune('P') {
							goto l221
						}
						position++
					}
				l222:
					{
						add(ruleAction52, position)
					}
					goto l216
				l221:
					position, tokenIndex = position216, tokenIndex216
					if !_rules[ruleeDice3]() {
						goto l214
					}
				}
			l216:
				add(ruleeDice2, position215)
			}
			return true
		l214:
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 20 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action53) / (('b' / 'B') Action54) / eDice4)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				{
					position227, tokenIndex227 := position, tokenIndex
					{
						position229, tokenIndex229 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l230
						}
						position++
						goto l229
					l230:
						position, tokenIndex = position229, tokenIndex229
						if buffer[position] != rune('B') {
							goto l228
						}
						position++
					}
				l229:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l228
					}
					if !_rules[rulevalue]() {
						goto l228
					}
					{
						add(ruleAction53, position)
					}
					goto l227
				l228:
					position, tokenIndex = position227, tokenIndex227
					{
						position233, tokenIndex233 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l234
						}
						position++
						goto l233
					l234:
						position, tokenIndex = position233, tokenIndex233
						if buffer[position] != rune('B') {
							goto l232
						}
						position++
					}
				l233:
					{
						add(ruleAction54, position)
					}
					goto l227
				l232:
					position, tokenIndex = position227, tokenIndex227
					{
						position236 := position
						{
							position237, tokenIndex237 := position, tokenIndex
							{
								position239, tokenIndex239 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l240
								}
								position++
								goto l239
							l240:
								position, tokenIndex = position239, tokenIndex239
								if buffer[position] != rune('F') {
									goto l238
								}
								position++
							}
						l239:
							if !_rules[rulesp]() {
								goto l238
							}
							{
								add(ruleAction55, position)
							}
							goto l237
						l238:
							position, tokenIndex = position237, tokenIndex237
							if !_rules[rulevalue]() {
								goto l225
							}
						}
					l237:
						add(ruleeDice4, position236)
					}
				}
			l227:
				add(ruleeDice3, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 21 eDice4 <- <((('f' / 'F') sp Action55) / value)> */
		nil,
		/* 22 value <- <(number / assign_expr / (identifier Action56) / sub)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l246
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					{
						position248 := position
						if !_rules[ruleidentifier]() {
							goto l247
						}
						{
							add(ruleAction2, position)
						}
						if buffer[position] != rune('=') {
							goto l247
						}
						position++
						if !_rules[rulee0]() {
							goto l247
						}
						{
							add(ruleAction3, position)
						}
						add(ruleassign_expr, position248)
					}
					goto l245
				l247:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleidentifier]() {
						goto l251
					}
					{
						add(ruleAction56, position)
					}
					goto l245
				l251:
					position, tokenIndex = position245, tokenIndex245
					{
						position253 := position
						{
							position254 := position
							if buffer[position] != rune('(') {
								goto l243
							}
							position++
							if !_rules[rulesp]() {
								goto l243
							}
							add(ruleopen, position254)
						}
						if !_rules[rulee0]() {
							goto l243
						}
						{
							position255 := position
							if buffer[position] != rune(')') {
								goto l243
							}
							position++
							if !_rules[rulesp]() {
								goto l243
							}
							add(ruleclose, position255)
						}
						add(rulesub, position253)
					}
				}
			l245:
				add(rulevalue, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 23 number <- <(<[0-9]+> sp Action57)> */
		func() bool {
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					position258 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l256
					}
					position++
				l259:
					{
						position260, tokenIndex260 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l260
						}
						position++
						goto l259
					l260:
						position, tokenIndex = position260, tokenIndex260
					}
					add(rulePegText, position258)
				}
				if !_rules[rulesp]() {
					goto l256
				}
				{
					add(ruleAction57, position)
				}
				add(rulenumber, position257)
			}
			return true
		l256:
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 24 identifier <- <(<(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position262, tokenIndex262 := position, tokenIndex
			{
				position263 := position
				{
					position264 := position
					{
						position265, tokenIndex265 := position, tokenIndex
						{
							switch buffer[position] {
							case '\r':
								if buffer[position] != rune('\r') {
									goto l265
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l265
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l265
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l265
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l265
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l265
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l265
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l265
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l265
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l265
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l265
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l265
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l265
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l265
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l265
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l265
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l265
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l265
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l265
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l265
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l265
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l265
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l265
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l265
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l265
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l265
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l265
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l265
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l265
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l265
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l265
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l265
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l265
								}
								position++
							}
						}

						goto l262
					l265:
						position, tokenIndex = position265, tokenIndex265
					}
					if !matchDot() {
						goto l262
					}
				l267:
					{
						position268, tokenIndex268 := position, tokenIndex
						{
							position269, tokenIndex269 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l269
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l269
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l269
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l269
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l269
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l269
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l269
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l269
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l269
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l269
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l269
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l269
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l269
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l269
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l269
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l269
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l269
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l269
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l269
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l269
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l269
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l269
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l269
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l269
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l269
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l269
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l269
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l269
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l269
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l269
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l269
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l269
									}
									position++
								}
							}

							goto l268
						l269:
							position, tokenIndex = position269, tokenIndex269
						}
						if !matchDot() {
							goto l268
						}
						goto l267
					l268:
						position, tokenIndex = position268, tokenIndex268
					}
					add(rulePegText, position264)
				}
				if !_rules[rulesp]() {
					goto l262
				}
				add(ruleidentifier, position263)
			}
			return true
		l262:
			position, tokenIndex = position262, tokenIndex262
			return false
		},
		/* 25 sub <- <(open e0 close)> */
		nil,
		/* 26 add <- <(('+' / '＋') sp)> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				{
					position274, tokenIndex274 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l275
					}
					position++
					goto l274
				l275:
					position, tokenIndex = position274, tokenIndex274
					if buffer[position] != rune('＋') {
						goto l272
					}
					position++
				}
			l274:
				if !_rules[rulesp]() {
					goto l272
				}
				add(ruleadd, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 27 minus <- <(('-' / '－') sp)> */
		func() bool {
			position276, tokenIndex276 := position, tokenIndex
			{
				position277 := position
				{
					position278, tokenIndex278 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l279
					}
					position++
					goto l278
				l279:
					position, tokenIndex = position278, tokenIndex278
					if buffer[position] != rune('－') {
						goto l276
					}
					position++
				}
			l278:
				if !_rules[rulesp]() {
					goto l276
				}
				add(ruleminus, position277)
			}
			return true
		l276:
			position, tokenIndex = position276, tokenIndex276
			return false
		},
		/* 28 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 29 divide <- <(('/' / '／') sp)> */
		nil,
		/* 30 modulus <- <('%' sp)> */
		nil,
		/* 31 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 32 open <- <('(' sp)> */
		nil,
		/* 33 close <- <(')' sp)> */
		nil,
		/* 34 bitwiseOr <- <('|' sp)> */
		nil,
		/* 35 logicOr <- <('|' '|' sp)> */
		nil,
		/* 36 bitwiseAnd <- <(('&' / ('&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 37 logicAnd <- <((('&' '&') / ('&' 'a' 'm' 'p' ';' '&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 38 sp <- <((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' '))*> */
		func() bool {
			{
				position291 := position
			l292:
				{
					position293, tokenIndex293 := position, tokenIndex
					{
						switch buffer[position] {
						case '\r':
							if buffer[position] != rune('\r') {
								goto l293
							}
							position++
						case '\n':
							if buffer[position] != rune('\n') {
								goto l293
							}
							position++
						case '\t':
							if buffer[position] != rune('\t') {
								goto l293
							}
							position++
						default:
							if buffer[position] != rune(' ') {
								goto l293
							}
							position++
						}
					}

					goto l292
				l293:
					position, tokenIndex = position293, tokenIndex293
				}
				add(rulesp, position291)
			}
			return true
		},
		/* 39 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 40 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 41 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 42 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 43 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 44 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 45 fstring <- <('`' <(('{' sp e0m sp '}') / escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('`') '`')) .))*> '`' sp Action58)> */
		nil,
		/* 46 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 48 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 49 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 50 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 51 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 52 Action4 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 53 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 54 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 55 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 56 Action8 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 57 Action9 <- <{ p.AddOperator(TypeBitwiseOr) }> */
		nil,
		/* 58 Action10 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 59 Action11 <- <{ p.AddOperator(TypeBitwiseAnd) }> */
		nil,
		/* 60 Action12 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 61 Action13 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 62 Action14 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 63 Action15 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 64 Action16 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 65 Action17 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 66 Action18 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 67 Action19 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 68 Action20 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 69 Action21 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 70 Action22 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 71 Action23 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 72 Action24 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 73 Action25 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 74 Action26 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 75 Action27 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 76 Action28 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 77 Action29 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 78 Action30 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 79 Action31 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 80 Action32 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 81 Action33 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 82 Action34 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 83 Action35 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 84 Action36 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 85 Action37 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 86 Action38 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 87 Action39 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 88 Action40 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 89 Action41 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 90 Action42 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 91 Action43 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 92 Action44 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 93 Action45 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 94 Action46 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 95 Action47 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 96 Action48 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 97 Action49 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 98 Action50 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 99 Action51 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 100 Action52 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 101 Action53 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 102 Action54 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 103 Action55 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 104 Action56 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 106 Action57 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 107 Action58 <- <{ p.AddFormatString(string(text)) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
