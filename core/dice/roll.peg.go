package dice

// Code generated by C:\Users\fy0\go\bin\peg.exe -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	rulee
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	rulevalue
	rulenumber
	ruleassign_expr
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulesp
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	rulePegText
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
)

var rul3s = [...]string{
	"Unknown",
	"e",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"value",
	"number",
	"assign_expr",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"sp",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"PegText",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [60]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddLeftValueMark()
		case ruleAction2:
			p.AddOperator(TypeAdd)
		case ruleAction3:
			p.AddLeftValueMark()
		case ruleAction4:
			p.AddOperator(TypeSubtract)
		case ruleAction5:
			p.AddLeftValueMark()
		case ruleAction6:
			p.AddOperator(TypeMultiply)
		case ruleAction7:
			p.AddLeftValueMark()
		case ruleAction8:
			p.AddOperator(TypeDivide)
		case ruleAction9:
			p.AddLeftValueMark()
		case ruleAction10:
			p.AddOperator(TypeModulus)
		case ruleAction11:
			p.AddLeftValueMark()
		case ruleAction12:
			p.AddOperator(TypeExponentiation)
		case ruleAction13:
			p.AddOperator(TypeNegation)
		case ruleAction14:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction15:
			p.AddOperator(TypeDiceSetK)
		case ruleAction16:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction17:
			p.AddOperator(TypeDice)
		case ruleAction18:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction19:
			p.AddLeftValueMark()
		case ruleAction20:
			p.AddOperator(TypeDiceSetK)
		case ruleAction21:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction22:
			p.AddOperator(TypeDice)
		case ruleAction23:
			p.AddOperator(TypeDicePenalty)
		case ruleAction24:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction25:
			p.AddOperator(TypeDiceBonus)
		case ruleAction26:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction27:
			p.AddLoadVarname(string(text))
		case ruleAction28:
			p.AddValue(string(text))
		case ruleAction29:
			p.AddValueStr(string(text))
		case ruleAction30:
			p.AddStore()
		case ruleAction31:
			p.AddFormatString(string(text))

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 e <- <(sp (fstring / e1) Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulesp]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						{
							position5 := position
						l6:
							{
								position7, tokenIndex7 := position, tokenIndex
								{
									position8, tokenIndex8 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l9
									}
									position++
									if !_rules[rulesp]() {
										goto l9
									}
									if !_rules[rulee1]() {
										goto l9
									}
									if !_rules[rulesp]() {
										goto l9
									}
									if buffer[position] != rune('}') {
										goto l9
									}
									position++
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									{
										position11 := position
										if buffer[position] != rune('\\') {
											goto l10
										}
										position++
										{
											switch buffer[position] {
											case '\\':
												if buffer[position] != rune('\\') {
													goto l10
												}
												position++
											case '\'':
												if buffer[position] != rune('\'') {
													goto l10
												}
												position++
											case '"':
												if buffer[position] != rune('"') {
													goto l10
												}
												position++
											case 'r':
												if buffer[position] != rune('r') {
													goto l10
												}
												position++
											case 'f':
												if buffer[position] != rune('f') {
													goto l10
												}
												position++
											case 'n':
												if buffer[position] != rune('n') {
													goto l10
												}
												position++
											case 't':
												if buffer[position] != rune('t') {
													goto l10
												}
												position++
											default:
												if buffer[position] != rune('b') {
													goto l10
												}
												position++
											}
										}

										add(ruleescape, position11)
									}
									goto l8
								l10:
									position, tokenIndex = position8, tokenIndex8
									{
										position13, tokenIndex13 := position, tokenIndex
										{
											switch buffer[position] {
											case '\r':
												if buffer[position] != rune('\r') {
													goto l13
												}
												position++
											case '\n':
												if buffer[position] != rune('\n') {
													goto l13
												}
												position++
											case '\\':
												if buffer[position] != rune('\\') {
													goto l13
												}
												position++
											default:
												if buffer[position] != rune('`') {
													goto l13
												}
												position++
											}
										}

										goto l7
									l13:
										position, tokenIndex = position13, tokenIndex13
									}
									if !matchDot() {
										goto l7
									}
								}
							l8:
								goto l6
							l7:
								position, tokenIndex = position7, tokenIndex7
							}
							add(rulePegText, position5)
						}
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						if !_rules[rulesp]() {
							goto l3
						}
						{
							add(ruleAction31, position)
						}
						add(rulefstring, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[rulee1]() {
						goto l0
					}
				}
			l2:
				{
					add(ruleAction0, position)
				}
				add(rulee, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e1 <- <(e2 ((add Action1 e2 Action2) / (minus Action3 e2 Action4))*)> */
		func() bool {
			position17, tokenIndex17 := position, tokenIndex
			{
				position18 := position
				if !_rules[rulee2]() {
					goto l17
				}
			l19:
				{
					position20, tokenIndex20 := position, tokenIndex
					{
						position21, tokenIndex21 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l22
						}
						{
							add(ruleAction1, position)
						}
						if !_rules[rulee2]() {
							goto l22
						}
						{
							add(ruleAction2, position)
						}
						goto l21
					l22:
						position, tokenIndex = position21, tokenIndex21
						if !_rules[ruleminus]() {
							goto l20
						}
						{
							add(ruleAction3, position)
						}
						if !_rules[rulee2]() {
							goto l20
						}
						{
							add(ruleAction4, position)
						}
					}
				l21:
					goto l19
				l20:
					position, tokenIndex = position20, tokenIndex20
				}
				add(rulee1, position18)
			}
			return true
		l17:
			position, tokenIndex = position17, tokenIndex17
			return false
		},
		/* 2 e2 <- <(e3 ((&('%') (modulus Action9 e3 Action10)) | (&('/') (divide Action7 e3 Action8)) | (&('*') (multiply Action5 e3 Action6)))*)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[rulee3]() {
					goto l27
				}
			l29:
				{
					position30, tokenIndex30 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position32 := position
								if buffer[position] != rune('%') {
									goto l30
								}
								position++
								if !_rules[rulesp]() {
									goto l30
								}
								add(rulemodulus, position32)
							}
							{
								add(ruleAction9, position)
							}
							if !_rules[rulee3]() {
								goto l30
							}
							{
								add(ruleAction10, position)
							}
						case '/':
							{
								position35 := position
								if buffer[position] != rune('/') {
									goto l30
								}
								position++
								if !_rules[rulesp]() {
									goto l30
								}
								add(ruledivide, position35)
							}
							{
								add(ruleAction7, position)
							}
							if !_rules[rulee3]() {
								goto l30
							}
							{
								add(ruleAction8, position)
							}
						default:
							{
								position38 := position
								if buffer[position] != rune('*') {
									goto l30
								}
								position++
								if !_rules[rulesp]() {
									goto l30
								}
								add(rulemultiply, position38)
							}
							{
								add(ruleAction5, position)
							}
							if !_rules[rulee3]() {
								goto l30
							}
							{
								add(ruleAction6, position)
							}
						}
					}

					goto l29
				l30:
					position, tokenIndex = position30, tokenIndex30
				}
				add(rulee2, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 3 e3 <- <(e4 (exponentiation Action11 e4 Action12)*)> */
		func() bool {
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				if !_rules[rulee4]() {
					goto l41
				}
			l43:
				{
					position44, tokenIndex44 := position, tokenIndex
					{
						position45 := position
						{
							position46, tokenIndex46 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l47
							}
							position++
							if !_rules[rulesp]() {
								goto l47
							}
							goto l46
						l47:
							position, tokenIndex = position46, tokenIndex46
							if buffer[position] != rune('*') {
								goto l44
							}
							position++
							if buffer[position] != rune('*') {
								goto l44
							}
							position++
							if !_rules[rulesp]() {
								goto l44
							}
						}
					l46:
						add(ruleexponentiation, position45)
					}
					{
						add(ruleAction11, position)
					}
					if !_rules[rulee4]() {
						goto l44
					}
					{
						add(ruleAction12, position)
					}
					goto l43
				l44:
					position, tokenIndex = position44, tokenIndex44
				}
				add(rulee3, position42)
			}
			return true
		l41:
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 4 e4 <- <((minus e5 Action13) / e5)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				{
					position52, tokenIndex52 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l53
					}
					if !_rules[rulee5]() {
						goto l53
					}
					{
						add(ruleAction13, position)
					}
					goto l52
				l53:
					position, tokenIndex = position52, tokenIndex52
					if !_rules[rulee5]() {
						goto l50
					}
				}
			l52:
				add(rulee4, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 5 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				{
					position57, tokenIndex57 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l58
					}
					if !_rules[ruleeDice]() {
						goto l58
					}
					goto l57
				l58:
					position, tokenIndex = position57, tokenIndex57
					if !_rules[ruleeDice]() {
						goto l55
					}
				}
			l57:
				add(rulee5, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 6 eDice <- <((&(('d' / 'D') (number / '(')) ('d' / 'D') Action14 eDice2 ('k' eDice2 Action15)? ('q' eDice2 Action16)? Action17)+ / (('d' / 'D') Action18) / (eDice2 (('d' / 'D') Action19 &(number / '(') eDice2 ('k' eDice2 Action20)? ('q' eDice2 Action21)? Action22)*))> */
		func() bool {
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				{
					position61, tokenIndex61 := position, tokenIndex
					{
						position65, tokenIndex65 := position, tokenIndex
						{
							position66, tokenIndex66 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l67
							}
							position++
							goto l66
						l67:
							position, tokenIndex = position66, tokenIndex66
							if buffer[position] != rune('D') {
								goto l62
							}
							position++
						}
					l66:
						{
							position68, tokenIndex68 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l69
							}
							goto l68
						l69:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('(') {
								goto l62
							}
							position++
						}
					l68:
						position, tokenIndex = position65, tokenIndex65
					}
					{
						position70, tokenIndex70 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l71
						}
						position++
						goto l70
					l71:
						position, tokenIndex = position70, tokenIndex70
						if buffer[position] != rune('D') {
							goto l62
						}
						position++
					}
				l70:
					{
						add(ruleAction14, position)
					}
					if !_rules[ruleeDice2]() {
						goto l62
					}
					{
						position73, tokenIndex73 := position, tokenIndex
						if buffer[position] != rune('k') {
							goto l73
						}
						position++
						if !_rules[ruleeDice2]() {
							goto l73
						}
						{
							add(ruleAction15, position)
						}
						goto l74
					l73:
						position, tokenIndex = position73, tokenIndex73
					}
				l74:
					{
						position76, tokenIndex76 := position, tokenIndex
						if buffer[position] != rune('q') {
							goto l76
						}
						position++
						if !_rules[ruleeDice2]() {
							goto l76
						}
						{
							add(ruleAction16, position)
						}
						goto l77
					l76:
						position, tokenIndex = position76, tokenIndex76
					}
				l77:
					{
						add(ruleAction17, position)
					}
				l63:
					{
						position64, tokenIndex64 := position, tokenIndex
						{
							position80, tokenIndex80 := position, tokenIndex
							{
								position81, tokenIndex81 := position, tokenIndex
								if buffer[position] != rune('d') {
									goto l82
								}
								position++
								goto l81
							l82:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('D') {
									goto l64
								}
								position++
							}
						l81:
							{
								position83, tokenIndex83 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l84
								}
								goto l83
							l84:
								position, tokenIndex = position83, tokenIndex83
								if buffer[position] != rune('(') {
									goto l64
								}
								position++
							}
						l83:
							position, tokenIndex = position80, tokenIndex80
						}
						{
							position85, tokenIndex85 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l86
							}
							position++
							goto l85
						l86:
							position, tokenIndex = position85, tokenIndex85
							if buffer[position] != rune('D') {
								goto l64
							}
							position++
						}
					l85:
						{
							add(ruleAction14, position)
						}
						if !_rules[ruleeDice2]() {
							goto l64
						}
						{
							position88, tokenIndex88 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l88
							}
							position++
							if !_rules[ruleeDice2]() {
								goto l88
							}
							{
								add(ruleAction15, position)
							}
							goto l89
						l88:
							position, tokenIndex = position88, tokenIndex88
						}
					l89:
						{
							position91, tokenIndex91 := position, tokenIndex
							if buffer[position] != rune('q') {
								goto l91
							}
							position++
							if !_rules[ruleeDice2]() {
								goto l91
							}
							{
								add(ruleAction16, position)
							}
							goto l92
						l91:
							position, tokenIndex = position91, tokenIndex91
						}
					l92:
						{
							add(ruleAction17, position)
						}
						goto l63
					l64:
						position, tokenIndex = position64, tokenIndex64
					}
					goto l61
				l62:
					position, tokenIndex = position61, tokenIndex61
					{
						position96, tokenIndex96 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l97
						}
						position++
						goto l96
					l97:
						position, tokenIndex = position96, tokenIndex96
						if buffer[position] != rune('D') {
							goto l95
						}
						position++
					}
				l96:
					{
						add(ruleAction18, position)
					}
					goto l61
				l95:
					position, tokenIndex = position61, tokenIndex61
					if !_rules[ruleeDice2]() {
						goto l59
					}
				l99:
					{
						position100, tokenIndex100 := position, tokenIndex
						{
							position101, tokenIndex101 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l102
							}
							position++
							goto l101
						l102:
							position, tokenIndex = position101, tokenIndex101
							if buffer[position] != rune('D') {
								goto l100
							}
							position++
						}
					l101:
						{
							add(ruleAction19, position)
						}
						{
							position104, tokenIndex104 := position, tokenIndex
							{
								position105, tokenIndex105 := position, tokenIndex
								if !_rules[rulenumber]() {
									goto l106
								}
								goto l105
							l106:
								position, tokenIndex = position105, tokenIndex105
								if buffer[position] != rune('(') {
									goto l100
								}
								position++
							}
						l105:
							position, tokenIndex = position104, tokenIndex104
						}
						if !_rules[ruleeDice2]() {
							goto l100
						}
						{
							position107, tokenIndex107 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l107
							}
							position++
							if !_rules[ruleeDice2]() {
								goto l107
							}
							{
								add(ruleAction20, position)
							}
							goto l108
						l107:
							position, tokenIndex = position107, tokenIndex107
						}
					l108:
						{
							position110, tokenIndex110 := position, tokenIndex
							if buffer[position] != rune('q') {
								goto l110
							}
							position++
							if !_rules[ruleeDice2]() {
								goto l110
							}
							{
								add(ruleAction21, position)
							}
							goto l111
						l110:
							position, tokenIndex = position110, tokenIndex110
						}
					l111:
						{
							add(ruleAction22, position)
						}
						goto l99
					l100:
						position, tokenIndex = position100, tokenIndex100
					}
				}
			l61:
				add(ruleeDice, position60)
			}
			return true
		l59:
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 7 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				{
					position116, tokenIndex116 := position, tokenIndex
					{
						position117, tokenIndex117 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l118
						}
						goto l117
					l118:
						position, tokenIndex = position117, tokenIndex117
						if buffer[position] != rune('(') {
							goto l114
						}
						position++
					}
				l117:
					position, tokenIndex = position116, tokenIndex116
				}
				add(rulelaNumberOrLeftParen, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 8 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action23) / (('p' / 'P') Action24) / eDice3)> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					{
						position123, tokenIndex123 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l124
						}
						position++
						goto l123
					l124:
						position, tokenIndex = position123, tokenIndex123
						if buffer[position] != rune('P') {
							goto l122
						}
						position++
					}
				l123:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l122
					}
					if !_rules[ruleeDice3]() {
						goto l122
					}
					{
						add(ruleAction23, position)
					}
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					{
						position127, tokenIndex127 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l128
						}
						position++
						goto l127
					l128:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('P') {
							goto l126
						}
						position++
					}
				l127:
					{
						add(ruleAction24, position)
					}
					goto l121
				l126:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleeDice3]() {
						goto l119
					}
				}
			l121:
				add(ruleeDice2, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 9 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action25) / (('b' / 'B') Action26) / value)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				{
					position132, tokenIndex132 := position, tokenIndex
					{
						position134, tokenIndex134 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l135
						}
						position++
						goto l134
					l135:
						position, tokenIndex = position134, tokenIndex134
						if buffer[position] != rune('B') {
							goto l133
						}
						position++
					}
				l134:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l133
					}
					if !_rules[rulevalue]() {
						goto l133
					}
					{
						add(ruleAction25, position)
					}
					goto l132
				l133:
					position, tokenIndex = position132, tokenIndex132
					{
						position138, tokenIndex138 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l139
						}
						position++
						goto l138
					l139:
						position, tokenIndex = position138, tokenIndex138
						if buffer[position] != rune('B') {
							goto l137
						}
						position++
					}
				l138:
					{
						add(ruleAction26, position)
					}
					goto l132
				l137:
					position, tokenIndex = position132, tokenIndex132
					if !_rules[rulevalue]() {
						goto l130
					}
				}
			l132:
				add(ruleeDice3, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 10 value <- <(number / assign_expr / (identifier Action27) / sub)> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				{
					position143, tokenIndex143 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l144
					}
					goto l143
				l144:
					position, tokenIndex = position143, tokenIndex143
					{
						position146 := position
						if !_rules[ruleidentifier]() {
							goto l145
						}
						{
							add(ruleAction29, position)
						}
						if buffer[position] != rune('=') {
							goto l145
						}
						position++
						if !_rules[rulee1]() {
							goto l145
						}
						{
							add(ruleAction30, position)
						}
						add(ruleassign_expr, position146)
					}
					goto l143
				l145:
					position, tokenIndex = position143, tokenIndex143
					if !_rules[ruleidentifier]() {
						goto l149
					}
					{
						add(ruleAction27, position)
					}
					goto l143
				l149:
					position, tokenIndex = position143, tokenIndex143
					{
						position151 := position
						{
							position152 := position
							if buffer[position] != rune('(') {
								goto l141
							}
							position++
							if !_rules[rulesp]() {
								goto l141
							}
							add(ruleopen, position152)
						}
						if !_rules[rulee1]() {
							goto l141
						}
						{
							position153 := position
							if buffer[position] != rune(')') {
								goto l141
							}
							position++
							if !_rules[rulesp]() {
								goto l141
							}
							add(ruleclose, position153)
						}
						add(rulesub, position151)
					}
				}
			l143:
				add(rulevalue, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 11 number <- <(<[0-9]+> sp Action28)> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				{
					position156 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l154
					}
					position++
				l157:
					{
						position158, tokenIndex158 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l158
						}
						position++
						goto l157
					l158:
						position, tokenIndex = position158, tokenIndex158
					}
					add(rulePegText, position156)
				}
				if !_rules[rulesp]() {
					goto l154
				}
				{
					add(ruleAction28, position)
				}
				add(rulenumber, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 12 assign_expr <- <(identifier Action29 '=' e1 Action30)> */
		nil,
		/* 13 identifier <- <(<(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position163 := position
					{
						position164, tokenIndex164 := position, tokenIndex
						{
							switch buffer[position] {
							case '\r':
								if buffer[position] != rune('\r') {
									goto l164
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l164
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l164
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l164
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l164
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l164
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l164
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l164
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l164
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l164
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l164
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l164
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l164
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l164
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l164
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l164
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l164
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l164
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l164
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l164
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l164
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l164
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l164
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l164
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l164
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l164
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l164
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l164
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l164
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l164
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l164
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l164
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l164
								}
								position++
							}
						}

						goto l161
					l164:
						position, tokenIndex = position164, tokenIndex164
					}
					if !matchDot() {
						goto l161
					}
				l166:
					{
						position167, tokenIndex167 := position, tokenIndex
						{
							position168, tokenIndex168 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l168
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l168
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l168
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l168
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l168
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l168
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l168
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l168
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l168
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l168
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l168
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l168
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l168
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l168
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l168
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l168
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l168
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l168
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l168
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l168
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l168
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l168
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l168
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l168
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l168
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l168
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l168
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l168
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l168
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l168
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l168
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l168
									}
									position++
								}
							}

							goto l167
						l168:
							position, tokenIndex = position168, tokenIndex168
						}
						if !matchDot() {
							goto l167
						}
						goto l166
					l167:
						position, tokenIndex = position167, tokenIndex167
					}
					add(rulePegText, position163)
				}
				if !_rules[rulesp]() {
					goto l161
				}
				add(ruleidentifier, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 14 sub <- <(open e1 close)> */
		nil,
		/* 15 add <- <('+' sp)> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				if buffer[position] != rune('+') {
					goto l171
				}
				position++
				if !_rules[rulesp]() {
					goto l171
				}
				add(ruleadd, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 16 minus <- <('-' sp)> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('-') {
					goto l173
				}
				position++
				if !_rules[rulesp]() {
					goto l173
				}
				add(ruleminus, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 17 multiply <- <('*' sp)> */
		nil,
		/* 18 divide <- <('/' sp)> */
		nil,
		/* 19 modulus <- <('%' sp)> */
		nil,
		/* 20 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 21 open <- <('(' sp)> */
		nil,
		/* 22 close <- <(')' sp)> */
		nil,
		/* 23 sp <- <(' ' / '\t')*> */
		func() bool {
			{
				position182 := position
			l183:
				{
					position184, tokenIndex184 := position, tokenIndex
					{
						position185, tokenIndex185 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l186
						}
						position++
						goto l185
					l186:
						position, tokenIndex = position185, tokenIndex185
						if buffer[position] != rune('\t') {
							goto l184
						}
						position++
					}
				l185:
					goto l183
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
				add(rulesp, position182)
			}
			return true
		},
		/* 24 fstring <- <('`' <(('{' sp e1 sp '}') / escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('`') '`')) .))*> '`' sp Action31)> */
		nil,
		/* 25 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 27 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 28 Action1 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 29 Action2 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 30 Action3 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 31 Action4 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 32 Action5 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 33 Action6 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 34 Action7 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 35 Action8 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 36 Action9 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 37 Action10 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 38 Action11 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 39 Action12 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 40 Action13 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 41 Action14 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 42 Action15 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 43 Action16 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 44 Action17 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 45 Action18 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 46 Action19 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 47 Action20 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 48 Action21 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 49 Action22 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 50 Action23 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 51 Action24 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 52 Action25 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 53 Action26 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 54 Action27 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 56 Action28 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 57 Action29 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 58 Action30 <- <{ p.AddStore() }> */
		nil,
		/* 59 Action31 <- <{ p.AddFormatString(string(text)) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
