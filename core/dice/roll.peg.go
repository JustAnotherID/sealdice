package dice

// Code generated by C:\Users\fy0\go\bin\peg.exe -switch -inline dice/roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleeBase
	rulee
	ruleeOne
	ruleassign_expr
	rules0
	ruleblock
	rulestmtElse
	rulestmtIf
	rulee0
	ruleeSimpleSwitch
	ruleeTernary
	ruleeBitwise
	ruleeComp
	rulee1
	rulee2
	rulee3
	rulee4
	rulee5
	ruledndDiceSuffix
	rulekqDiceOp
	rule_dnumber
	rulesimpleDice2
	rulewodDicePool
	ruledoubleCrossDicePool
	ruleeDice
	rulelaNumberOrLeftParen
	ruleeDice2
	ruleeDice3
	ruleeDice4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulebitwiseOr
	rulelogicOr
	rulebitwiseAnd
	rulelogicAnd
	rulesp
	rulelt
	rulegt
	rulele
	rulege
	ruleeq
	rulene
	rulestrPart
	rulestrPart1
	rulestrPart2
	rulestrPart3
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
	ruleAction71
	ruleAction72
	ruleAction73
	ruleAction74
	ruleAction75
	rulePegText
	ruleAction76
	ruleAction77
	ruleAction78
	ruleAction79
	ruleAction80
	ruleAction81
	ruleAction82
	ruleAction83
	ruleAction84
	ruleAction85
	ruleAction86
	ruleAction87
	ruleAction88
	ruleAction89
	ruleAction90
	ruleAction91
	ruleAction92
)

var rul3s = [...]string{
	"Unknown",
	"eBase",
	"e",
	"eOne",
	"assign_expr",
	"s0",
	"block",
	"stmtElse",
	"stmtIf",
	"e0",
	"eSimpleSwitch",
	"eTernary",
	"eBitwise",
	"eComp",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"dndDiceSuffix",
	"kqDiceOp",
	"_dnumber",
	"simpleDice2",
	"wodDicePool",
	"doubleCrossDicePool",
	"eDice",
	"laNumberOrLeftParen",
	"eDice2",
	"eDice3",
	"eDice4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"bitwiseOr",
	"logicOr",
	"bitwiseAnd",
	"logicAnd",
	"sp",
	"lt",
	"gt",
	"le",
	"ge",
	"eq",
	"ne",
	"strPart",
	"strPart1",
	"strPart2",
	"strPart3",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
	"Action71",
	"Action72",
	"Action73",
	"Action74",
	"Action75",
	"PegText",
	"Action76",
	"Action77",
	"Action78",
	"Action79",
	"Action80",
	"Action81",
	"Action82",
	"Action83",
	"Action84",
	"Action85",
	"Action86",
	"Action87",
	"Action88",
	"Action89",
	"Action90",
	"Action91",
	"Action92",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [153]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddOperator(TypeClearDetail)
		case ruleAction2:
			p.AddValueStr(string(text))
		case ruleAction3:
			p.AddStore()
		case ruleAction4:
			p.AddOperator(TypePop)
		case ruleAction5:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction6:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction7:
			p.PopAndSetOffset()
		case ruleAction8:
			p.AddValueStr("")
		case ruleAction9:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction10:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction11:
			p.AddOperator(TypeJne)
			p.PushForOffset()
		case ruleAction12:
			p.AddOperator(TypeJmp)
			p.PopAndSetOffset()
			p.PushForOffset()
		case ruleAction13:
			p.PopAndSetOffset()
		case ruleAction14:
			p.CounterPush()
		case ruleAction15:
			p.CounterAdd(1)
		case ruleAction16:
			p.AddValueStr("")
			limit := p.CounterPop() + 1
			for i := int64(0); i < limit; i++ {
				p.PopAndSetOffset()
			}
		case ruleAction17:
			p.AddLeftValueMark()
		case ruleAction18:
			p.AddOperator(TypeBitwiseOr)
		case ruleAction19:
			p.AddLeftValueMark()
		case ruleAction20:
			p.AddOperator(TypeBitwiseAnd)
		case ruleAction21:
			p.AddLeftValueMark()
		case ruleAction22:
			p.AddOperator(TypeCompLT)
		case ruleAction23:
			p.AddLeftValueMark()
		case ruleAction24:
			p.AddOperator(TypeCompLE)
		case ruleAction25:
			p.AddLeftValueMark()
		case ruleAction26:
			p.AddOperator(TypeCompEQ)
		case ruleAction27:
			p.AddLeftValueMark()
		case ruleAction28:
			p.AddOperator(TypeCompNE)
		case ruleAction29:
			p.AddLeftValueMark()
		case ruleAction30:
			p.AddOperator(TypeCompGE)
		case ruleAction31:
			p.AddLeftValueMark()
		case ruleAction32:
			p.AddOperator(TypeCompGT)
		case ruleAction33:
			p.AddLeftValueMark()
		case ruleAction34:
			p.AddOperator(TypeAdd)
		case ruleAction35:
			p.AddLeftValueMark()
		case ruleAction36:
			p.AddOperator(TypeSubtract)
		case ruleAction37:
			p.AddLeftValueMark()
		case ruleAction38:
			p.AddOperator(TypeMultiply)
		case ruleAction39:
			p.AddLeftValueMark()
		case ruleAction40:
			p.AddOperator(TypeDivide)
		case ruleAction41:
			p.AddLeftValueMark()
		case ruleAction42:
			p.AddOperator(TypeModulus)
		case ruleAction43:
			p.AddLeftValueMark()
		case ruleAction44:
			p.AddOperator(TypeExponentiation)
		case ruleAction45:
			p.AddOperator(TypeNegation)
		case ruleAction46:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetK)
		case ruleAction47:
			p.AddValue("1")
			p.AddOperator(TypeDiceSetQ)
		case ruleAction48:
			p.AddOperator(TypeDiceSetK)
		case ruleAction49:
			p.AddOperator(TypeDiceSetQ)
		case ruleAction50:
			p.AddOperatorWithInt64(TypeDiceSetK, 1)
		case ruleAction51:
			p.AddOperatorWithInt64(TypeDiceSetQ, 1)
		case ruleAction52:
			p.AddOperator(TypeWodSetInit)
		case ruleAction53:
			p.AddOperator(TypeWodSetPool)
		case ruleAction54:
			p.AddOperator(TypeDCSetInit)
		case ruleAction55:
			p.AddOperator(TypeDCSetPool)
		case ruleAction56:
			p.AddValue("2")
			p.AddLeftValueMark()
		case ruleAction57:
			p.AddOperator(TypeDice)
		case ruleAction58:
			p.AddValue("1")
			p.AddLeftValueMark()
		case ruleAction59:
			p.AddOperator(TypeDice)
		case ruleAction60:
			p.AddValue("2")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction61:
			p.AddValue("1")
			p.AddLeftValueMark()
			p.AddValue("0")
			p.AddOperator(TypeDice)
		case ruleAction62:
			p.AddOperator(TypeWodSetPoints)
		case ruleAction63:
			p.AddOperator(TypeWodSetThreshold)
		case ruleAction64:
			p.AddOperator(TypeWodSetThresholdQ)
		case ruleAction65:
			p.AddOperator(TypeDiceWod)
		case ruleAction66:
			p.AddOperator(TypeDCSetPoints)
		case ruleAction67:
			p.AddOperator(TypeDiceDC)
		case ruleAction68:
			p.AddLeftValueMark()
		case ruleAction69:
			p.AddOperator(TypeDice)
		case ruleAction70:
			p.AddOperator(TypeDicePenalty)
		case ruleAction71:
			p.AddValue("1")
			p.AddOperator(TypeDicePenalty)
		case ruleAction72:
			p.AddOperator(TypeDiceBonus)
		case ruleAction73:
			p.AddValue("1")
			p.AddOperator(TypeDiceBonus)
		case ruleAction74:
			p.AddValue("0")
			p.AddValue("0")
			p.AddOperator(TypeDiceFate)
		case ruleAction75:
			p.AddLoadVarname(string(text))
		case ruleAction76:
			p.AddValue(string(text))
		case ruleAction77:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction78:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction79:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction80:
			p.AddValueStr(string(text))
			p.CounterAdd(1)
		case ruleAction81:
			p.CounterPush()
		case ruleAction82:
			p.CounterAdd(1)
		case ruleAction83:
			p.CounterAdd(1)
		case ruleAction84:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction85:
			p.CounterPush()
		case ruleAction86:
			p.CounterAdd(1)
		case ruleAction87:
			p.CounterAdd(1)
		case ruleAction88:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction89:
			p.CounterPush()
		case ruleAction90:
			p.AddFormatString(string(text), p.CounterPop())
		case ruleAction91:
			p.CounterPush()
		case ruleAction92:
			p.AddFormatString(string(text), p.CounterPop())

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 eBase <- <(e Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulee]() {
					goto l0
				}
				{
					add(ruleAction0, position)
				}
				add(ruleeBase, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e <- <(eOne (';' sp Action1 eOne?)*)> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				if !_rules[ruleeOne]() {
					goto l3
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if buffer[position] != rune(';') {
						goto l6
					}
					position++
					if !_rules[rulesp]() {
						goto l6
					}
					{
						add(ruleAction1, position)
					}
					{
						position8, tokenIndex8 := position, tokenIndex
						if !_rules[ruleeOne]() {
							goto l8
						}
						goto l9
					l8:
						position, tokenIndex = position8, tokenIndex8
					}
				l9:
					goto l5
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(rulee, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 eOne <- <(sp (s0 / e0 / assign_expr))> */
		func() bool {
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[rulesp]() {
					goto l10
				}
				{
					position12, tokenIndex12 := position, tokenIndex
					{
						position14 := position
						{
							position15 := position
							if buffer[position] != rune('i') {
								goto l13
							}
							position++
							if buffer[position] != rune('f') {
								goto l13
							}
							position++
							if !_rules[rulesp]() {
								goto l13
							}
							if !_rules[rulee0]() {
								goto l13
							}
							{
								add(ruleAction5, position)
							}
							if !_rules[ruleblock]() {
								goto l13
							}
							{
								add(ruleAction6, position)
							}
							{
								position18, tokenIndex18 := position, tokenIndex
								{
									position20 := position
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if buffer[position] != rune('l') {
										goto l18
									}
									position++
									if buffer[position] != rune('s') {
										goto l18
									}
									position++
									if buffer[position] != rune('e') {
										goto l18
									}
									position++
									if !_rules[rulesp]() {
										goto l18
									}
									if !_rules[ruleblock]() {
										goto l18
									}
									add(rulestmtElse, position20)
								}
								goto l19
							l18:
								position, tokenIndex = position18, tokenIndex18
							}
						l19:
							{
								add(ruleAction7, position)
							}
							{
								add(ruleAction8, position)
							}
							add(rulestmtIf, position15)
						}
						add(rules0, position14)
					}
					goto l12
				l13:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[rulee0]() {
						goto l23
					}
					goto l12
				l23:
					position, tokenIndex = position12, tokenIndex12
					if !_rules[ruleassign_expr]() {
						goto l10
					}
				}
			l12:
				add(ruleeOne, position11)
			}
			return true
		l10:
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 assign_expr <- <(identifier Action2 '=' sp e0 Action3)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if !_rules[ruleidentifier]() {
					goto l24
				}
				{
					add(ruleAction2, position)
				}
				if buffer[position] != rune('=') {
					goto l24
				}
				position++
				if !_rules[rulesp]() {
					goto l24
				}
				if !_rules[rulee0]() {
					goto l24
				}
				{
					add(ruleAction3, position)
				}
				add(ruleassign_expr, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 4 s0 <- <stmtIf> */
		nil,
		/* 5 block <- <((('{' sp '}') / ('{' sp e Action4 '}')) sp)> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				{
					position31, tokenIndex31 := position, tokenIndex
					if buffer[position] != rune('{') {
						goto l32
					}
					position++
					if !_rules[rulesp]() {
						goto l32
					}
					if buffer[position] != rune('}') {
						goto l32
					}
					position++
					goto l31
				l32:
					position, tokenIndex = position31, tokenIndex31
					if buffer[position] != rune('{') {
						goto l29
					}
					position++
					if !_rules[rulesp]() {
						goto l29
					}
					if !_rules[rulee]() {
						goto l29
					}
					{
						add(ruleAction4, position)
					}
					if buffer[position] != rune('}') {
						goto l29
					}
					position++
				}
			l31:
				if !_rules[rulesp]() {
					goto l29
				}
				add(ruleblock, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 6 stmtElse <- <('e' 'l' 's' 'e' sp block)> */
		nil,
		/* 7 stmtIf <- <('i' 'f' sp e0 Action5 block Action6 stmtElse? Action7 Action8)> */
		nil,
		/* 8 e0 <- <eTernary> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				{
					position38 := position
					{
						position39, tokenIndex39 := position, tokenIndex
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune('?') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction11, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						if buffer[position] != rune(':') {
							goto l40
						}
						position++
						if !_rules[rulesp]() {
							goto l40
						}
						{
							add(ruleAction12, position)
						}
						if !_rules[ruleeBitwise]() {
							goto l40
						}
						{
							add(ruleAction13, position)
						}
						goto l39
					l40:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeSimpleSwitch]() {
							goto l44
						}
						{
							add(ruleAction14, position)
						}
					l46:
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l47
							}
							position++
							if !_rules[rulesp]() {
								goto l47
							}
							if !_rules[ruleeSimpleSwitch]() {
								goto l47
							}
							{
								add(ruleAction15, position)
							}
							goto l46
						l47:
							position, tokenIndex = position47, tokenIndex47
						}
						{
							add(ruleAction16, position)
						}
						goto l39
					l44:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleeBitwise]() {
							goto l36
						}
					}
				l39:
					add(ruleeTernary, position38)
				}
				add(rulee0, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 9 eSimpleSwitch <- <(eBitwise '?' sp Action9 eBitwise Action10)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				if buffer[position] != rune('?') {
					goto l50
				}
				position++
				if !_rules[rulesp]() {
					goto l50
				}
				{
					add(ruleAction9, position)
				}
				if !_rules[ruleeBitwise]() {
					goto l50
				}
				{
					add(ruleAction10, position)
				}
				add(ruleeSimpleSwitch, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 10 eTernary <- <((eBitwise '?' sp Action11 eBitwise ':' sp Action12 eBitwise Action13) / (eSimpleSwitch Action14 (',' sp eSimpleSwitch Action15)* Action16) / eBitwise)> */
		nil,
		/* 11 eBitwise <- <(eComp (((logicOr / bitwiseOr) Action17 eComp Action18) / ((logicAnd / bitwiseAnd) Action19 eComp Action20))*)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleeComp]() {
					goto l55
				}
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						{
							position61, tokenIndex61 := position, tokenIndex
							{
								position63 := position
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if buffer[position] != rune('|') {
									goto l62
								}
								position++
								if !_rules[rulesp]() {
									goto l62
								}
								add(rulelogicOr, position63)
							}
							goto l61
						l62:
							position, tokenIndex = position61, tokenIndex61
							{
								position64 := position
								if buffer[position] != rune('|') {
									goto l60
								}
								position++
								if !_rules[rulesp]() {
									goto l60
								}
								add(rulebitwiseOr, position64)
							}
						}
					l61:
						{
							add(ruleAction17, position)
						}
						if !_rules[ruleeComp]() {
							goto l60
						}
						{
							add(ruleAction18, position)
						}
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						{
							position67, tokenIndex67 := position, tokenIndex
							{
								position69 := position
								{
									position70, tokenIndex70 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									if buffer[position] != rune('&') {
										goto l71
									}
									position++
									goto l70
								l71:
									position, tokenIndex = position70, tokenIndex70
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
									if buffer[position] != rune('&') {
										goto l68
									}
									position++
									if buffer[position] != rune('a') {
										goto l68
									}
									position++
									if buffer[position] != rune('m') {
										goto l68
									}
									position++
									if buffer[position] != rune('p') {
										goto l68
									}
									position++
									if buffer[position] != rune(';') {
										goto l68
									}
									position++
								}
							l70:
								if !_rules[rulesp]() {
									goto l68
								}
								add(rulelogicAnd, position69)
							}
							goto l67
						l68:
							position, tokenIndex = position67, tokenIndex67
							{
								position72 := position
								{
									position73, tokenIndex73 := position, tokenIndex
									if buffer[position] != rune('&') {
										goto l74
									}
									position++
									goto l73
								l74:
									position, tokenIndex = position73, tokenIndex73
									if buffer[position] != rune('&') {
										goto l58
									}
									position++
									if buffer[position] != rune('a') {
										goto l58
									}
									position++
									if buffer[position] != rune('m') {
										goto l58
									}
									position++
									if buffer[position] != rune('p') {
										goto l58
									}
									position++
									if buffer[position] != rune(';') {
										goto l58
									}
									position++
								}
							l73:
								if !_rules[rulesp]() {
									goto l58
								}
								add(rulebitwiseAnd, position72)
							}
						}
					l67:
						{
							add(ruleAction19, position)
						}
						if !_rules[ruleeComp]() {
							goto l58
						}
						{
							add(ruleAction20, position)
						}
					}
				l59:
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(ruleeBitwise, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 12 eComp <- <(e1 ((lt Action21 e1 Action22) / (ge Action29 e1 Action30) / ((&('>') (gt Action31 e1 Action32)) | (&('!') (ne Action27 e1 Action28)) | (&('=') (eq Action25 e1 Action26)) | (&('<') (le Action23 e1 Action24))))*)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if !_rules[rulee1]() {
					goto l77
				}
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					{
						position81, tokenIndex81 := position, tokenIndex
						{
							position83 := position
							{
								position84, tokenIndex84 := position, tokenIndex
								if buffer[position] != rune('<') {
									goto l85
								}
								position++
								goto l84
							l85:
								position, tokenIndex = position84, tokenIndex84
								if buffer[position] != rune('＜') {
									goto l82
								}
								position++
							}
						l84:
							if !_rules[rulesp]() {
								goto l82
							}
							add(rulelt, position83)
						}
						{
							add(ruleAction21, position)
						}
						if !_rules[rulee1]() {
							goto l82
						}
						{
							add(ruleAction22, position)
						}
						goto l81
					l82:
						position, tokenIndex = position81, tokenIndex81
						{
							position89 := position
							{
								position90, tokenIndex90 := position, tokenIndex
								if buffer[position] != rune('>') {
									goto l91
								}
								position++
								if buffer[position] != rune('=') {
									goto l91
								}
								position++
								goto l90
							l91:
								position, tokenIndex = position90, tokenIndex90
								if buffer[position] != rune('＞') {
									goto l88
								}
								position++
								if buffer[position] != rune('＝') {
									goto l88
								}
								position++
							}
						l90:
							if !_rules[rulesp]() {
								goto l88
							}
							add(rulege, position89)
						}
						{
							add(ruleAction29, position)
						}
						if !_rules[rulee1]() {
							goto l88
						}
						{
							add(ruleAction30, position)
						}
						goto l81
					l88:
						position, tokenIndex = position81, tokenIndex81
						{
							switch buffer[position] {
							case '>':
								{
									position95 := position
									{
										position96, tokenIndex96 := position, tokenIndex
										if buffer[position] != rune('>') {
											goto l97
										}
										position++
										goto l96
									l97:
										position, tokenIndex = position96, tokenIndex96
										if buffer[position] != rune('＞') {
											goto l80
										}
										position++
									}
								l96:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulegt, position95)
								}
								{
									add(ruleAction31, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction32, position)
								}
							case '!':
								{
									position100 := position
									{
										position101, tokenIndex101 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l102
										}
										position++
										if buffer[position] != rune('=') {
											goto l102
										}
										position++
										goto l101
									l102:
										position, tokenIndex = position101, tokenIndex101
										if buffer[position] != rune('！') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l101:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulene, position100)
								}
								{
									add(ruleAction27, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction28, position)
								}
							case '=':
								{
									position105 := position
									{
										position106, tokenIndex106 := position, tokenIndex
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										if buffer[position] != rune('=') {
											goto l107
										}
										position++
										goto l106
									l107:
										position, tokenIndex = position106, tokenIndex106
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l106:
									if !_rules[rulesp]() {
										goto l80
									}
									add(ruleeq, position105)
								}
								{
									add(ruleAction25, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction26, position)
								}
							default:
								{
									position110 := position
									{
										position111, tokenIndex111 := position, tokenIndex
										if buffer[position] != rune('<') {
											goto l112
										}
										position++
										if buffer[position] != rune('=') {
											goto l112
										}
										position++
										goto l111
									l112:
										position, tokenIndex = position111, tokenIndex111
										if buffer[position] != rune('＜') {
											goto l80
										}
										position++
										if buffer[position] != rune('＝') {
											goto l80
										}
										position++
									}
								l111:
									if !_rules[rulesp]() {
										goto l80
									}
									add(rulele, position110)
								}
								{
									add(ruleAction23, position)
								}
								if !_rules[rulee1]() {
									goto l80
								}
								{
									add(ruleAction24, position)
								}
							}
						}

					}
				l81:
					goto l79
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
				add(ruleeComp, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 13 e1 <- <(e2 ((add Action33 e2 Action34) / (minus Action35 e2 Action36))*)> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				if !_rules[rulee2]() {
					goto l115
				}
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					{
						position119, tokenIndex119 := position, tokenIndex
						if !_rules[ruleadd]() {
							goto l120
						}
						{
							add(ruleAction33, position)
						}
						if !_rules[rulee2]() {
							goto l120
						}
						{
							add(ruleAction34, position)
						}
						goto l119
					l120:
						position, tokenIndex = position119, tokenIndex119
						if !_rules[ruleminus]() {
							goto l118
						}
						{
							add(ruleAction35, position)
						}
						if !_rules[rulee2]() {
							goto l118
						}
						{
							add(ruleAction36, position)
						}
					}
				l119:
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(rulee1, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 14 e2 <- <(e3 ((&('%') (modulus Action41 e3 Action42)) | (&('/') (divide Action39 e3 Action40)) | (&('*') (multiply Action37 e3 Action38)))*)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				if !_rules[rulee3]() {
					goto l125
				}
			l127:
				{
					position128, tokenIndex128 := position, tokenIndex
					{
						switch buffer[position] {
						case '%':
							{
								position130 := position
								if buffer[position] != rune('%') {
									goto l128
								}
								position++
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemodulus, position130)
							}
							{
								add(ruleAction41, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction42, position)
							}
						case '/':
							{
								position133 := position
								{
									position134, tokenIndex134 := position, tokenIndex
									if buffer[position] != rune('/') {
										goto l135
									}
									position++
									goto l134
								l135:
									position, tokenIndex = position134, tokenIndex134
									if buffer[position] != rune('／') {
										goto l128
									}
									position++
								}
							l134:
								if !_rules[rulesp]() {
									goto l128
								}
								add(ruledivide, position133)
							}
							{
								add(ruleAction39, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction40, position)
							}
						default:
							{
								position138 := position
								{
									position139, tokenIndex139 := position, tokenIndex
									if buffer[position] != rune('*') {
										goto l140
									}
									position++
									goto l139
								l140:
									position, tokenIndex = position139, tokenIndex139
									if buffer[position] != rune('＊') {
										goto l128
									}
									position++
								}
							l139:
								if !_rules[rulesp]() {
									goto l128
								}
								add(rulemultiply, position138)
							}
							{
								add(ruleAction37, position)
							}
							if !_rules[rulee3]() {
								goto l128
							}
							{
								add(ruleAction38, position)
							}
						}
					}

					goto l127
				l128:
					position, tokenIndex = position128, tokenIndex128
				}
				add(rulee2, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 15 e3 <- <(e4 (exponentiation Action43 e4 Action44)*)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if !_rules[rulee4]() {
					goto l143
				}
			l145:
				{
					position146, tokenIndex146 := position, tokenIndex
					{
						position147 := position
						{
							position148, tokenIndex148 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l149
							}
							position++
							if !_rules[rulesp]() {
								goto l149
							}
							goto l148
						l149:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if buffer[position] != rune('*') {
								goto l146
							}
							position++
							if !_rules[rulesp]() {
								goto l146
							}
						}
					l148:
						add(ruleexponentiation, position147)
					}
					{
						add(ruleAction43, position)
					}
					if !_rules[rulee4]() {
						goto l146
					}
					{
						add(ruleAction44, position)
					}
					goto l145
				l146:
					position, tokenIndex = position146, tokenIndex146
				}
				add(rulee3, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 16 e4 <- <((minus e5 Action45) / e5)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l155
					}
					if !_rules[rulee5]() {
						goto l155
					}
					{
						add(ruleAction45, position)
					}
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[rulee5]() {
						goto l152
					}
				}
			l154:
				add(rulee4, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 17 e5 <- <((add eDice) / eDice)> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				{
					position159, tokenIndex159 := position, tokenIndex
					if !_rules[ruleadd]() {
						goto l160
					}
					if !_rules[ruleeDice]() {
						goto l160
					}
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if !_rules[ruleeDice]() {
						goto l157
					}
				}
			l159:
				add(rulee5, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 18 dndDiceSuffix <- <(((('优' '势') / ('k' 'h')) Action46 sp) / ((('劣' '势') / ('k' 'l')) Action47 sp))> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position163, tokenIndex163 := position, tokenIndex
					{
						position165, tokenIndex165 := position, tokenIndex
						if buffer[position] != rune('优') {
							goto l166
						}
						position++
						if buffer[position] != rune('势') {
							goto l166
						}
						position++
						goto l165
					l166:
						position, tokenIndex = position165, tokenIndex165
						if buffer[position] != rune('k') {
							goto l164
						}
						position++
						if buffer[position] != rune('h') {
							goto l164
						}
						position++
					}
				l165:
					{
						add(ruleAction46, position)
					}
					if !_rules[rulesp]() {
						goto l164
					}
					goto l163
				l164:
					position, tokenIndex = position163, tokenIndex163
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != rune('劣') {
							goto l169
						}
						position++
						if buffer[position] != rune('势') {
							goto l169
						}
						position++
						goto l168
					l169:
						position, tokenIndex = position168, tokenIndex168
						if buffer[position] != rune('k') {
							goto l161
						}
						position++
						if buffer[position] != rune('l') {
							goto l161
						}
						position++
					}
				l168:
					{
						add(ruleAction47, position)
					}
					if !_rules[rulesp]() {
						goto l161
					}
				}
			l163:
				add(ruledndDiceSuffix, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 19 kqDiceOp <- <(('k' eDice2 Action48)? ('q' eDice2 Action49)? ('d' 'l' eDice2 Action50)? ('d' 'h' eDice2 Action51)?)> */
		func() bool {
			{
				position172 := position
				{
					position173, tokenIndex173 := position, tokenIndex
					if buffer[position] != rune('k') {
						goto l173
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l173
					}
					{
						add(ruleAction48, position)
					}
					goto l174
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
			l174:
				{
					position176, tokenIndex176 := position, tokenIndex
					if buffer[position] != rune('q') {
						goto l176
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l176
					}
					{
						add(ruleAction49, position)
					}
					goto l177
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
			l177:
				{
					position179, tokenIndex179 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l179
					}
					position++
					if buffer[position] != rune('l') {
						goto l179
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l179
					}
					{
						add(ruleAction50, position)
					}
					goto l180
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
			l180:
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l182
					}
					position++
					if buffer[position] != rune('h') {
						goto l182
					}
					position++
					if !_rules[ruleeDice2]() {
						goto l182
					}
					{
						add(ruleAction51, position)
					}
					goto l183
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
			l183:
				add(rulekqDiceOp, position172)
			}
			return true
		},
		/* 20 _dnumber <- <&(('d' / 'D') (number / '('))> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					{
						position188, tokenIndex188 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l189
						}
						position++
						goto l188
					l189:
						position, tokenIndex = position188, tokenIndex188
						if buffer[position] != rune('D') {
							goto l185
						}
						position++
					}
				l188:
					{
						position190, tokenIndex190 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l191
						}
						goto l190
					l191:
						position, tokenIndex = position190, tokenIndex190
						if buffer[position] != rune('(') {
							goto l185
						}
						position++
					}
				l190:
					position, tokenIndex = position187, tokenIndex187
				}
				add(rule_dnumber, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 21 simpleDice2 <- <(&(number / '(') eDice2)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					{
						position195, tokenIndex195 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l196
						}
						goto l195
					l196:
						position, tokenIndex = position195, tokenIndex195
						if buffer[position] != rune('(') {
							goto l192
						}
						position++
					}
				l195:
					position, tokenIndex = position194, tokenIndex194
				}
				if !_rules[ruleeDice2]() {
					goto l192
				}
				add(rulesimpleDice2, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 22 wodDicePool <- <(Action52 (simpleDice2 Action53)?)> */
		nil,
		/* 23 doubleCrossDicePool <- <(Action54 (simpleDice2 Action55))> */
		nil,
		/* 24 eDice <- <((_dnumber ('d' / 'D') Action56 eDice2 dndDiceSuffix Action57) / (_dnumber ('d' / 'D') Action58 eDice2 kqDiceOp Action59) / (('d' / 'D') dndDiceSuffix Action60) / (('d' / 'D') !(!((&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .) sp Action61) / (wodDicePool ('a' / 'A') simpleDice2 ((&('Q' | 'q') (('q' / 'Q') simpleDice2 Action64)) | (&('K' | 'k') (('k' / 'K') simpleDice2 Action63)) | (&('M' | 'm') (('m' / 'M') simpleDice2 Action62)))* Action65) / (doubleCrossDicePool ('c' / 'C') simpleDice2 (('m' / 'M') simpleDice2 Action66)* Action67) / (eDice2 (('d' / 'D') Action68 simpleDice2 kqDiceOp Action69)*))> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[rule_dnumber]() {
						goto l202
					}
					{
						position203, tokenIndex203 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l204
						}
						position++
						goto l203
					l204:
						position, tokenIndex = position203, tokenIndex203
						if buffer[position] != rune('D') {
							goto l202
						}
						position++
					}
				l203:
					{
						add(ruleAction56, position)
					}
					if !_rules[ruleeDice2]() {
						goto l202
					}
					if !_rules[ruledndDiceSuffix]() {
						goto l202
					}
					{
						add(ruleAction57, position)
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[rule_dnumber]() {
						goto l207
					}
					{
						position208, tokenIndex208 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l209
						}
						position++
						goto l208
					l209:
						position, tokenIndex = position208, tokenIndex208
						if buffer[position] != rune('D') {
							goto l207
						}
						position++
					}
				l208:
					{
						add(ruleAction58, position)
					}
					if !_rules[ruleeDice2]() {
						goto l207
					}
					if !_rules[rulekqDiceOp]() {
						goto l207
					}
					{
						add(ruleAction59, position)
					}
					goto l201
				l207:
					position, tokenIndex = position201, tokenIndex201
					{
						position213, tokenIndex213 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l214
						}
						position++
						goto l213
					l214:
						position, tokenIndex = position213, tokenIndex213
						if buffer[position] != rune('D') {
							goto l212
						}
						position++
					}
				l213:
					if !_rules[ruledndDiceSuffix]() {
						goto l212
					}
					{
						add(ruleAction60, position)
					}
					goto l201
				l212:
					position, tokenIndex = position201, tokenIndex201
					{
						position217, tokenIndex217 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l218
						}
						position++
						goto l217
					l218:
						position, tokenIndex = position217, tokenIndex217
						if buffer[position] != rune('D') {
							goto l216
						}
						position++
					}
				l217:
					{
						position219, tokenIndex219 := position, tokenIndex
						{
							position220, tokenIndex220 := position, tokenIndex
							{
								switch buffer[position] {
								case '\r':
									if buffer[position] != rune('\r') {
										goto l220
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l220
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l220
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l220
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l220
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l220
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l220
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l220
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l220
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l220
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l220
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l220
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l220
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l220
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l220
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l220
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l220
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l220
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l220
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l220
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l220
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l220
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l220
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l220
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l220
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l220
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l220
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l220
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l220
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l220
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l220
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l220
									}
									position++
								}
							}

							goto l219
						l220:
							position, tokenIndex = position220, tokenIndex220
						}
						if !matchDot() {
							goto l219
						}
						goto l216
					l219:
						position, tokenIndex = position219, tokenIndex219
					}
					if !_rules[rulesp]() {
						goto l216
					}
					{
						add(ruleAction61, position)
					}
					goto l201
				l216:
					position, tokenIndex = position201, tokenIndex201
					{
						position224 := position
						{
							add(ruleAction52, position)
						}
						{
							position226, tokenIndex226 := position, tokenIndex
							if !_rules[rulesimpleDice2]() {
								goto l226
							}
							{
								add(ruleAction53, position)
							}
							goto l227
						l226:
							position, tokenIndex = position226, tokenIndex226
						}
					l227:
						add(rulewodDicePool, position224)
					}
					{
						position229, tokenIndex229 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l230
						}
						position++
						goto l229
					l230:
						position, tokenIndex = position229, tokenIndex229
						if buffer[position] != rune('A') {
							goto l223
						}
						position++
					}
				l229:
					if !_rules[rulesimpleDice2]() {
						goto l223
					}
				l231:
					{
						position232, tokenIndex232 := position, tokenIndex
						{
							switch buffer[position] {
							case 'Q', 'q':
								{
									position234, tokenIndex234 := position, tokenIndex
									if buffer[position] != rune('q') {
										goto l235
									}
									position++
									goto l234
								l235:
									position, tokenIndex = position234, tokenIndex234
									if buffer[position] != rune('Q') {
										goto l232
									}
									position++
								}
							l234:
								if !_rules[rulesimpleDice2]() {
									goto l232
								}
								{
									add(ruleAction64, position)
								}
							case 'K', 'k':
								{
									position237, tokenIndex237 := position, tokenIndex
									if buffer[position] != rune('k') {
										goto l238
									}
									position++
									goto l237
								l238:
									position, tokenIndex = position237, tokenIndex237
									if buffer[position] != rune('K') {
										goto l232
									}
									position++
								}
							l237:
								if !_rules[rulesimpleDice2]() {
									goto l232
								}
								{
									add(ruleAction63, position)
								}
							default:
								{
									position240, tokenIndex240 := position, tokenIndex
									if buffer[position] != rune('m') {
										goto l241
									}
									position++
									goto l240
								l241:
									position, tokenIndex = position240, tokenIndex240
									if buffer[position] != rune('M') {
										goto l232
									}
									position++
								}
							l240:
								if !_rules[rulesimpleDice2]() {
									goto l232
								}
								{
									add(ruleAction62, position)
								}
							}
						}

						goto l231
					l232:
						position, tokenIndex = position232, tokenIndex232
					}
					{
						add(ruleAction65, position)
					}
					goto l201
				l223:
					position, tokenIndex = position201, tokenIndex201
					{
						position245 := position
						{
							add(ruleAction54, position)
						}
						if !_rules[rulesimpleDice2]() {
							goto l244
						}
						{
							add(ruleAction55, position)
						}
						add(ruledoubleCrossDicePool, position245)
					}
					{
						position248, tokenIndex248 := position, tokenIndex
						if buffer[position] != rune('c') {
							goto l249
						}
						position++
						goto l248
					l249:
						position, tokenIndex = position248, tokenIndex248
						if buffer[position] != rune('C') {
							goto l244
						}
						position++
					}
				l248:
					if !_rules[rulesimpleDice2]() {
						goto l244
					}
				l250:
					{
						position251, tokenIndex251 := position, tokenIndex
						{
							position252, tokenIndex252 := position, tokenIndex
							if buffer[position] != rune('m') {
								goto l253
							}
							position++
							goto l252
						l253:
							position, tokenIndex = position252, tokenIndex252
							if buffer[position] != rune('M') {
								goto l251
							}
							position++
						}
					l252:
						if !_rules[rulesimpleDice2]() {
							goto l251
						}
						{
							add(ruleAction66, position)
						}
						goto l250
					l251:
						position, tokenIndex = position251, tokenIndex251
					}
					{
						add(ruleAction67, position)
					}
					goto l201
				l244:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[ruleeDice2]() {
						goto l199
					}
				l256:
					{
						position257, tokenIndex257 := position, tokenIndex
						{
							position258, tokenIndex258 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l259
							}
							position++
							goto l258
						l259:
							position, tokenIndex = position258, tokenIndex258
							if buffer[position] != rune('D') {
								goto l257
							}
							position++
						}
					l258:
						{
							add(ruleAction68, position)
						}
						if !_rules[rulesimpleDice2]() {
							goto l257
						}
						if !_rules[rulekqDiceOp]() {
							goto l257
						}
						{
							add(ruleAction69, position)
						}
						goto l256
					l257:
						position, tokenIndex = position257, tokenIndex257
					}
				}
			l201:
				add(ruleeDice, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 25 laNumberOrLeftParen <- <&(number / '(')> */
		func() bool {
			position262, tokenIndex262 := position, tokenIndex
			{
				position263 := position
				{
					position264, tokenIndex264 := position, tokenIndex
					{
						position265, tokenIndex265 := position, tokenIndex
						if !_rules[rulenumber]() {
							goto l266
						}
						goto l265
					l266:
						position, tokenIndex = position265, tokenIndex265
						if buffer[position] != rune('(') {
							goto l262
						}
						position++
					}
				l265:
					position, tokenIndex = position264, tokenIndex264
				}
				add(rulelaNumberOrLeftParen, position263)
			}
			return true
		l262:
			position, tokenIndex = position262, tokenIndex262
			return false
		},
		/* 26 eDice2 <- <((('p' / 'P') laNumberOrLeftParen eDice3 Action70) / (('p' / 'P') Action71) / eDice3)> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				{
					position269, tokenIndex269 := position, tokenIndex
					{
						position271, tokenIndex271 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l272
						}
						position++
						goto l271
					l272:
						position, tokenIndex = position271, tokenIndex271
						if buffer[position] != rune('P') {
							goto l270
						}
						position++
					}
				l271:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l270
					}
					if !_rules[ruleeDice3]() {
						goto l270
					}
					{
						add(ruleAction70, position)
					}
					goto l269
				l270:
					position, tokenIndex = position269, tokenIndex269
					{
						position275, tokenIndex275 := position, tokenIndex
						if buffer[position] != rune('p') {
							goto l276
						}
						position++
						goto l275
					l276:
						position, tokenIndex = position275, tokenIndex275
						if buffer[position] != rune('P') {
							goto l274
						}
						position++
					}
				l275:
					{
						add(ruleAction71, position)
					}
					goto l269
				l274:
					position, tokenIndex = position269, tokenIndex269
					if !_rules[ruleeDice3]() {
						goto l267
					}
				}
			l269:
				add(ruleeDice2, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 27 eDice3 <- <((('b' / 'B') laNumberOrLeftParen value Action72) / (('b' / 'B') Action73) / eDice4)> */
		func() bool {
			position278, tokenIndex278 := position, tokenIndex
			{
				position279 := position
				{
					position280, tokenIndex280 := position, tokenIndex
					{
						position282, tokenIndex282 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l283
						}
						position++
						goto l282
					l283:
						position, tokenIndex = position282, tokenIndex282
						if buffer[position] != rune('B') {
							goto l281
						}
						position++
					}
				l282:
					if !_rules[rulelaNumberOrLeftParen]() {
						goto l281
					}
					if !_rules[rulevalue]() {
						goto l281
					}
					{
						add(ruleAction72, position)
					}
					goto l280
				l281:
					position, tokenIndex = position280, tokenIndex280
					{
						position286, tokenIndex286 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l287
						}
						position++
						goto l286
					l287:
						position, tokenIndex = position286, tokenIndex286
						if buffer[position] != rune('B') {
							goto l285
						}
						position++
					}
				l286:
					{
						add(ruleAction73, position)
					}
					goto l280
				l285:
					position, tokenIndex = position280, tokenIndex280
					{
						position289 := position
						{
							position290, tokenIndex290 := position, tokenIndex
							{
								position292, tokenIndex292 := position, tokenIndex
								if buffer[position] != rune('f') {
									goto l293
								}
								position++
								goto l292
							l293:
								position, tokenIndex = position292, tokenIndex292
								if buffer[position] != rune('F') {
									goto l291
								}
								position++
							}
						l292:
							{
								add(ruleAction74, position)
							}
							goto l290
						l291:
							position, tokenIndex = position290, tokenIndex290
							if !_rules[rulevalue]() {
								goto l278
							}
						}
					l290:
						add(ruleeDice4, position289)
					}
				}
			l280:
				add(ruleeDice3, position279)
			}
			return true
		l278:
			position, tokenIndex = position278, tokenIndex278
			return false
		},
		/* 28 eDice4 <- <((('f' / 'F') Action74) / value)> */
		nil,
		/* 29 value <- <(number / assign_expr / (identifier Action75) / sub / fstring)> */
		func() bool {
			position296, tokenIndex296 := position, tokenIndex
			{
				position297 := position
				{
					position298, tokenIndex298 := position, tokenIndex
					if !_rules[rulenumber]() {
						goto l299
					}
					goto l298
				l299:
					position, tokenIndex = position298, tokenIndex298
					if !_rules[ruleassign_expr]() {
						goto l300
					}
					goto l298
				l300:
					position, tokenIndex = position298, tokenIndex298
					if !_rules[ruleidentifier]() {
						goto l301
					}
					{
						add(ruleAction75, position)
					}
					goto l298
				l301:
					position, tokenIndex = position298, tokenIndex298
					{
						position304 := position
						{
							position305 := position
							if buffer[position] != rune('(') {
								goto l303
							}
							position++
							if !_rules[rulesp]() {
								goto l303
							}
							add(ruleopen, position305)
						}
						if !_rules[rulee0]() {
							goto l303
						}
						{
							position306 := position
							if buffer[position] != rune(')') {
								goto l303
							}
							position++
							add(ruleclose, position306)
						}
						add(rulesub, position304)
					}
					goto l298
				l303:
					position, tokenIndex = position298, tokenIndex298
					{
						position307 := position
						{
							switch buffer[position] {
							case '\'':
								if buffer[position] != rune('\'') {
									goto l296
								}
								position++
								{
									add(ruleAction91, position)
								}
								{
									position310 := position
								l311:
									{
										position312, tokenIndex312 := position, tokenIndex
										{
											position313 := position
											{
												position314 := position
												{
													position317, tokenIndex317 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l318
													}
													goto l317
												l318:
													position, tokenIndex = position317, tokenIndex317
													{
														position319, tokenIndex319 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l319
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l319
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l319
																}
																position++
															case '\'':
																if buffer[position] != rune('\'') {
																	goto l319
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l319
																}
																position++
															}
														}

														goto l312
													l319:
														position, tokenIndex = position319, tokenIndex319
													}
													if !matchDot() {
														goto l312
													}
												}
											l317:
											l315:
												{
													position316, tokenIndex316 := position, tokenIndex
													{
														position321, tokenIndex321 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l322
														}
														goto l321
													l322:
														position, tokenIndex = position321, tokenIndex321
														{
															position323, tokenIndex323 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l323
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l323
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l323
																	}
																	position++
																case '\'':
																	if buffer[position] != rune('\'') {
																		goto l323
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l323
																	}
																	position++
																}
															}

															goto l316
														l323:
															position, tokenIndex = position323, tokenIndex323
														}
														if !matchDot() {
															goto l316
														}
													}
												l321:
													goto l315
												l316:
													position, tokenIndex = position316, tokenIndex316
												}
												add(rulePegText, position314)
											}
											{
												add(ruleAction80, position)
											}
											add(rulestrPart3, position313)
										}
										goto l311
									l312:
										position, tokenIndex = position312, tokenIndex312
									}
									add(rulePegText, position310)
								}
								if buffer[position] != rune('\'') {
									goto l296
								}
								position++
								{
									add(ruleAction92, position)
								}
							case '"':
								if buffer[position] != rune('"') {
									goto l296
								}
								position++
								{
									add(ruleAction89, position)
								}
								{
									position328 := position
								l329:
									{
										position330, tokenIndex330 := position, tokenIndex
										{
											position331 := position
											{
												position332 := position
												{
													position335, tokenIndex335 := position, tokenIndex
													if !_rules[ruleescape]() {
														goto l336
													}
													goto l335
												l336:
													position, tokenIndex = position335, tokenIndex335
													{
														position337, tokenIndex337 := position, tokenIndex
														{
															switch buffer[position] {
															case '\r':
																if buffer[position] != rune('\r') {
																	goto l337
																}
																position++
															case '\n':
																if buffer[position] != rune('\n') {
																	goto l337
																}
																position++
															case '\\':
																if buffer[position] != rune('\\') {
																	goto l337
																}
																position++
															case '"':
																if buffer[position] != rune('"') {
																	goto l337
																}
																position++
															default:
																if buffer[position] != rune('{') {
																	goto l337
																}
																position++
															}
														}

														goto l330
													l337:
														position, tokenIndex = position337, tokenIndex337
													}
													if !matchDot() {
														goto l330
													}
												}
											l335:
											l333:
												{
													position334, tokenIndex334 := position, tokenIndex
													{
														position339, tokenIndex339 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l340
														}
														goto l339
													l340:
														position, tokenIndex = position339, tokenIndex339
														{
															position341, tokenIndex341 := position, tokenIndex
															{
																switch buffer[position] {
																case '\r':
																	if buffer[position] != rune('\r') {
																		goto l341
																	}
																	position++
																case '\n':
																	if buffer[position] != rune('\n') {
																		goto l341
																	}
																	position++
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l341
																	}
																	position++
																case '"':
																	if buffer[position] != rune('"') {
																		goto l341
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l341
																	}
																	position++
																}
															}

															goto l334
														l341:
															position, tokenIndex = position341, tokenIndex341
														}
														if !matchDot() {
															goto l334
														}
													}
												l339:
													goto l333
												l334:
													position, tokenIndex = position334, tokenIndex334
												}
												add(rulePegText, position332)
											}
											{
												add(ruleAction79, position)
											}
											add(rulestrPart2, position331)
										}
										goto l329
									l330:
										position, tokenIndex = position330, tokenIndex330
									}
									add(rulePegText, position328)
								}
								if buffer[position] != rune('"') {
									goto l296
								}
								position++
								{
									add(ruleAction90, position)
								}
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l296
								}
								position++
								{
									add(ruleAction85, position)
								}
								{
									position346 := position
								l347:
									{
										position348, tokenIndex348 := position, tokenIndex
										{
											position349, tokenIndex349 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l350
											}
											position++
											if !_rules[rulesp]() {
												goto l350
											}
											if !_rules[rulee]() {
												goto l350
											}
											{
												add(ruleAction86, position)
											}
											if buffer[position] != rune('}') {
												goto l350
											}
											position++
											goto l349
										l350:
											position, tokenIndex = position349, tokenIndex349
											if buffer[position] != rune('{') {
												goto l352
											}
											position++
											if buffer[position] != rune('%') {
												goto l352
											}
											position++
											if !_rules[rulesp]() {
												goto l352
											}
											if !_rules[rulee]() {
												goto l352
											}
											{
												add(ruleAction87, position)
											}
											if buffer[position] != rune('%') {
												goto l352
											}
											position++
											if buffer[position] != rune('}') {
												goto l352
											}
											position++
											goto l349
										l352:
											position, tokenIndex = position349, tokenIndex349
											{
												position354 := position
												{
													position355 := position
													{
														position358, tokenIndex358 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l359
														}
														goto l358
													l359:
														position, tokenIndex = position358, tokenIndex358
														{
															position360, tokenIndex360 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l360
																	}
																	position++
																case '\x1e':
																	if buffer[position] != rune('\x1e') {
																		goto l360
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l360
																	}
																	position++
																}
															}

															goto l348
														l360:
															position, tokenIndex = position360, tokenIndex360
														}
														if !matchDot() {
															goto l348
														}
													}
												l358:
												l356:
													{
														position357, tokenIndex357 := position, tokenIndex
														{
															position362, tokenIndex362 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l363
															}
															goto l362
														l363:
															position, tokenIndex = position362, tokenIndex362
															{
																position364, tokenIndex364 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l364
																		}
																		position++
																	case '\x1e':
																		if buffer[position] != rune('\x1e') {
																			goto l364
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l364
																		}
																		position++
																	}
																}

																goto l357
															l364:
																position, tokenIndex = position364, tokenIndex364
															}
															if !matchDot() {
																goto l357
															}
														}
													l362:
														goto l356
													l357:
														position, tokenIndex = position357, tokenIndex357
													}
													add(rulePegText, position355)
												}
												{
													add(ruleAction78, position)
												}
												add(rulestrPart1, position354)
											}
										}
									l349:
										goto l347
									l348:
										position, tokenIndex = position348, tokenIndex348
									}
									add(rulePegText, position346)
								}
								if buffer[position] != rune('\x1e') {
									goto l296
								}
								position++
								{
									add(ruleAction88, position)
								}
							default:
								if buffer[position] != rune('`') {
									goto l296
								}
								position++
								{
									add(ruleAction81, position)
								}
								{
									position369 := position
								l370:
									{
										position371, tokenIndex371 := position, tokenIndex
										{
											position372, tokenIndex372 := position, tokenIndex
											if buffer[position] != rune('{') {
												goto l373
											}
											position++
											if !_rules[rulesp]() {
												goto l373
											}
											if !_rules[rulee]() {
												goto l373
											}
											{
												add(ruleAction82, position)
											}
											if buffer[position] != rune('}') {
												goto l373
											}
											position++
											goto l372
										l373:
											position, tokenIndex = position372, tokenIndex372
											if buffer[position] != rune('{') {
												goto l375
											}
											position++
											if buffer[position] != rune('{') {
												goto l375
											}
											position++
											if !_rules[rulesp]() {
												goto l375
											}
											if !_rules[rulee]() {
												goto l375
											}
											{
												add(ruleAction83, position)
											}
											if buffer[position] != rune('}') {
												goto l375
											}
											position++
											if buffer[position] != rune('}') {
												goto l375
											}
											position++
											goto l372
										l375:
											position, tokenIndex = position372, tokenIndex372
											{
												position377 := position
												{
													position378 := position
													{
														position381, tokenIndex381 := position, tokenIndex
														if !_rules[ruleescape]() {
															goto l382
														}
														goto l381
													l382:
														position, tokenIndex = position381, tokenIndex381
														{
															position383, tokenIndex383 := position, tokenIndex
															{
																switch buffer[position] {
																case '\\':
																	if buffer[position] != rune('\\') {
																		goto l383
																	}
																	position++
																case '`':
																	if buffer[position] != rune('`') {
																		goto l383
																	}
																	position++
																default:
																	if buffer[position] != rune('{') {
																		goto l383
																	}
																	position++
																}
															}

															goto l371
														l383:
															position, tokenIndex = position383, tokenIndex383
														}
														if !matchDot() {
															goto l371
														}
													}
												l381:
												l379:
													{
														position380, tokenIndex380 := position, tokenIndex
														{
															position385, tokenIndex385 := position, tokenIndex
															if !_rules[ruleescape]() {
																goto l386
															}
															goto l385
														l386:
															position, tokenIndex = position385, tokenIndex385
															{
																position387, tokenIndex387 := position, tokenIndex
																{
																	switch buffer[position] {
																	case '\\':
																		if buffer[position] != rune('\\') {
																			goto l387
																		}
																		position++
																	case '`':
																		if buffer[position] != rune('`') {
																			goto l387
																		}
																		position++
																	default:
																		if buffer[position] != rune('{') {
																			goto l387
																		}
																		position++
																	}
																}

																goto l380
															l387:
																position, tokenIndex = position387, tokenIndex387
															}
															if !matchDot() {
																goto l380
															}
														}
													l385:
														goto l379
													l380:
														position, tokenIndex = position380, tokenIndex380
													}
													add(rulePegText, position378)
												}
												{
													add(ruleAction77, position)
												}
												add(rulestrPart, position377)
											}
										}
									l372:
										goto l370
									l371:
										position, tokenIndex = position371, tokenIndex371
									}
									add(rulePegText, position369)
								}
								if buffer[position] != rune('`') {
									goto l296
								}
								position++
								{
									add(ruleAction84, position)
								}
							}
						}

						if !_rules[rulesp]() {
							goto l296
						}
						add(rulefstring, position307)
					}
				}
			l298:
				add(rulevalue, position297)
			}
			return true
		l296:
			position, tokenIndex = position296, tokenIndex296
			return false
		},
		/* 30 number <- <(<[0-9]+> Action76)> */
		func() bool {
			position391, tokenIndex391 := position, tokenIndex
			{
				position392 := position
				{
					position393 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l391
					}
					position++
				l394:
					{
						position395, tokenIndex395 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l395
						}
						position++
						goto l394
					l395:
						position, tokenIndex = position395, tokenIndex395
					}
					add(rulePegText, position393)
				}
				{
					add(ruleAction76, position)
				}
				add(rulenumber, position392)
			}
			return true
		l391:
			position, tokenIndex = position391, tokenIndex391
			return false
		},
		/* 31 identifier <- <(<(!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&(':') ':') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9])) . (!((&('\x1e') '\x1e') | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' ') | (&('~') '~') | (&('}') '}') | (&('|') '|') | (&('{') '{') | (&('`') '`') | (&('^') '^') | (&(']') ']') | (&('\\') '\\') | (&('[') '[') | (&('@') '@') | (&('?') '?') | (&('>') '>') | (&('=') '=') | (&('<') '<') | (&(';') ';') | (&('/') '/') | (&('+') '+') | (&('*') '*') | (&(')') ')') | (&('(') '(') | (&('\'') '\'') | (&('&') '&') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('"') '"') | (&('!') '!') | (&(',' | '-' | '.') [,-.])) .)*)> sp)> */
		func() bool {
			position397, tokenIndex397 := position, tokenIndex
			{
				position398 := position
				{
					position399 := position
					{
						position400, tokenIndex400 := position, tokenIndex
						{
							switch buffer[position] {
							case '\x1e':
								if buffer[position] != rune('\x1e') {
									goto l400
								}
								position++
							case '\r':
								if buffer[position] != rune('\r') {
									goto l400
								}
								position++
							case '\n':
								if buffer[position] != rune('\n') {
									goto l400
								}
								position++
							case '\t':
								if buffer[position] != rune('\t') {
									goto l400
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l400
								}
								position++
							case '~':
								if buffer[position] != rune('~') {
									goto l400
								}
								position++
							case '}':
								if buffer[position] != rune('}') {
									goto l400
								}
								position++
							case '|':
								if buffer[position] != rune('|') {
									goto l400
								}
								position++
							case '{':
								if buffer[position] != rune('{') {
									goto l400
								}
								position++
							case '`':
								if buffer[position] != rune('`') {
									goto l400
								}
								position++
							case '^':
								if buffer[position] != rune('^') {
									goto l400
								}
								position++
							case ']':
								if buffer[position] != rune(']') {
									goto l400
								}
								position++
							case '\\':
								if buffer[position] != rune('\\') {
									goto l400
								}
								position++
							case '[':
								if buffer[position] != rune('[') {
									goto l400
								}
								position++
							case '@':
								if buffer[position] != rune('@') {
									goto l400
								}
								position++
							case '?':
								if buffer[position] != rune('?') {
									goto l400
								}
								position++
							case '>':
								if buffer[position] != rune('>') {
									goto l400
								}
								position++
							case '=':
								if buffer[position] != rune('=') {
									goto l400
								}
								position++
							case '<':
								if buffer[position] != rune('<') {
									goto l400
								}
								position++
							case ';':
								if buffer[position] != rune(';') {
									goto l400
								}
								position++
							case ':':
								if buffer[position] != rune(':') {
									goto l400
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l400
								}
								position++
							case '+':
								if buffer[position] != rune('+') {
									goto l400
								}
								position++
							case '*':
								if buffer[position] != rune('*') {
									goto l400
								}
								position++
							case ')':
								if buffer[position] != rune(')') {
									goto l400
								}
								position++
							case '(':
								if buffer[position] != rune('(') {
									goto l400
								}
								position++
							case '\'':
								if buffer[position] != rune('\'') {
									goto l400
								}
								position++
							case '&':
								if buffer[position] != rune('&') {
									goto l400
								}
								position++
							case '%':
								if buffer[position] != rune('%') {
									goto l400
								}
								position++
							case '#':
								if buffer[position] != rune('#') {
									goto l400
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l400
								}
								position++
							case '!':
								if buffer[position] != rune('!') {
									goto l400
								}
								position++
							case ',', '-', '.':
								if c := buffer[position]; c < rune(',') || c > rune('.') {
									goto l400
								}
								position++
							default:
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l400
								}
								position++
							}
						}

						goto l397
					l400:
						position, tokenIndex = position400, tokenIndex400
					}
					if !matchDot() {
						goto l397
					}
				l402:
					{
						position403, tokenIndex403 := position, tokenIndex
						{
							position404, tokenIndex404 := position, tokenIndex
							{
								switch buffer[position] {
								case '\x1e':
									if buffer[position] != rune('\x1e') {
										goto l404
									}
									position++
								case '\r':
									if buffer[position] != rune('\r') {
										goto l404
									}
									position++
								case '\n':
									if buffer[position] != rune('\n') {
										goto l404
									}
									position++
								case '\t':
									if buffer[position] != rune('\t') {
										goto l404
									}
									position++
								case ' ':
									if buffer[position] != rune(' ') {
										goto l404
									}
									position++
								case '~':
									if buffer[position] != rune('~') {
										goto l404
									}
									position++
								case '}':
									if buffer[position] != rune('}') {
										goto l404
									}
									position++
								case '|':
									if buffer[position] != rune('|') {
										goto l404
									}
									position++
								case '{':
									if buffer[position] != rune('{') {
										goto l404
									}
									position++
								case '`':
									if buffer[position] != rune('`') {
										goto l404
									}
									position++
								case '^':
									if buffer[position] != rune('^') {
										goto l404
									}
									position++
								case ']':
									if buffer[position] != rune(']') {
										goto l404
									}
									position++
								case '\\':
									if buffer[position] != rune('\\') {
										goto l404
									}
									position++
								case '[':
									if buffer[position] != rune('[') {
										goto l404
									}
									position++
								case '@':
									if buffer[position] != rune('@') {
										goto l404
									}
									position++
								case '?':
									if buffer[position] != rune('?') {
										goto l404
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l404
									}
									position++
								case '=':
									if buffer[position] != rune('=') {
										goto l404
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l404
									}
									position++
								case ';':
									if buffer[position] != rune(';') {
										goto l404
									}
									position++
								case '/':
									if buffer[position] != rune('/') {
										goto l404
									}
									position++
								case '+':
									if buffer[position] != rune('+') {
										goto l404
									}
									position++
								case '*':
									if buffer[position] != rune('*') {
										goto l404
									}
									position++
								case ')':
									if buffer[position] != rune(')') {
										goto l404
									}
									position++
								case '(':
									if buffer[position] != rune('(') {
										goto l404
									}
									position++
								case '\'':
									if buffer[position] != rune('\'') {
										goto l404
									}
									position++
								case '&':
									if buffer[position] != rune('&') {
										goto l404
									}
									position++
								case '%':
									if buffer[position] != rune('%') {
										goto l404
									}
									position++
								case '$':
									if buffer[position] != rune('$') {
										goto l404
									}
									position++
								case '#':
									if buffer[position] != rune('#') {
										goto l404
									}
									position++
								case '"':
									if buffer[position] != rune('"') {
										goto l404
									}
									position++
								case '!':
									if buffer[position] != rune('!') {
										goto l404
									}
									position++
								default:
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l404
									}
									position++
								}
							}

							goto l403
						l404:
							position, tokenIndex = position404, tokenIndex404
						}
						if !matchDot() {
							goto l403
						}
						goto l402
					l403:
						position, tokenIndex = position403, tokenIndex403
					}
					add(rulePegText, position399)
				}
				if !_rules[rulesp]() {
					goto l397
				}
				add(ruleidentifier, position398)
			}
			return true
		l397:
			position, tokenIndex = position397, tokenIndex397
			return false
		},
		/* 32 sub <- <(open e0 close)> */
		nil,
		/* 33 add <- <(('+' / '＋') sp)> */
		func() bool {
			position407, tokenIndex407 := position, tokenIndex
			{
				position408 := position
				{
					position409, tokenIndex409 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l410
					}
					position++
					goto l409
				l410:
					position, tokenIndex = position409, tokenIndex409
					if buffer[position] != rune('＋') {
						goto l407
					}
					position++
				}
			l409:
				if !_rules[rulesp]() {
					goto l407
				}
				add(ruleadd, position408)
			}
			return true
		l407:
			position, tokenIndex = position407, tokenIndex407
			return false
		},
		/* 34 minus <- <(('-' / '－') sp)> */
		func() bool {
			position411, tokenIndex411 := position, tokenIndex
			{
				position412 := position
				{
					position413, tokenIndex413 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l414
					}
					position++
					goto l413
				l414:
					position, tokenIndex = position413, tokenIndex413
					if buffer[position] != rune('－') {
						goto l411
					}
					position++
				}
			l413:
				if !_rules[rulesp]() {
					goto l411
				}
				add(ruleminus, position412)
			}
			return true
		l411:
			position, tokenIndex = position411, tokenIndex411
			return false
		},
		/* 35 multiply <- <(('*' / '＊') sp)> */
		nil,
		/* 36 divide <- <(('/' / '／') sp)> */
		nil,
		/* 37 modulus <- <('%' sp)> */
		nil,
		/* 38 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 39 open <- <('(' sp)> */
		nil,
		/* 40 close <- <')'> */
		nil,
		/* 41 bitwiseOr <- <('|' sp)> */
		nil,
		/* 42 logicOr <- <('|' '|' sp)> */
		nil,
		/* 43 bitwiseAnd <- <(('&' / ('&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 44 logicAnd <- <((('&' '&') / ('&' 'a' 'm' 'p' ';' '&' 'a' 'm' 'p' ';')) sp)> */
		nil,
		/* 45 sp <- <((&('/') ('/' '/' (!'\n' .)*)) | (&('\r') '\r') | (&('\n') '\n') | (&('\t') '\t') | (&(' ') ' '))*> */
		func() bool {
			{
				position426 := position
			l427:
				{
					position428, tokenIndex428 := position, tokenIndex
					{
						switch buffer[position] {
						case '/':
							if buffer[position] != rune('/') {
								goto l428
							}
							position++
							if buffer[position] != rune('/') {
								goto l428
							}
							position++
						l430:
							{
								position431, tokenIndex431 := position, tokenIndex
								{
									position432, tokenIndex432 := position, tokenIndex
									if buffer[position] != rune('\n') {
										goto l432
									}
									position++
									goto l431
								l432:
									position, tokenIndex = position432, tokenIndex432
								}
								if !matchDot() {
									goto l431
								}
								goto l430
							l431:
								position, tokenIndex = position431, tokenIndex431
							}
						case '\r':
							if buffer[position] != rune('\r') {
								goto l428
							}
							position++
						case '\n':
							if buffer[position] != rune('\n') {
								goto l428
							}
							position++
						case '\t':
							if buffer[position] != rune('\t') {
								goto l428
							}
							position++
						default:
							if buffer[position] != rune(' ') {
								goto l428
							}
							position++
						}
					}

					goto l427
				l428:
					position, tokenIndex = position428, tokenIndex428
				}
				add(rulesp, position426)
			}
			return true
		},
		/* 46 lt <- <(('<' / '＜') sp)> */
		nil,
		/* 47 gt <- <(('>' / '＞') sp)> */
		nil,
		/* 48 le <- <((('<' '=') / ('＜' '＝')) sp)> */
		nil,
		/* 49 ge <- <((('>' '=') / ('＞' '＝')) sp)> */
		nil,
		/* 50 eq <- <((('=' '=') / ('＝' '＝')) sp)> */
		nil,
		/* 51 ne <- <((('!' '=') / ('！' '＝')) sp)> */
		nil,
		/* 52 strPart <- <(<(escape / (!((&('\\') '\\') | (&('`') '`') | (&('{') '{')) .))+> Action77)> */
		nil,
		/* 53 strPart1 <- <(<(escape / (!((&('\\') '\\') | (&('\x1e') '\x1e') | (&('{') '{')) .))+> Action78)> */
		nil,
		/* 54 strPart2 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('"') '"') | (&('{') '{')) .))+> Action79)> */
		nil,
		/* 55 strPart3 <- <(<(escape / (!((&('\r') '\r') | (&('\n') '\n') | (&('\\') '\\') | (&('\'') '\'') | (&('{') '{')) .))+> Action80)> */
		nil,
		/* 56 fstring <- <(((&('\'') ('\'' Action91 <strPart3*> '\'' Action92)) | (&('"') ('"' Action89 <strPart2*> '"' Action90)) | (&('\x1e') ('\x1e' Action85 <(('{' sp e Action86 '}') / ('{' '%' sp e Action87 ('%' '}')) / strPart1)*> '\x1e' Action88)) | (&('`') ('`' Action81 <(('{' sp e Action82 '}') / ('{' '{' sp e Action83 ('}' '}')) / strPart)*> '`' Action84))) sp)> */
		nil,
		/* 57 escape <- <('\\' ((&('\\') '\\') | (&('\'') '\'') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		func() bool {
			position444, tokenIndex444 := position, tokenIndex
			{
				position445 := position
				if buffer[position] != rune('\\') {
					goto l444
				}
				position++
				{
					switch buffer[position] {
					case '\\':
						if buffer[position] != rune('\\') {
							goto l444
						}
						position++
					case '\'':
						if buffer[position] != rune('\'') {
							goto l444
						}
						position++
					case '"':
						if buffer[position] != rune('"') {
							goto l444
						}
						position++
					case 'r':
						if buffer[position] != rune('r') {
							goto l444
						}
						position++
					case 'f':
						if buffer[position] != rune('f') {
							goto l444
						}
						position++
					case 'n':
						if buffer[position] != rune('n') {
							goto l444
						}
						position++
					case 't':
						if buffer[position] != rune('t') {
							goto l444
						}
						position++
					default:
						if buffer[position] != rune('b') {
							goto l444
						}
						position++
					}
				}

				add(ruleescape, position445)
			}
			return true
		l444:
			position, tokenIndex = position444, tokenIndex444
			return false
		},
		/* 59 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 60 Action1 <- <{ p.AddOperator(TypeClearDetail) }> */
		nil,
		/* 61 Action2 <- <{ p.AddValueStr(string(text)) }> */
		nil,
		/* 62 Action3 <- <{ p.AddStore() }> */
		nil,
		/* 63 Action4 <- <{p.AddOperator(TypePop)}> */
		nil,
		/* 64 Action5 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 65 Action6 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 66 Action7 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 67 Action8 <- <{ p.AddValueStr(""); }> */
		nil,
		/* 68 Action9 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 69 Action10 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); }> */
		nil,
		/* 70 Action11 <- <{ p.AddOperator(TypeJne); p.PushForOffset() }> */
		nil,
		/* 71 Action12 <- <{ p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() }> */
		nil,
		/* 72 Action13 <- <{ p.PopAndSetOffset() }> */
		nil,
		/* 73 Action14 <- <{ p.CounterPush() }> */
		nil,
		/* 74 Action15 <- <{p.CounterAdd(1)}> */
		nil,
		/* 75 Action16 <- <{ p.AddValueStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.PopAndSetOffset() } }> */
		nil,
		/* 76 Action17 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 77 Action18 <- <{ p.AddOperator(TypeBitwiseOr) }> */
		nil,
		/* 78 Action19 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 79 Action20 <- <{ p.AddOperator(TypeBitwiseAnd) }> */
		nil,
		/* 80 Action21 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 81 Action22 <- <{ p.AddOperator(TypeCompLT) }> */
		nil,
		/* 82 Action23 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 83 Action24 <- <{ p.AddOperator(TypeCompLE) }> */
		nil,
		/* 84 Action25 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 85 Action26 <- <{ p.AddOperator(TypeCompEQ) }> */
		nil,
		/* 86 Action27 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 87 Action28 <- <{ p.AddOperator(TypeCompNE) }> */
		nil,
		/* 88 Action29 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 89 Action30 <- <{ p.AddOperator(TypeCompGE) }> */
		nil,
		/* 90 Action31 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 91 Action32 <- <{ p.AddOperator(TypeCompGT) }> */
		nil,
		/* 92 Action33 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 93 Action34 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 94 Action35 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 95 Action36 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 96 Action37 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 97 Action38 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 98 Action39 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 99 Action40 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 100 Action41 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 101 Action42 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 102 Action43 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 103 Action44 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 104 Action45 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 105 Action46 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetK)}> */
		nil,
		/* 106 Action47 <- <{p.AddValue("1"); p.AddOperator(TypeDiceSetQ)}> */
		nil,
		/* 107 Action48 <- <{ p.AddOperator(TypeDiceSetK) }> */
		nil,
		/* 108 Action49 <- <{ p.AddOperator(TypeDiceSetQ) }> */
		nil,
		/* 109 Action50 <- <{ p.AddOperatorWithInt64(TypeDiceSetK, 1) }> */
		nil,
		/* 110 Action51 <- <{ p.AddOperatorWithInt64(TypeDiceSetQ, 1) }> */
		nil,
		/* 111 Action52 <- <{ p.AddOperator(TypeWodSetInit) }> */
		nil,
		/* 112 Action53 <- <{ p.AddOperator(TypeWodSetPool) }> */
		nil,
		/* 113 Action54 <- <{ p.AddOperator(TypeDCSetInit) }> */
		nil,
		/* 114 Action55 <- <{ p.AddOperator(TypeDCSetPool) }> */
		nil,
		/* 115 Action56 <- <{ p.AddValue("2"); p.AddLeftValueMark() }> */
		nil,
		/* 116 Action57 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 117 Action58 <- <{ p.AddValue("1"); p.AddLeftValueMark() }> */
		nil,
		/* 118 Action59 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 119 Action60 <- <{ p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 120 Action61 <- <{ p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }> */
		nil,
		/* 121 Action62 <- <{ p.AddOperator(TypeWodSetPoints) }> */
		nil,
		/* 122 Action63 <- <{ p.AddOperator(TypeWodSetThreshold) }> */
		nil,
		/* 123 Action64 <- <{ p.AddOperator(TypeWodSetThresholdQ) }> */
		nil,
		/* 124 Action65 <- <{ p.AddOperator(TypeDiceWod) }> */
		nil,
		/* 125 Action66 <- <{ p.AddOperator(TypeDCSetPoints) }> */
		nil,
		/* 126 Action67 <- <{ p.AddOperator(TypeDiceDC) }> */
		nil,
		/* 127 Action68 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 128 Action69 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 129 Action70 <- <{ p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 130 Action71 <- <{ p.AddValue("1"); p.AddOperator(TypeDicePenalty) }> */
		nil,
		/* 131 Action72 <- <{ p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 132 Action73 <- <{ p.AddValue("1"); p.AddOperator(TypeDiceBonus) }> */
		nil,
		/* 133 Action74 <- <{ p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) }> */
		nil,
		/* 134 Action75 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 136 Action76 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 137 Action77 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 138 Action78 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 139 Action79 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 140 Action80 <- <{ p.AddValueStr(string(text)); p.CounterAdd(1) }> */
		nil,
		/* 141 Action81 <- <{ p.CounterPush() }> */
		nil,
		/* 142 Action82 <- <{p.CounterAdd(1)}> */
		nil,
		/* 143 Action83 <- <{p.CounterAdd(1)}> */
		nil,
		/* 144 Action84 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 145 Action85 <- <{ p.CounterPush() }> */
		nil,
		/* 146 Action86 <- <{p.CounterAdd(1)}> */
		nil,
		/* 147 Action87 <- <{p.CounterAdd(1)}> */
		nil,
		/* 148 Action88 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 149 Action89 <- <{ p.CounterPush() }> */
		nil,
		/* 150 Action90 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
		/* 151 Action91 <- <{ p.CounterPush() }> */
		nil,
		/* 152 Action92 <- <{ p.AddFormatString(string(text), p.CounterPop()) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
