// part of SealDice project

package dice

type DiceRollParser Peg {
    RollExpression
}

// 实际操作中发现，不匹配句尾比较好 (没有!.)
eBase <- e { p.AddOperator(TypeHalt) }
e <- ( eOne ';' sp { p.AddOperator(TypeClearDetail) } )* eOne
eOne <- sp (fstring / e0)

assign_expr <- identifier { p.AddValueStr(string(text)) } '=' e0 { p.AddStore() }

e0m <- (e0 ';' sp { p.AddOperator(TypeClearDetail) })* e0
e0 <- eTernary

// 没有特别搞懂为啥第一个e1不支持括号
eTernary <- eComp '?' sp { p.AddOperator(TypeJne); p.PushForOffset() } eComp ':' sp { p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() } eComp { p.PopAndSetOffset() }
        / eComp

// push 1
// jne 2
// push "ret1"
// jmp 1
// push "ret2"

eComp <- e1 ( lt { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompLT) }
            / le { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompLE) }
            / eq { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompEQ) }
            / ne { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompNE) }
            / ge { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompGE) }
            / gt { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompGT) })*

e1 <- e2 ( add { p.AddLeftValueMark() } e2 { p.AddOperator(TypeAdd) }
         / minus { p.AddLeftValueMark() } e2 { p.AddOperator(TypeSubtract) }
         )*
e2 <- e3 ( multiply { p.AddLeftValueMark() } e3 { p.AddOperator(TypeMultiply) }
         / divide { p.AddLeftValueMark() } e3 { p.AddOperator(TypeDivide) }
         / modulus { p.AddLeftValueMark() } e3 { p.AddOperator(TypeModulus) }
         )*

e3 <- e4 ( exponentiation { p.AddLeftValueMark() } e4 { p.AddOperator(TypeExponentiation) }
         )*

e4 <- minus e5 { p.AddOperator(TypeNegation) }
    / e5

e5 <- add eDice
    / eDice

dndDiceSuffix <- (('优势' / 'kh') {p.AddValue("1"); p.AddOperator(TypeDiceSetK)} sp / ('劣势' / 'kl') {p.AddValue("1"); p.AddOperator(TypeDiceSetQ)} sp )
kqDiceOp <- ('k' eDice2 { p.AddOperator(TypeDiceSetK) })? ('q' eDice2 { p.AddOperator(TypeDiceSetQ) } )? ('dl' eDice2 { p.AddOperatorWithInt64(TypeDiceSetK, 1) } )? ('dh' eDice2 { p.AddOperatorWithInt64(TypeDiceSetQ, 1) } )?

_dnumber <- &( [dD] (number / '(') )  // 独立出来是因为括号会影响IDEA的自动高亮

eDice <- ( _dnumber [dD] { p.AddValue("2"); p.AddLeftValueMark() } eDice2 dndDiceSuffix { p.AddOperator(TypeDice) } )
         / ( _dnumber [dD] { p.AddValue("1"); p.AddLeftValueMark() } eDice2 kqDiceOp { p.AddOperator(TypeDice) } )

         / [dD] dndDiceSuffix { p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }
         / [dD] !([^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r]) sp { p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }

         / eDice2 ( [dD] { p.AddLeftValueMark() } &(number / '(') eDice2 kqDiceOp { p.AddOperator(TypeDice) }
         )*

laNumberOrLeftParen <- &(number / '(')

// 这里故意弄成number，因为出现了 .rab射击 读取了射击的值，结果成为 .rab60 这样子的情况
eDice2 <- [pP] laNumberOrLeftParen eDice3 { p.AddOperator(TypeDicePenalty) }
         / [pP] { p.AddValue("1"); p.AddOperator(TypeDicePenalty) }
         / eDice3

eDice3 <- [bB] laNumberOrLeftParen value { p.AddOperator(TypeDiceBonus) }
         / [bB] { p.AddValue("1"); p.AddOperator(TypeDiceBonus) }
         / eDice4

eDice4 <- [fF] sp { p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) } // 塞两个垃圾参数，使其不成为unary
         / value

value <- number
       / assign_expr
       / identifier { p.AddLoadVarname(string(text)) }
       / sub

number <- < [0-9]+ > sp { p.AddValue(string(text)) }

identifier <- < [^!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~0-9 \t\n\r][^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r]* > sp // not (punctuation+number)
// identifier2 <- !'d' ![0-9] < (universalCharacter / [a-zA-Z_])+ > sp // not (punctuation+number)
sub <- open e0 close
add <- ('+'/'＋') sp
minus <- ('-' / '－') sp
multiply <- ('*' / '＊') sp
divide <- ('/' / '／') sp
modulus <- '%' sp
exponentiation <- '^' sp / '**' sp
open <- '(' sp
close <- ')' sp
sp <- ( ' ' / '\t' )*
lt <- ('<' / '＜') sp
gt <- ('>' / '＞') sp
le <- ('<=' / '＜＝') sp
ge <- ('>=' / '＞＝') sp
eq <- ('==' / '＝＝') sp
ne <- ('!=' / '！＝') sp

fstring <- '`' < ( ('{' sp e0m sp '}') / escape / ![`\\\n\r] .)* > '`' sp { p.AddFormatString(string(text)) }
escape <- '\\' ([btnfr"'\\])  //  / OctalEscape / UnicodeEscape
