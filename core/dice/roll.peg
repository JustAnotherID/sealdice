// part of SealDice project

package dice

type DiceRollParser Peg {
    RollExpression
}

// 实际操作中发现，不匹配句尾比较好 (没有!.)
eBase <- e { p.AddOperator(TypeHalt) }
e <- ( eOne ';' sp { p.AddOperator(TypeClearDetail) } )* eOne
eOne <- sp (fstring / e0)

assign_expr <- identifier { p.AddValueStr(string(text)) } '=' sp e0 { p.AddStore() }

// e0m <- (e0 ';' sp { p.AddOperator(TypeClearDetail) })* e0
e0 <- eTernary

eSimpleSwitch <- eBitwise '?' sp { p.AddOperator(TypeJne); p.PushForOffset() } eBitwise { p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset(); } // 这里的Pop对应的是jne，所有jmp将攒到最后
eTernary <- eBitwise '?' sp { p.AddOperator(TypeJne); p.PushForOffset() } eBitwise ':' sp { p.AddOperator(TypeJmp); p.PopAndSetOffset(); p.PushForOffset() } eBitwise { p.PopAndSetOffset() }
        / eSimpleSwitch { p.CounterPush() } ( ',' sp eSimpleSwitch {p.CounterAdd(1)} )*  { p.AddValueStr(""); limit:=p.CounterPop()+1; for i:=int64(0); i<limit; i++ { p.PopAndSetOffset() } }
        / eBitwise

// if ... then .. else
// push 1
// jne 2
// push "ret1"
// jmp 1
// push "ret2"

// switch { case 1: ..., case 2: ... }
// push cond1
// jne 2
// push "ret1"
// jmp 5
// push cond2
// jne 2
// push "ret2"
// jmp 1
// push 0 // 默认
// push "ret3"

eBitwise <- eComp ((logicOr / bitwiseOr) { p.AddLeftValueMark() } eComp { p.AddOperator(TypeBitwiseOr) }
                 / (logicAnd / bitwiseAnd) { p.AddLeftValueMark() } eComp { p.AddOperator(TypeBitwiseAnd) } )*

eComp <- e1 ( lt { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompLT) }
            / le { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompLE) }
            / eq { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompEQ) }
            / ne { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompNE) }
            / ge { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompGE) }
            / gt { p.AddLeftValueMark() } e1 { p.AddOperator(TypeCompGT) })*

e1 <- e2 ( add { p.AddLeftValueMark() } e2 { p.AddOperator(TypeAdd) }
         / minus { p.AddLeftValueMark() } e2 { p.AddOperator(TypeSubtract) }
         )*
e2 <- e3 ( multiply { p.AddLeftValueMark() } e3 { p.AddOperator(TypeMultiply) }
         / divide { p.AddLeftValueMark() } e3 { p.AddOperator(TypeDivide) }
         / modulus { p.AddLeftValueMark() } e3 { p.AddOperator(TypeModulus) }
         )*

e3 <- e4 ( exponentiation { p.AddLeftValueMark() } e4 { p.AddOperator(TypeExponentiation) }
         )*

e4 <- minus e5 { p.AddOperator(TypeNegation) }
    / e5

e5 <- add eDice
    / eDice

dndDiceSuffix <- (('优势' / 'kh') {p.AddValue("1"); p.AddOperator(TypeDiceSetK)} sp / ('劣势' / 'kl') {p.AddValue("1"); p.AddOperator(TypeDiceSetQ)} sp )
kqDiceOp <- ('k' eDice2 { p.AddOperator(TypeDiceSetK) })? ('q' eDice2 { p.AddOperator(TypeDiceSetQ) } )? ('dl' eDice2 { p.AddOperatorWithInt64(TypeDiceSetK, 1) } )? ('dh' eDice2 { p.AddOperatorWithInt64(TypeDiceSetQ, 1) } )?

_dnumber <- &( [dD] (number / '(') )  // 独立出来是因为括号会影响IDEA的自动高亮

eDice <- ( _dnumber [dD] { p.AddValue("2"); p.AddLeftValueMark() } eDice2 dndDiceSuffix { p.AddOperator(TypeDice) } )
         / ( _dnumber [dD] { p.AddValue("1"); p.AddLeftValueMark() } eDice2 kqDiceOp { p.AddOperator(TypeDice) } )

         / [dD] dndDiceSuffix { p.AddValue("2"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }
         / [dD] !([^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r]) sp { p.AddValue("1"); p.AddLeftValueMark(); p.AddValue("0"); p.AddOperator(TypeDice) }

         / eDice2 ( [dD] { p.AddLeftValueMark() } &(number / '(') eDice2 kqDiceOp { p.AddOperator(TypeDice) }
         )*

laNumberOrLeftParen <- &(number / '(')

// 这里故意弄成number，因为出现了 .rab射击 读取了射击的值，结果成为 .rab60 这样子的情况
eDice2 <- [pP] laNumberOrLeftParen eDice3 { p.AddOperator(TypeDicePenalty) }
         / [pP] { p.AddValue("1"); p.AddOperator(TypeDicePenalty) }
         / eDice3

eDice3 <- [bB] laNumberOrLeftParen value { p.AddOperator(TypeDiceBonus) }
         / [bB] { p.AddValue("1"); p.AddOperator(TypeDiceBonus) }
         / eDice4

eDice4 <- [fF] sp { p.AddValue("0"); p.AddValue("0"); p.AddOperator(TypeDiceFate) } // 塞两个垃圾参数，使其不成为unary
         / value

value <- number
       / assign_expr
       / identifier { p.AddLoadVarname(string(text)) }
       / sub
       / fstring

number <- < [0-9]+ > sp { p.AddValue(string(text)) }

identifier <- < [^!"#%&\'()*+,-./:;<=>?@\[\\\]^`{|}~0-9 \t\n\r][^!"#$%&\'()*+,-./;<=>?@\[\\\]^`{|}~ \t\n\r]* > sp // not (punctuation+number)
// identifier2 <- !'d' ![0-9] < (universalCharacter / [a-zA-Z_])+ > sp // not (punctuation+number)
sub <- open e0 close
add <- ('+'/'＋') sp
minus <- ('-' / '－') sp
multiply <- ('*' / '＊') sp
divide <- ('/' / '／') sp
modulus <- '%' sp
exponentiation <- '^' sp / '**' sp
open <- '(' sp
close <- ')' sp

bitwiseOr <- '|' sp
logicOr <- '||' sp
bitwiseAnd <- ('&' / '&amp;') sp
logicAnd <- ('&&' / '&amp;&amp;') sp
sp <- ( ' ' / '\t' / '\n' / '\r' )*
lt <- ('<' / '＜') sp
gt <- ('>' / '＞') sp
le <- ('<=' / '＜＝') sp
ge <- ('>=' / '＞＝') sp
eq <- ('==' / '＝＝') sp
ne <- ('!=' / '！＝') sp

strPart <- < (escape / (![{`\\\n\r].))+ > { p.AddValueStr(string(text)); p.CounterAdd(1) }
strPart2 <- < (escape / (![{"\\\n\r].))+ > { p.AddValueStr(string(text)); p.CounterAdd(1) }
strPart3 <- < (escape / (![{\'\\\n\r].))+ > { p.AddValueStr(string(text)); p.CounterAdd(1) }

fstring <- (
          ('`' { p.CounterPush() } < ( ('{' sp e {p.CounterAdd(1)} '}') / ('{{' sp e {p.CounterAdd(1)} '}}') / strPart )* > '`' { p.AddFormatString(string(text), p.CounterPop()) })
        / ('"' { p.CounterPush() } < ( strPart2 )* > '"' { p.AddFormatString(string(text), p.CounterPop()) })
        / ('\'' { p.CounterPush() } < ( strPart3 )* > '\'' { p.AddFormatString(string(text), p.CounterPop()) })
    ) sp
escape <- '\\' ([btnfr"'\\])  //  / OctalEscape / UnicodeEscape
