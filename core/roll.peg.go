package main

// Code generated by peg -inline roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	rulee
	rulee1
	rulee2
	rulee3
	ruleeDice
	rulee4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulesp
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	rulePegText
	ruleAction16
)

var rul3s = [...]string{
	"Unknown",
	"e",
	"e1",
	"e2",
	"e3",
	"eDice",
	"e4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"sp",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"PegText",
	"Action16",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [40]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddLeftValueMark()
		case ruleAction2:
			p.AddOperator(TypeAdd)
		case ruleAction3:
			p.AddOperator(TypeSubtract)
		case ruleAction4:
			p.AddLeftValueMark()
		case ruleAction5:
			p.AddOperator(TypeMultiply)
		case ruleAction6:
			p.AddOperator(TypeDivide)
		case ruleAction7:
			p.AddOperator(TypeModulus)
		case ruleAction8:
			p.AddLeftValueMark()
		case ruleAction9:
			p.AddOperator(TypeExponentiation)
		case ruleAction10:
			p.AddLeftValueMark()
		case ruleAction11:
			p.AddOperator(TypeDice)
		case ruleAction12:
			p.AddValue("1")
			p.AddOperator(TypeSwap)
			p.AddOperator(TypeDice)
		case ruleAction13:
			p.AddOperator(TypeNegation)
		case ruleAction14:
			p.AddValue(string(text))
		case ruleAction15:
			p.AddLoadVarname(string(text))
		case ruleAction16:
			p.AddFormatString(string(text))

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 e <- <(sp (fstring / e1) !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulesp]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						{
							position5 := position
						l6:
							{
								position7, tokenIndex7 := position, tokenIndex
								{
									position8, tokenIndex8 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l9
									}
									position++
									if !_rules[rulesp]() {
										goto l9
									}
									if !_rules[rulee1]() {
										goto l9
									}
									if !_rules[rulesp]() {
										goto l9
									}
									if buffer[position] != rune('}') {
										goto l9
									}
									position++
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									{
										position11 := position
										if buffer[position] != rune('\\') {
											goto l10
										}
										position++
										{
											position12, tokenIndex12 := position, tokenIndex
											if buffer[position] != rune('b') {
												goto l13
											}
											position++
											goto l12
										l13:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('t') {
												goto l14
											}
											position++
											goto l12
										l14:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('n') {
												goto l15
											}
											position++
											goto l12
										l15:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('f') {
												goto l16
											}
											position++
											goto l12
										l16:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('r') {
												goto l17
											}
											position++
											goto l12
										l17:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('"') {
												goto l18
											}
											position++
											goto l12
										l18:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('\'') {
												goto l19
											}
											position++
											goto l12
										l19:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('\\') {
												goto l10
											}
											position++
										}
									l12:
										add(ruleescape, position11)
									}
									goto l8
								l10:
									position, tokenIndex = position8, tokenIndex8
									{
										position20, tokenIndex20 := position, tokenIndex
										{
											position21, tokenIndex21 := position, tokenIndex
											if buffer[position] != rune('`') {
												goto l22
											}
											position++
											goto l21
										l22:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\\') {
												goto l23
											}
											position++
											goto l21
										l23:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\n') {
												goto l24
											}
											position++
											goto l21
										l24:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\r') {
												goto l20
											}
											position++
										}
									l21:
										goto l7
									l20:
										position, tokenIndex = position20, tokenIndex20
									}
									if !matchDot() {
										goto l7
									}
								}
							l8:
								goto l6
							l7:
								position, tokenIndex = position7, tokenIndex7
							}
							add(rulePegText, position5)
						}
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						if !_rules[rulesp]() {
							goto l3
						}
						{
							add(ruleAction16, position)
						}
						add(rulefstring, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[rulee1]() {
						goto l0
					}
				}
			l2:
				{
					position26, tokenIndex26 := position, tokenIndex
					if !matchDot() {
						goto l26
					}
					goto l0
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
				{
					add(ruleAction0, position)
				}
				add(rulee, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e1 <- <(e2 Action1 ((add e2 Action2) / (minus e2 Action3))*)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if !_rules[rulee2]() {
					goto l28
				}
				{
					add(ruleAction1, position)
				}
			l31:
				{
					position32, tokenIndex32 := position, tokenIndex
					{
						position33, tokenIndex33 := position, tokenIndex
						{
							position35 := position
							if buffer[position] != rune('+') {
								goto l34
							}
							position++
							if !_rules[rulesp]() {
								goto l34
							}
							add(ruleadd, position35)
						}
						if !_rules[rulee2]() {
							goto l34
						}
						{
							add(ruleAction2, position)
						}
						goto l33
					l34:
						position, tokenIndex = position33, tokenIndex33
						if !_rules[ruleminus]() {
							goto l32
						}
						if !_rules[rulee2]() {
							goto l32
						}
						{
							add(ruleAction3, position)
						}
					}
				l33:
					goto l31
				l32:
					position, tokenIndex = position32, tokenIndex32
				}
				add(rulee1, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 2 e2 <- <(e3 Action4 ((multiply e3 Action5) / (divide e3 Action6) / (modulus e3 Action7))*)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				if !_rules[rulee3]() {
					goto l38
				}
				{
					add(ruleAction4, position)
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position43, tokenIndex43 := position, tokenIndex
						{
							position45 := position
							if buffer[position] != rune('*') {
								goto l44
							}
							position++
							if !_rules[rulesp]() {
								goto l44
							}
							add(rulemultiply, position45)
						}
						if !_rules[rulee3]() {
							goto l44
						}
						{
							add(ruleAction5, position)
						}
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						{
							position48 := position
							if buffer[position] != rune('/') {
								goto l47
							}
							position++
							if !_rules[rulesp]() {
								goto l47
							}
							add(ruledivide, position48)
						}
						if !_rules[rulee3]() {
							goto l47
						}
						{
							add(ruleAction6, position)
						}
						goto l43
					l47:
						position, tokenIndex = position43, tokenIndex43
						{
							position50 := position
							if buffer[position] != rune('%') {
								goto l42
							}
							position++
							if !_rules[rulesp]() {
								goto l42
							}
							add(rulemodulus, position50)
						}
						if !_rules[rulee3]() {
							goto l42
						}
						{
							add(ruleAction7, position)
						}
					}
				l43:
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				add(rulee2, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 3 e3 <- <(eDice Action8 (exponentiation eDice Action9)*)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleeDice]() {
					goto l52
				}
				{
					add(ruleAction8, position)
				}
			l55:
				{
					position56, tokenIndex56 := position, tokenIndex
					{
						position57 := position
						{
							position58, tokenIndex58 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l59
							}
							position++
							if !_rules[rulesp]() {
								goto l59
							}
							goto l58
						l59:
							position, tokenIndex = position58, tokenIndex58
							if buffer[position] != rune('*') {
								goto l56
							}
							position++
							if buffer[position] != rune('*') {
								goto l56
							}
							position++
							if !_rules[rulesp]() {
								goto l56
							}
						}
					l58:
						add(ruleexponentiation, position57)
					}
					if !_rules[ruleeDice]() {
						goto l56
					}
					{
						add(ruleAction9, position)
					}
					goto l55
				l56:
					position, tokenIndex = position56, tokenIndex56
				}
				add(rulee3, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 4 eDice <- <((e4 Action10 (('d' / 'D') e4 ('k' e4)? Action11)*) / (('d' / 'D') e4 ('k' e4)? Action12)+)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				{
					position63, tokenIndex63 := position, tokenIndex
					if !_rules[rulee4]() {
						goto l64
					}
					{
						add(ruleAction10, position)
					}
				l66:
					{
						position67, tokenIndex67 := position, tokenIndex
						{
							position68, tokenIndex68 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l69
							}
							position++
							goto l68
						l69:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('D') {
								goto l67
							}
							position++
						}
					l68:
						if !_rules[rulee4]() {
							goto l67
						}
						{
							position70, tokenIndex70 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l70
							}
							position++
							if !_rules[rulee4]() {
								goto l70
							}
							goto l71
						l70:
							position, tokenIndex = position70, tokenIndex70
						}
					l71:
						{
							add(ruleAction11, position)
						}
						goto l66
					l67:
						position, tokenIndex = position67, tokenIndex67
					}
					goto l63
				l64:
					position, tokenIndex = position63, tokenIndex63
					{
						position75, tokenIndex75 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l76
						}
						position++
						goto l75
					l76:
						position, tokenIndex = position75, tokenIndex75
						if buffer[position] != rune('D') {
							goto l61
						}
						position++
					}
				l75:
					if !_rules[rulee4]() {
						goto l61
					}
					{
						position77, tokenIndex77 := position, tokenIndex
						if buffer[position] != rune('k') {
							goto l77
						}
						position++
						if !_rules[rulee4]() {
							goto l77
						}
						goto l78
					l77:
						position, tokenIndex = position77, tokenIndex77
					}
				l78:
					{
						add(ruleAction12, position)
					}
				l73:
					{
						position74, tokenIndex74 := position, tokenIndex
						{
							position80, tokenIndex80 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l81
							}
							position++
							goto l80
						l81:
							position, tokenIndex = position80, tokenIndex80
							if buffer[position] != rune('D') {
								goto l74
							}
							position++
						}
					l80:
						if !_rules[rulee4]() {
							goto l74
						}
						{
							position82, tokenIndex82 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l82
							}
							position++
							if !_rules[rulee4]() {
								goto l82
							}
							goto l83
						l82:
							position, tokenIndex = position82, tokenIndex82
						}
					l83:
						{
							add(ruleAction12, position)
						}
						goto l73
					l74:
						position, tokenIndex = position74, tokenIndex74
					}
				}
			l63:
				add(ruleeDice, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 5 e4 <- <((minus value Action13) / value)> */
		func() bool {
			position85, tokenIndex85 := position, tokenIndex
			{
				position86 := position
				{
					position87, tokenIndex87 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l88
					}
					if !_rules[rulevalue]() {
						goto l88
					}
					{
						add(ruleAction13, position)
					}
					goto l87
				l88:
					position, tokenIndex = position87, tokenIndex87
					if !_rules[rulevalue]() {
						goto l85
					}
				}
			l87:
				add(rulee4, position86)
			}
			return true
		l85:
			position, tokenIndex = position85, tokenIndex85
			return false
		},
		/* 6 value <- <((number Action14) / (identifier Action15) / sub)> */
		func() bool {
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				{
					position92, tokenIndex92 := position, tokenIndex
					{
						position94 := position
						{
							position95 := position
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l93
							}
							position++
						l96:
							{
								position97, tokenIndex97 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l97
								}
								position++
								goto l96
							l97:
								position, tokenIndex = position97, tokenIndex97
							}
							add(rulePegText, position95)
						}
						if !_rules[rulesp]() {
							goto l93
						}
						add(rulenumber, position94)
					}
					{
						add(ruleAction14, position)
					}
					goto l92
				l93:
					position, tokenIndex = position92, tokenIndex92
					{
						position100 := position
						{
							position101, tokenIndex101 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l101
							}
							position++
							goto l99
						l101:
							position, tokenIndex = position101, tokenIndex101
						}
						{
							position102 := position
							{
								position105, tokenIndex105 := position, tokenIndex
								{
									position106, tokenIndex106 := position, tokenIndex
									if buffer[position] != rune('!') {
										goto l107
									}
									position++
									goto l106
								l107:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('"') {
										goto l108
									}
									position++
									goto l106
								l108:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('#') {
										goto l109
									}
									position++
									goto l106
								l109:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('$') {
										goto l110
									}
									position++
									goto l106
								l110:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('%') {
										goto l111
									}
									position++
									goto l106
								l111:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('&') {
										goto l112
									}
									position++
									goto l106
								l112:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('\'') {
										goto l113
									}
									position++
									goto l106
								l113:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('(') {
										goto l114
									}
									position++
									goto l106
								l114:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune(')') {
										goto l115
									}
									position++
									goto l106
								l115:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('*') {
										goto l116
									}
									position++
									goto l106
								l116:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('+') {
										goto l117
									}
									position++
									goto l106
								l117:
									position, tokenIndex = position106, tokenIndex106
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l118
									}
									position++
									goto l106
								l118:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('/') {
										goto l119
									}
									position++
									goto l106
								l119:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune(':') {
										goto l120
									}
									position++
									goto l106
								l120:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune(';') {
										goto l121
									}
									position++
									goto l106
								l121:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('<') {
										goto l122
									}
									position++
									goto l106
								l122:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('=') {
										goto l123
									}
									position++
									goto l106
								l123:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('>') {
										goto l124
									}
									position++
									goto l106
								l124:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('?') {
										goto l125
									}
									position++
									goto l106
								l125:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('@') {
										goto l126
									}
									position++
									goto l106
								l126:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('[') {
										goto l127
									}
									position++
									goto l106
								l127:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('\\') {
										goto l128
									}
									position++
									goto l106
								l128:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune(']') {
										goto l129
									}
									position++
									goto l106
								l129:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('^') {
										goto l130
									}
									position++
									goto l106
								l130:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('_') {
										goto l131
									}
									position++
									goto l106
								l131:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('`') {
										goto l132
									}
									position++
									goto l106
								l132:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('{') {
										goto l133
									}
									position++
									goto l106
								l133:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('|') {
										goto l134
									}
									position++
									goto l106
								l134:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('}') {
										goto l135
									}
									position++
									goto l106
								l135:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('~') {
										goto l136
									}
									position++
									goto l106
								l136:
									position, tokenIndex = position106, tokenIndex106
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l137
									}
									position++
									goto l106
								l137:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune(' ') {
										goto l138
									}
									position++
									goto l106
								l138:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('\t') {
										goto l139
									}
									position++
									goto l106
								l139:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('\n') {
										goto l140
									}
									position++
									goto l106
								l140:
									position, tokenIndex = position106, tokenIndex106
									if buffer[position] != rune('\r') {
										goto l105
									}
									position++
								}
							l106:
								goto l99
							l105:
								position, tokenIndex = position105, tokenIndex105
							}
							if !matchDot() {
								goto l99
							}
						l103:
							{
								position104, tokenIndex104 := position, tokenIndex
								{
									position141, tokenIndex141 := position, tokenIndex
									{
										position142, tokenIndex142 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l143
										}
										position++
										goto l142
									l143:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('"') {
											goto l144
										}
										position++
										goto l142
									l144:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('#') {
											goto l145
										}
										position++
										goto l142
									l145:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('$') {
											goto l146
										}
										position++
										goto l142
									l146:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('%') {
											goto l147
										}
										position++
										goto l142
									l147:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('&') {
											goto l148
										}
										position++
										goto l142
									l148:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('\'') {
											goto l149
										}
										position++
										goto l142
									l149:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('(') {
											goto l150
										}
										position++
										goto l142
									l150:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune(')') {
											goto l151
										}
										position++
										goto l142
									l151:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('*') {
											goto l152
										}
										position++
										goto l142
									l152:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('+') {
											goto l153
										}
										position++
										goto l142
									l153:
										position, tokenIndex = position142, tokenIndex142
										if c := buffer[position]; c < rune(',') || c > rune('.') {
											goto l154
										}
										position++
										goto l142
									l154:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('/') {
											goto l155
										}
										position++
										goto l142
									l155:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune(':') {
											goto l156
										}
										position++
										goto l142
									l156:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune(';') {
											goto l157
										}
										position++
										goto l142
									l157:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('<') {
											goto l158
										}
										position++
										goto l142
									l158:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('=') {
											goto l159
										}
										position++
										goto l142
									l159:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('>') {
											goto l160
										}
										position++
										goto l142
									l160:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('?') {
											goto l161
										}
										position++
										goto l142
									l161:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('@') {
											goto l162
										}
										position++
										goto l142
									l162:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('[') {
											goto l163
										}
										position++
										goto l142
									l163:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('\\') {
											goto l164
										}
										position++
										goto l142
									l164:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune(']') {
											goto l165
										}
										position++
										goto l142
									l165:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('^') {
											goto l166
										}
										position++
										goto l142
									l166:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('_') {
											goto l167
										}
										position++
										goto l142
									l167:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('`') {
											goto l168
										}
										position++
										goto l142
									l168:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('{') {
											goto l169
										}
										position++
										goto l142
									l169:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('|') {
											goto l170
										}
										position++
										goto l142
									l170:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('}') {
											goto l171
										}
										position++
										goto l142
									l171:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('~') {
											goto l172
										}
										position++
										goto l142
									l172:
										position, tokenIndex = position142, tokenIndex142
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l173
										}
										position++
										goto l142
									l173:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune(' ') {
											goto l174
										}
										position++
										goto l142
									l174:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('\t') {
											goto l175
										}
										position++
										goto l142
									l175:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('\n') {
											goto l176
										}
										position++
										goto l142
									l176:
										position, tokenIndex = position142, tokenIndex142
										if buffer[position] != rune('\r') {
											goto l141
										}
										position++
									}
								l142:
									goto l104
								l141:
									position, tokenIndex = position141, tokenIndex141
								}
								if !matchDot() {
									goto l104
								}
								goto l103
							l104:
								position, tokenIndex = position104, tokenIndex104
							}
							add(rulePegText, position102)
						}
						if !_rules[rulesp]() {
							goto l99
						}
						add(ruleidentifier, position100)
					}
					{
						add(ruleAction15, position)
					}
					goto l92
				l99:
					position, tokenIndex = position92, tokenIndex92
					{
						position178 := position
						{
							position179 := position
							if buffer[position] != rune('(') {
								goto l90
							}
							position++
							if !_rules[rulesp]() {
								goto l90
							}
							add(ruleopen, position179)
						}
						if !_rules[rulee1]() {
							goto l90
						}
						{
							position180 := position
							if buffer[position] != rune(')') {
								goto l90
							}
							position++
							if !_rules[rulesp]() {
								goto l90
							}
							add(ruleclose, position180)
						}
						add(rulesub, position178)
					}
				}
			l92:
				add(rulevalue, position91)
			}
			return true
		l90:
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 7 number <- <(<[0-9]+> sp)> */
		nil,
		/* 8 identifier <- <(!'d' <(!('!' / '"' / '#' / '$' / '%' / '&' / '\'' / '(' / ')' / '*' / '+' / [,-.] / '/' / ':' / ';' / '<' / '=' / '>' / '?' / '@' / '[' / '\\' / ']' / '^' / '_' / '`' / '{' / '|' / '}' / '~' / [0-9] / ' ' / '\t' / '\n' / '\r') .)+> sp)> */
		nil,
		/* 9 sub <- <(open e1 close)> */
		nil,
		/* 10 add <- <('+' sp)> */
		nil,
		/* 11 minus <- <('-' sp)> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				if buffer[position] != rune('-') {
					goto l185
				}
				position++
				if !_rules[rulesp]() {
					goto l185
				}
				add(ruleminus, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 12 multiply <- <('*' sp)> */
		nil,
		/* 13 divide <- <('/' sp)> */
		nil,
		/* 14 modulus <- <('%' sp)> */
		nil,
		/* 15 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 16 open <- <('(' sp)> */
		nil,
		/* 17 close <- <(')' sp)> */
		nil,
		/* 18 sp <- <(' ' / '\t')*> */
		func() bool {
			{
				position194 := position
			l195:
				{
					position196, tokenIndex196 := position, tokenIndex
					{
						position197, tokenIndex197 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l198
						}
						position++
						goto l197
					l198:
						position, tokenIndex = position197, tokenIndex197
						if buffer[position] != rune('\t') {
							goto l196
						}
						position++
					}
				l197:
					goto l195
				l196:
					position, tokenIndex = position196, tokenIndex196
				}
				add(rulesp, position194)
			}
			return true
		},
		/* 19 fstring <- <('`' <(('{' sp e1 sp '}') / escape / (!('`' / '\\' / '\n' / '\r') .))*> '`' sp Action16)> */
		nil,
		/* 20 escape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\'' / '\\'))> */
		nil,
		/* 22 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 23 Action1 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 24 Action2 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 25 Action3 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 26 Action4 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 27 Action5 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 28 Action6 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 29 Action7 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 30 Action8 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 31 Action9 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 32 Action10 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 33 Action11 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 34 Action12 <- <{ p.AddValue("1"); p.AddOperator(TypeSwap); p.AddOperator(TypeDice) }> */
		nil,
		/* 35 Action13 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 36 Action14 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 37 Action15 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 39 Action16 <- <{ p.AddFormatString(string(text)) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
