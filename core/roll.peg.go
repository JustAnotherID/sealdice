package main

// Code generated by peg -inline roll.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	rulee
	rulee1
	rulee2
	rulee3
	ruleeDice
	rulee4
	rulevalue
	rulenumber
	ruleidentifier
	rulesub
	ruleadd
	ruleminus
	rulemultiply
	ruledivide
	rulemodulus
	ruleexponentiation
	ruleopen
	ruleclose
	rulesp
	rulefstring
	ruleescape
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	rulePegText
	ruleAction20
)

var rul3s = [...]string{
	"Unknown",
	"e",
	"e1",
	"e2",
	"e3",
	"eDice",
	"e4",
	"value",
	"number",
	"identifier",
	"sub",
	"add",
	"minus",
	"multiply",
	"divide",
	"modulus",
	"exponentiation",
	"open",
	"close",
	"sp",
	"fstring",
	"escape",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"PegText",
	"Action20",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type DiceRollParser struct {
	RollExpression

	Buffer string
	buffer []rune
	rules  [44]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *DiceRollParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *DiceRollParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *DiceRollParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *DiceRollParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *DiceRollParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *DiceRollParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *DiceRollParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddOperator(TypeHalt)
		case ruleAction1:
			p.AddLeftValueMark()
		case ruleAction2:
			p.AddOperator(TypeAdd)
		case ruleAction3:
			p.AddLeftValueMark()
		case ruleAction4:
			p.AddOperator(TypeSubtract)
		case ruleAction5:
			p.AddLeftValueMark()
		case ruleAction6:
			p.AddOperator(TypeMultiply)
		case ruleAction7:
			p.AddLeftValueMark()
		case ruleAction8:
			p.AddOperator(TypeDivide)
		case ruleAction9:
			p.AddLeftValueMark()
		case ruleAction10:
			p.AddOperator(TypeModulus)
		case ruleAction11:
			p.AddLeftValueMark()
		case ruleAction12:
			p.AddOperator(TypeExponentiation)
		case ruleAction13:
			p.AddLeftValueMark()
		case ruleAction14:
			p.AddOperator(TypeDice)
		case ruleAction15:
			p.AddLeftValueMark()
		case ruleAction16:
			p.AddValue("1")
			p.AddOperator(TypeSwap)
			p.AddOperator(TypeDice)
		case ruleAction17:
			p.AddOperator(TypeNegation)
		case ruleAction18:
			p.AddValue(string(text))
		case ruleAction19:
			p.AddLoadVarname(string(text))
		case ruleAction20:
			p.AddFormatString(string(text))

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*DiceRollParser) error {
	return func(p *DiceRollParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *DiceRollParser) Init(options ...func(*DiceRollParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 e <- <(sp (fstring / e1) !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rulesp]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						{
							position5 := position
						l6:
							{
								position7, tokenIndex7 := position, tokenIndex
								{
									position8, tokenIndex8 := position, tokenIndex
									if buffer[position] != rune('{') {
										goto l9
									}
									position++
									if !_rules[rulesp]() {
										goto l9
									}
									if !_rules[rulee1]() {
										goto l9
									}
									if !_rules[rulesp]() {
										goto l9
									}
									if buffer[position] != rune('}') {
										goto l9
									}
									position++
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									{
										position11 := position
										if buffer[position] != rune('\\') {
											goto l10
										}
										position++
										{
											position12, tokenIndex12 := position, tokenIndex
											if buffer[position] != rune('b') {
												goto l13
											}
											position++
											goto l12
										l13:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('t') {
												goto l14
											}
											position++
											goto l12
										l14:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('n') {
												goto l15
											}
											position++
											goto l12
										l15:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('f') {
												goto l16
											}
											position++
											goto l12
										l16:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('r') {
												goto l17
											}
											position++
											goto l12
										l17:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('"') {
												goto l18
											}
											position++
											goto l12
										l18:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('\'') {
												goto l19
											}
											position++
											goto l12
										l19:
											position, tokenIndex = position12, tokenIndex12
											if buffer[position] != rune('\\') {
												goto l10
											}
											position++
										}
									l12:
										add(ruleescape, position11)
									}
									goto l8
								l10:
									position, tokenIndex = position8, tokenIndex8
									{
										position20, tokenIndex20 := position, tokenIndex
										{
											position21, tokenIndex21 := position, tokenIndex
											if buffer[position] != rune('`') {
												goto l22
											}
											position++
											goto l21
										l22:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\\') {
												goto l23
											}
											position++
											goto l21
										l23:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\n') {
												goto l24
											}
											position++
											goto l21
										l24:
											position, tokenIndex = position21, tokenIndex21
											if buffer[position] != rune('\r') {
												goto l20
											}
											position++
										}
									l21:
										goto l7
									l20:
										position, tokenIndex = position20, tokenIndex20
									}
									if !matchDot() {
										goto l7
									}
								}
							l8:
								goto l6
							l7:
								position, tokenIndex = position7, tokenIndex7
							}
							add(rulePegText, position5)
						}
						if buffer[position] != rune('`') {
							goto l3
						}
						position++
						if !_rules[rulesp]() {
							goto l3
						}
						{
							add(ruleAction20, position)
						}
						add(rulefstring, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[rulee1]() {
						goto l0
					}
				}
			l2:
				{
					position26, tokenIndex26 := position, tokenIndex
					if !matchDot() {
						goto l26
					}
					goto l0
				l26:
					position, tokenIndex = position26, tokenIndex26
				}
				{
					add(ruleAction0, position)
				}
				add(rulee, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 e1 <- <(e2 ((add Action1 e2 Action2) / (minus Action3 e2 Action4))*)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if !_rules[rulee2]() {
					goto l28
				}
			l30:
				{
					position31, tokenIndex31 := position, tokenIndex
					{
						position32, tokenIndex32 := position, tokenIndex
						{
							position34 := position
							if buffer[position] != rune('+') {
								goto l33
							}
							position++
							if !_rules[rulesp]() {
								goto l33
							}
							add(ruleadd, position34)
						}
						{
							add(ruleAction1, position)
						}
						if !_rules[rulee2]() {
							goto l33
						}
						{
							add(ruleAction2, position)
						}
						goto l32
					l33:
						position, tokenIndex = position32, tokenIndex32
						if !_rules[ruleminus]() {
							goto l31
						}
						{
							add(ruleAction3, position)
						}
						if !_rules[rulee2]() {
							goto l31
						}
						{
							add(ruleAction4, position)
						}
					}
				l32:
					goto l30
				l31:
					position, tokenIndex = position31, tokenIndex31
				}
				add(rulee1, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 2 e2 <- <(e3 ((multiply Action5 e3 Action6) / (divide Action7 e3 Action8) / (modulus Action9 e3 Action10))*)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[rulee3]() {
					goto l39
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					{
						position43, tokenIndex43 := position, tokenIndex
						{
							position45 := position
							if buffer[position] != rune('*') {
								goto l44
							}
							position++
							if !_rules[rulesp]() {
								goto l44
							}
							add(rulemultiply, position45)
						}
						{
							add(ruleAction5, position)
						}
						if !_rules[rulee3]() {
							goto l44
						}
						{
							add(ruleAction6, position)
						}
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						{
							position49 := position
							if buffer[position] != rune('/') {
								goto l48
							}
							position++
							if !_rules[rulesp]() {
								goto l48
							}
							add(ruledivide, position49)
						}
						{
							add(ruleAction7, position)
						}
						if !_rules[rulee3]() {
							goto l48
						}
						{
							add(ruleAction8, position)
						}
						goto l43
					l48:
						position, tokenIndex = position43, tokenIndex43
						{
							position52 := position
							if buffer[position] != rune('%') {
								goto l42
							}
							position++
							if !_rules[rulesp]() {
								goto l42
							}
							add(rulemodulus, position52)
						}
						{
							add(ruleAction9, position)
						}
						if !_rules[rulee3]() {
							goto l42
						}
						{
							add(ruleAction10, position)
						}
					}
				l43:
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				add(rulee2, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 3 e3 <- <(eDice (exponentiation Action11 eDice Action12)*)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleeDice]() {
					goto l55
				}
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59 := position
						{
							position60, tokenIndex60 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l61
							}
							position++
							if !_rules[rulesp]() {
								goto l61
							}
							goto l60
						l61:
							position, tokenIndex = position60, tokenIndex60
							if buffer[position] != rune('*') {
								goto l58
							}
							position++
							if buffer[position] != rune('*') {
								goto l58
							}
							position++
							if !_rules[rulesp]() {
								goto l58
							}
						}
					l60:
						add(ruleexponentiation, position59)
					}
					{
						add(ruleAction11, position)
					}
					if !_rules[ruleeDice]() {
						goto l58
					}
					{
						add(ruleAction12, position)
					}
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(rulee3, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 4 eDice <- <((e4 (('d' / 'D') Action13 e4 ('k' e4)? Action14)*) / (('d' / 'D') Action15 e4 ('k' e4)? Action16)+)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				{
					position66, tokenIndex66 := position, tokenIndex
					if !_rules[rulee4]() {
						goto l67
					}
				l68:
					{
						position69, tokenIndex69 := position, tokenIndex
						{
							position70, tokenIndex70 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l71
							}
							position++
							goto l70
						l71:
							position, tokenIndex = position70, tokenIndex70
							if buffer[position] != rune('D') {
								goto l69
							}
							position++
						}
					l70:
						{
							add(ruleAction13, position)
						}
						if !_rules[rulee4]() {
							goto l69
						}
						{
							position73, tokenIndex73 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l73
							}
							position++
							if !_rules[rulee4]() {
								goto l73
							}
							goto l74
						l73:
							position, tokenIndex = position73, tokenIndex73
						}
					l74:
						{
							add(ruleAction14, position)
						}
						goto l68
					l69:
						position, tokenIndex = position69, tokenIndex69
					}
					goto l66
				l67:
					position, tokenIndex = position66, tokenIndex66
					{
						position78, tokenIndex78 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l79
						}
						position++
						goto l78
					l79:
						position, tokenIndex = position78, tokenIndex78
						if buffer[position] != rune('D') {
							goto l64
						}
						position++
					}
				l78:
					{
						add(ruleAction15, position)
					}
					if !_rules[rulee4]() {
						goto l64
					}
					{
						position81, tokenIndex81 := position, tokenIndex
						if buffer[position] != rune('k') {
							goto l81
						}
						position++
						if !_rules[rulee4]() {
							goto l81
						}
						goto l82
					l81:
						position, tokenIndex = position81, tokenIndex81
					}
				l82:
					{
						add(ruleAction16, position)
					}
				l76:
					{
						position77, tokenIndex77 := position, tokenIndex
						{
							position84, tokenIndex84 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l85
							}
							position++
							goto l84
						l85:
							position, tokenIndex = position84, tokenIndex84
							if buffer[position] != rune('D') {
								goto l77
							}
							position++
						}
					l84:
						{
							add(ruleAction15, position)
						}
						if !_rules[rulee4]() {
							goto l77
						}
						{
							position87, tokenIndex87 := position, tokenIndex
							if buffer[position] != rune('k') {
								goto l87
							}
							position++
							if !_rules[rulee4]() {
								goto l87
							}
							goto l88
						l87:
							position, tokenIndex = position87, tokenIndex87
						}
					l88:
						{
							add(ruleAction16, position)
						}
						goto l76
					l77:
						position, tokenIndex = position77, tokenIndex77
					}
				}
			l66:
				add(ruleeDice, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 5 e4 <- <((minus value Action17) / value)> */
		func() bool {
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				{
					position92, tokenIndex92 := position, tokenIndex
					if !_rules[ruleminus]() {
						goto l93
					}
					if !_rules[rulevalue]() {
						goto l93
					}
					{
						add(ruleAction17, position)
					}
					goto l92
				l93:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[rulevalue]() {
						goto l90
					}
				}
			l92:
				add(rulee4, position91)
			}
			return true
		l90:
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 6 value <- <((number Action18) / (identifier Action19) / sub)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97, tokenIndex97 := position, tokenIndex
					{
						position99 := position
						{
							position100 := position
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l98
							}
							position++
						l101:
							{
								position102, tokenIndex102 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l102
								}
								position++
								goto l101
							l102:
								position, tokenIndex = position102, tokenIndex102
							}
							add(rulePegText, position100)
						}
						if !_rules[rulesp]() {
							goto l98
						}
						add(rulenumber, position99)
					}
					{
						add(ruleAction18, position)
					}
					goto l97
				l98:
					position, tokenIndex = position97, tokenIndex97
					{
						position105 := position
						{
							position106, tokenIndex106 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l106
							}
							position++
							goto l104
						l106:
							position, tokenIndex = position106, tokenIndex106
						}
						{
							position107 := position
							{
								position110, tokenIndex110 := position, tokenIndex
								{
									position111, tokenIndex111 := position, tokenIndex
									if buffer[position] != rune('!') {
										goto l112
									}
									position++
									goto l111
								l112:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('"') {
										goto l113
									}
									position++
									goto l111
								l113:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('#') {
										goto l114
									}
									position++
									goto l111
								l114:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('$') {
										goto l115
									}
									position++
									goto l111
								l115:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('%') {
										goto l116
									}
									position++
									goto l111
								l116:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('&') {
										goto l117
									}
									position++
									goto l111
								l117:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('\'') {
										goto l118
									}
									position++
									goto l111
								l118:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('(') {
										goto l119
									}
									position++
									goto l111
								l119:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune(')') {
										goto l120
									}
									position++
									goto l111
								l120:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('*') {
										goto l121
									}
									position++
									goto l111
								l121:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('+') {
										goto l122
									}
									position++
									goto l111
								l122:
									position, tokenIndex = position111, tokenIndex111
									if c := buffer[position]; c < rune(',') || c > rune('.') {
										goto l123
									}
									position++
									goto l111
								l123:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('/') {
										goto l124
									}
									position++
									goto l111
								l124:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune(':') {
										goto l125
									}
									position++
									goto l111
								l125:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune(';') {
										goto l126
									}
									position++
									goto l111
								l126:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('<') {
										goto l127
									}
									position++
									goto l111
								l127:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('=') {
										goto l128
									}
									position++
									goto l111
								l128:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('>') {
										goto l129
									}
									position++
									goto l111
								l129:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('?') {
										goto l130
									}
									position++
									goto l111
								l130:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('@') {
										goto l131
									}
									position++
									goto l111
								l131:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('[') {
										goto l132
									}
									position++
									goto l111
								l132:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('\\') {
										goto l133
									}
									position++
									goto l111
								l133:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune(']') {
										goto l134
									}
									position++
									goto l111
								l134:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('^') {
										goto l135
									}
									position++
									goto l111
								l135:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('_') {
										goto l136
									}
									position++
									goto l111
								l136:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('`') {
										goto l137
									}
									position++
									goto l111
								l137:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('{') {
										goto l138
									}
									position++
									goto l111
								l138:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('|') {
										goto l139
									}
									position++
									goto l111
								l139:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('}') {
										goto l140
									}
									position++
									goto l111
								l140:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('~') {
										goto l141
									}
									position++
									goto l111
								l141:
									position, tokenIndex = position111, tokenIndex111
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l142
									}
									position++
									goto l111
								l142:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune(' ') {
										goto l143
									}
									position++
									goto l111
								l143:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('\t') {
										goto l144
									}
									position++
									goto l111
								l144:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('\n') {
										goto l145
									}
									position++
									goto l111
								l145:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('\r') {
										goto l110
									}
									position++
								}
							l111:
								goto l104
							l110:
								position, tokenIndex = position110, tokenIndex110
							}
							if !matchDot() {
								goto l104
							}
						l108:
							{
								position109, tokenIndex109 := position, tokenIndex
								{
									position146, tokenIndex146 := position, tokenIndex
									{
										position147, tokenIndex147 := position, tokenIndex
										if buffer[position] != rune('!') {
											goto l148
										}
										position++
										goto l147
									l148:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('"') {
											goto l149
										}
										position++
										goto l147
									l149:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('#') {
											goto l150
										}
										position++
										goto l147
									l150:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('$') {
											goto l151
										}
										position++
										goto l147
									l151:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('%') {
											goto l152
										}
										position++
										goto l147
									l152:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('&') {
											goto l153
										}
										position++
										goto l147
									l153:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('\'') {
											goto l154
										}
										position++
										goto l147
									l154:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('(') {
											goto l155
										}
										position++
										goto l147
									l155:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune(')') {
											goto l156
										}
										position++
										goto l147
									l156:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('*') {
											goto l157
										}
										position++
										goto l147
									l157:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('+') {
											goto l158
										}
										position++
										goto l147
									l158:
										position, tokenIndex = position147, tokenIndex147
										if c := buffer[position]; c < rune(',') || c > rune('.') {
											goto l159
										}
										position++
										goto l147
									l159:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('/') {
											goto l160
										}
										position++
										goto l147
									l160:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune(':') {
											goto l161
										}
										position++
										goto l147
									l161:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune(';') {
											goto l162
										}
										position++
										goto l147
									l162:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('<') {
											goto l163
										}
										position++
										goto l147
									l163:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('=') {
											goto l164
										}
										position++
										goto l147
									l164:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('>') {
											goto l165
										}
										position++
										goto l147
									l165:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('?') {
											goto l166
										}
										position++
										goto l147
									l166:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('@') {
											goto l167
										}
										position++
										goto l147
									l167:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('[') {
											goto l168
										}
										position++
										goto l147
									l168:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('\\') {
											goto l169
										}
										position++
										goto l147
									l169:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune(']') {
											goto l170
										}
										position++
										goto l147
									l170:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('^') {
											goto l171
										}
										position++
										goto l147
									l171:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('_') {
											goto l172
										}
										position++
										goto l147
									l172:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('`') {
											goto l173
										}
										position++
										goto l147
									l173:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('{') {
											goto l174
										}
										position++
										goto l147
									l174:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('|') {
											goto l175
										}
										position++
										goto l147
									l175:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('}') {
											goto l176
										}
										position++
										goto l147
									l176:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('~') {
											goto l177
										}
										position++
										goto l147
									l177:
										position, tokenIndex = position147, tokenIndex147
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l178
										}
										position++
										goto l147
									l178:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune(' ') {
											goto l179
										}
										position++
										goto l147
									l179:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('\t') {
											goto l180
										}
										position++
										goto l147
									l180:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('\n') {
											goto l181
										}
										position++
										goto l147
									l181:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('\r') {
											goto l146
										}
										position++
									}
								l147:
									goto l109
								l146:
									position, tokenIndex = position146, tokenIndex146
								}
								if !matchDot() {
									goto l109
								}
								goto l108
							l109:
								position, tokenIndex = position109, tokenIndex109
							}
							add(rulePegText, position107)
						}
						if !_rules[rulesp]() {
							goto l104
						}
						add(ruleidentifier, position105)
					}
					{
						add(ruleAction19, position)
					}
					goto l97
				l104:
					position, tokenIndex = position97, tokenIndex97
					{
						position183 := position
						{
							position184 := position
							if buffer[position] != rune('(') {
								goto l95
							}
							position++
							if !_rules[rulesp]() {
								goto l95
							}
							add(ruleopen, position184)
						}
						if !_rules[rulee1]() {
							goto l95
						}
						{
							position185 := position
							if buffer[position] != rune(')') {
								goto l95
							}
							position++
							if !_rules[rulesp]() {
								goto l95
							}
							add(ruleclose, position185)
						}
						add(rulesub, position183)
					}
				}
			l97:
				add(rulevalue, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 7 number <- <(<[0-9]+> sp)> */
		nil,
		/* 8 identifier <- <(!'d' <(!('!' / '"' / '#' / '$' / '%' / '&' / '\'' / '(' / ')' / '*' / '+' / [,-.] / '/' / ':' / ';' / '<' / '=' / '>' / '?' / '@' / '[' / '\\' / ']' / '^' / '_' / '`' / '{' / '|' / '}' / '~' / [0-9] / ' ' / '\t' / '\n' / '\r') .)+> sp)> */
		nil,
		/* 9 sub <- <(open e1 close)> */
		nil,
		/* 10 add <- <('+' sp)> */
		nil,
		/* 11 minus <- <('-' sp)> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if buffer[position] != rune('-') {
					goto l190
				}
				position++
				if !_rules[rulesp]() {
					goto l190
				}
				add(ruleminus, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 12 multiply <- <('*' sp)> */
		nil,
		/* 13 divide <- <('/' sp)> */
		nil,
		/* 14 modulus <- <('%' sp)> */
		nil,
		/* 15 exponentiation <- <(('^' sp) / ('*' '*' sp))> */
		nil,
		/* 16 open <- <('(' sp)> */
		nil,
		/* 17 close <- <(')' sp)> */
		nil,
		/* 18 sp <- <(' ' / '\t')*> */
		func() bool {
			{
				position199 := position
			l200:
				{
					position201, tokenIndex201 := position, tokenIndex
					{
						position202, tokenIndex202 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l203
						}
						position++
						goto l202
					l203:
						position, tokenIndex = position202, tokenIndex202
						if buffer[position] != rune('\t') {
							goto l201
						}
						position++
					}
				l202:
					goto l200
				l201:
					position, tokenIndex = position201, tokenIndex201
				}
				add(rulesp, position199)
			}
			return true
		},
		/* 19 fstring <- <('`' <(('{' sp e1 sp '}') / escape / (!('`' / '\\' / '\n' / '\r') .))*> '`' sp Action20)> */
		nil,
		/* 20 escape <- <('\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\'' / '\\'))> */
		nil,
		/* 22 Action0 <- <{ p.AddOperator(TypeHalt) }> */
		nil,
		/* 23 Action1 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 24 Action2 <- <{ p.AddOperator(TypeAdd) }> */
		nil,
		/* 25 Action3 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 26 Action4 <- <{ p.AddOperator(TypeSubtract) }> */
		nil,
		/* 27 Action5 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 28 Action6 <- <{ p.AddOperator(TypeMultiply) }> */
		nil,
		/* 29 Action7 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 30 Action8 <- <{ p.AddOperator(TypeDivide) }> */
		nil,
		/* 31 Action9 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 32 Action10 <- <{ p.AddOperator(TypeModulus) }> */
		nil,
		/* 33 Action11 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 34 Action12 <- <{ p.AddOperator(TypeExponentiation) }> */
		nil,
		/* 35 Action13 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 36 Action14 <- <{ p.AddOperator(TypeDice) }> */
		nil,
		/* 37 Action15 <- <{ p.AddLeftValueMark() }> */
		nil,
		/* 38 Action16 <- <{ p.AddValue("1"); p.AddOperator(TypeSwap); p.AddOperator(TypeDice) }> */
		nil,
		/* 39 Action17 <- <{ p.AddOperator(TypeNegation) }> */
		nil,
		/* 40 Action18 <- <{ p.AddValue(string(text)) }> */
		nil,
		/* 41 Action19 <- <{ p.AddLoadVarname(string(text)) }> */
		nil,
		nil,
		/* 43 Action20 <- <{ p.AddFormatString(string(text)) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
